--1. Write a PL/SQL block to calculate the incentive of an employee whose ID is 110.

DECLARE
  incentive   NUMBER(8,2);
BEGIN
  SELECT salary * 0.12 INTO incentive
  FROM hr.employees
  WHERE employee_id = 110;
DBMS_OUTPUT.PUT_LINE('Incentive  = ' || TO_CHAR(incentive));
END;


--2. Write a PL/SQL block to show an invalid case-insensitive reference to a quoted and without 
--quoted user-defined identifier.

----1
DECLARE
  "WELCOME" varchar2(10) := 'welcome'; -- identifier with quotation 
BEGIN
  DBMS_Output.Put_Line("Welcome"); --reference to the identifier with quotation and different case
END;
/

----2
DECLARE
  WELCOME varchar2(10) := 'welcome'; -- identifier without quotation
BEGIN
  DBMS_Output.Put_Line("Welcome"); --reference to the identifier with quotation and different case
END;
/


--3. Write a PL/SQL block to show a reserved word can be used as a user-define identifier.

DECLARE
  "DECLARE" varchar2(25) := 'This is UPPERCASE';
  "Declare" varchar2(25) := 'This is Proper Case';
  "declare" varchar2(25) := 'This is lowercase';
BEGIN
  DBMS_Output.Put_Line("DECLARE");
  DBMS_Output.Put_Line("Declare");
  DBMS_Output.Put_Line("declare");
END;
/

--4. Write a PL/SQL block to show the result to neglect double quotation marks in reserved word identifier.

--In the example below  he references should be a quoted user-defined identifier which 
--is a reserved word and also have been neglected to enclose it in double quotation marks.

DECLARE
  "WORLD" varchar2(20) := 'world';  -- WORLD is not a reserved word
  "DECLARE" varchar2(20) := 'declare';  -- DECLARE is a reserved word
BEGIN
  DBMS_Output.Put_Line(WORLD);      -- Double quotation marks are optional
  DBMS_Output.Put_Line("DECLARE");      -- Double quotation marks are required
end;

           

--5. Write a PL/SQL block to show the result to neglect the case sensitivity of a user defined identifier 
--which is also a reserved word.

--In the example below the reference is a quoted user-defined identifier which is also a reserved word, 
--neglecting its case-sensitivity.

DECLARE
  "WORLD" varchar2(10) := 'world';  -- WORLD is not a reserved word
  "DECLARE" varchar2(10) := 'declare';  -- DECLARE is a reserved word
BEGIN
  DBMS_Output.Put_Line(World);      -- Identifier is case-insensitive
  DBMS_Output.Put_Line("Declare");      -- Identifier is case-sensitive
end;



--6. Write a PL/SQL block to explain single and multiline comments.

DECLARE
  some_condition  BOOLEAN;
  pi              NUMBER := 3.1415926; -- the value of pi is 3.1415926 : this is single line comment
  radius          NUMBER := 10;
  area            NUMBER;
BEGIN
 
  IF 2 + 2 = 4 THEN
    some_condition := TRUE;
  /* IF is the simple control flow statement  : this is multi line comment*/
  END IF;
 
  /* The line below in the statement computes the area of a circle.
  After the area is computed, the result is displayed. : : this is multi line comment*/
 
  area := pi * radius**2;
  DBMS_OUTPUT.PUT_LINE('The area of the circle is: ' || area);
END;


--7. Write PL/SQL blocks to show the declaration of variables.

DECLARE
  item_number       NUMBER(5);     -- SQL data type
  item_name         VARCHAR2(20);  -- SQL data type
  stock_yn          BOOLEAN;       -- PL/SQL-only data type
  item_rate        NUMBER(8,2);   -- SQL data type
  item_description  VARCHAR2(40);  -- SQL data type
BEGIN
  NULL;
END;


--Declaration of constant with scalar data type.
DECLARE
  maximum_deposit     CONSTANT REAL    := 25000.00;  -- SQL data type
  min_no_of_days CONSTANT INTEGER := 75;      -- SQL data type
  nominee_yn     CONSTANT BOOLEAN := FALSE;    -- PL/SQL-only data type
BEGIN
  NULL;
END;
/

--Declaration of variable with initial value

DECLARE
  worked_no_of_days    INTEGER := 15;
  employee_no          INTEGER := 0;
  pi     CONSTANT REAL := 3.14159;
  radius          REAL := 10;
  area            REAL := (pi * radius**2);
BEGIN
  NULL;
END;

--

--Initialize NULL by default to variable.

DECLARE
  ctr INTEGER;  -- initial value is NULL by default
BEGIN
  ctr := ctr + 1;  -- NULL + 1 is still NULL
  
  IF ctr IS NULL THEN
    DBMS_OUTPUT.PUT_LINE('The counter ctr is NULL.' || ctr);
  END IF;
END;
/

--Declaration of variable with NOT NULL Constraint

DECLARE
  acc_no INTEGER(5) NOT NULL  := 9999;
  x NATURALN                  := 9999;
  y POSITIVEN                 := 9999;
  z SIMPLE_INTEGER            := 9999;
BEGIN
  NULL;
END;
--These are subtypes of the NUMBER datatype in PL/SQL, designed for better performance and 
-stricter value constraints.


--In the following example the variable first_name  inherits the data type and size of the column 
--employees.first_name, which has a NOT NULL constraint and this declaration does not need an initial value.

DECLARE
  first_name  employees.first_name%TYPE;
BEGIN
  DBMS_OUTPUT.PUT_LINE('First Name = ' || first_name);
END;
/


--8. Write PL/SQL blocks to show the scope and visibility of local and global identifiers.

----1
DECLARE
  var_a integer;  -- Scope of var_a is INTEGER beginning
  var_b REAL;    -- Scope of var_b is REAL 
BEGIN
  var_a:=5.2;
  var_b:=10.25;
  -- Visible: var_a (INTEGER), var_b (REAL)
  DBMS_OUTPUT.PUT_LINE('In the Outer Block');
  DBMS_OUTPUT.PUT_LINE('var_a = ' || var_a); -- var_a  is INTEGER
  DBMS_OUTPUT.PUT_LINE('var_b = ' || var_b); -- var_b is REAL


  -- Start First sub-block:
  DECLARE
    var_a CHAR;  -- Scope of var_a have changed into CHAR and beginning from here
    var_c REAL;       -- Scope of var_c is REAL
  BEGIN
    var_a:='C';
    var_c:=15.50;

    -- Visible: var_a (CHAR), var_b (REAL), var_c (REAL)
    DBMS_OUTPUT.PUT_LINE('In the First sub-Block');
    DBMS_OUTPUT.PUT_LINE('var_a = ' || var_a); -- var_a is CHAR
    DBMS_OUTPUT.PUT_LINE('var_b = ' || var_b); -- var_b is REAL
    DBMS_OUTPUT.PUT_LINE('var_c = ' || var_c); -- var_c is REAL
    NULL;
  END;          --  ending first sub-block

  -- Start Second sub-block:
  DECLARE
    var_d REAL;     -- Scope of var_d beginning from here with REAL
  BEGIN
    -- Visible: var_a here is CHAR and  var_b is REAL AND  var_d is REAL
    var_d:=20.75;
    DBMS_OUTPUT.PUT_LINE('In the Second sub-Block');
    DBMS_OUTPUT.PUT_LINE('var_a = ' || var_a); -- var_a is CHAR
    DBMS_OUTPUT.PUT_LINE('var_b = ' || var_b); -- var_b is REAL
    DBMS_OUTPUT.PUT_LINE('var_d = ' || var_d); -- var_d is REAL
    NULL;
  END;          -- ending second sub-block

-- Visible: var_a is INTEGER and var_b is REAL
-- This is also in the Outer Block
DBMS_OUTPUT.PUT_LINE('At the end in the  Outer-Block');
DBMS_OUTPUT.PUT_LINE('var_a = ' || var_a); -- var_a  is INTEGER
DBMS_OUTPUT.PUT_LINE('var_b = ' || var_b); -- var_b is REAL
END;            --   ending the outer block
/


----2
-- Package Specification
CREATE OR REPLACE PACKAGE demo_package AS
    global_var NUMBER := 100; -- Global variable (accessible in package body and procedures)
END demo_package;
/

-- Package Body
CREATE OR REPLACE PACKAGE BODY demo_package AS
END demo_package;
/

-- PL/SQL Block to Demonstrate Scope and Visibility
DECLARE
    local_var NUMBER := 50; -- Local variable (only accessible in this block)
BEGIN
    -- Accessing both local and global variables
    DBMS_OUTPUT.PUT_LINE('Local Variable: ' || local_var);
    DBMS_OUTPUT.PUT_LINE('Global Variable: ' || demo_package.global_var);

    -- Changing the value of the local variable
    local_var := local_var + 10;
    DBMS_OUTPUT.PUT_LINE('Updated Local Variable: ' || local_var);

    -- Changing the value of the global variable (invalid in an anonymous block)
    -- Uncommenting the below line will cause an error:
    -- demo_package.global_var := demo_package.global_var + 20;

    -- Nested block to demonstrate further scope
    DECLARE
        nested_local_var NUMBER := 25; -- Local to the nested block
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Nested Local Variable: ' || nested_local_var);
        DBMS_OUTPUT.PUT_LINE('Accessing Global Variable from Nested Block: ' || demo_package.global_var);

        -- Accessing outer block's local variable
        DBMS_OUTPUT.PUT_LINE('Accessing Outer Local Variable: ' || local_var);

        -- Changing the nested local variable
        nested_local_var := nested_local_var * 2;
        DBMS_OUTPUT.PUT_LINE('Updated Nested Local Variable: ' || nested_local_var);
    END;

    -- Trying to access nested block variable (will cause an error if uncommented)
    -- DBMS_OUTPUT.PUT_LINE('Access Nested Variable: ' || nested_local_var);
END;
/

--9. Write a PL/SQL block to show a valid case-insensitive reference to a quoted and without quoted 
--user-defined identifier.

----1
--When identifier is enclosing with double quotation and reference to the identifier is without quoted:
DECLARE
  "WELCOME" varchar2(10) := 'welcome'; -- identifier with quotation 
BEGIN
  DBMS_Output.Put_Line(Welcome); --reference to the identifier without quotation
END;
/

----2
--When identifier is enclosing without double quotation and reference to the identifier is without quoted:
DECLARE
  WELCOME varchar2(10) := 'welcome'; -- identifier without quotation 
BEGIN
  DBMS_Output.Put_Line(Welcome);-- reference to the identifier without quotation
END;
/

--10. Write a PL/SQL block to adjust the salary of the employee whose ID 122.

DECLARE
  salary_of_emp  NUMBER(8,2);
 
  PROCEDURE approx_salary (
    emp        NUMBER, 
    empsal IN OUT NUMBER,
    addless     NUMBER
  ) IS
  BEGIN
    empsal := empsal + addless;
  END;
 
BEGIN
  SELECT salary INTO salary_of_emp
  FROM hr.employees
  WHERE employee_id = 122;
 
  DBMS_OUTPUT.PUT_LINE
   ('Before invoking procedure, salary_of_emp: ' || salary_of_emp);
 
  approx_salary (100, salary_of_emp, 1000);
 
  DBMS_OUTPUT.PUT_LINE
   ('After invoking procedure, salary_of_emp: ' || salary_of_emp);
END;
/

--11. Write a PL/SQL block to show the operator precedence and parentheses in several more complex expressions.

DECLARE
  salary      NUMBER := 40000;
  commission  NUMBER := 0.15;
BEGIN
  -- Division has higher precedence than addition:
  
  DBMS_OUTPUT.PUT_LINE('8 + 20 / 4 = ' || (8 + 20 / 4));
  DBMS_OUTPUT.PUT_LINE('20 / 4 + 8 = ' || (20 / 4 + 8));
  
 -- Parentheses override default operator precedence:
 
  DBMS_OUTPUT.PUT_LINE('7 + 9 / 3 = ' || (7 + 9 / 3));
  DBMS_OUTPUT.PUT_LINE('(7 + 9) / 3 = ' || ((7 + 9) / 3));
 
  -- Most deeply nested operation is evaluated first:
 
  DBMS_OUTPUT.PUT_LINE('30 + (30 / 6 + (15 - 8)) = '
                      || (30 + (30 / 6 + (15 - 8))));
 
  -- Parentheses, even when unnecessary, improve readability:
 
  DBMS_OUTPUT.PUT_LINE('(salary * 0.08) + (commission * 0.12) = '
    || ((salary * 0.08) + (commission * 0.12))
  );
 
  DBMS_OUTPUT.PUT_LINE('salary * 0.08 + commission * 0.12 = '
    || (salary * 0.08 + commission * 0.12)
  );
END;
/

--12. Write a PL/SQL block to create a procedure using the "IS [NOT] NULL Operator" and show 
--AND operator returns TRUE if and only if both operands are TRUE.

--Here is the procedure :

CREATE OR REPLACE PROCEDURE pri_bool(
  boo_name   VARCHAR2,
  boo_val    BOOLEAN
) IS
BEGIN
  IF boo_val IS NULL THEN
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = NULL');
  ELSIF boo_val = TRUE THEN
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = TRUE');
  ELSE
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = FALSE');
  END IF;
END;

--Now call the procedure pri_bool:

DECLARE
  PROCEDURE pri_m_and_n (
    m  BOOLEAN,
    n  BOOLEAN
  ) IS
  BEGIN
   pri_bool ('m', m);
   pri_bool ('n', n);
   pri_bool ('m AND n', m AND n);
 END pri_m_and_n;
 
BEGIN
DBMS_OUTPUT.PUT_LINE('------------- FOR m and n both FALSE ---------------------');
 pri_m_and_n (FALSE, FALSE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m TRUE AND n FALSE ---------------------');
 pri_m_and_n (TRUE, FALSE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m FALSE AND n TRUE ---------------------');
 pri_m_and_n (FALSE, TRUE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m TRUE AND n TRUE ---------------------');
 pri_m_and_n (TRUE, TRUE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m TRUE AND n NULL ---------------------');
 pri_m_and_n (TRUE, NULL);
DBMS_OUTPUT.PUT_LINE('------------- FOR m FALSE AND n NULL---------------------');
 pri_m_and_n (FALSE, NULL);
DBMS_OUTPUT.PUT_LINE('------------- FOR m NULL AND n TRUE ---------------------');
 pri_m_and_n (NULL, TRUE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m NULL AND n FALSE ---------------------');
 pri_m_and_n (NULL, FALSE);
END;


--13. Write a PL/SQL block to create a procedure using the "IS [NOT] NULL Operator" and show 
--OR operator returns TRUE if either operand is TRUE.

----Here is the procedure :

CREATE OR REPLACE PROCEDURE pri_bool(
  boo_name   VARCHAR2,
  boo_val    BOOLEAN
) IS
BEGIN
  IF boo_val IS NULL THEN
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = NULL');
  ELSIF boo_val = TRUE THEN
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = TRUE');
  ELSE
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = FALSE');
  END IF;
END;

--Now call the procedure pri_bool:

DECLARE
  PROCEDURE pri_m_or_n (
    m  BOOLEAN,
    n  BOOLEAN
  ) IS
  BEGIN
   pri_bool ('m', m);
   pri_bool ('n', n);
   pri_bool ('m OR n', m OR n);
 END pri_m_or_n;
BEGIN
DBMS_OUTPUT.PUT_LINE('------------- FOR m OR n both FALSE ---------------------');
 pri_m_or_n (FALSE, FALSE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m TRUE OR n FALSE ---------------------');
 pri_m_or_n (TRUE, FALSE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m FALSE OR n TRUE ---------------------');
 pri_m_or_n (FALSE, TRUE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m TRUE OR n TRUE ---------------------');
 pri_m_or_n (TRUE, TRUE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m TRUE OR n NULL ---------------------');
 pri_m_or_n (TRUE, NULL);
DBMS_OUTPUT.PUT_LINE('------------- FOR m FALSE OR n NULL---------------------');
 pri_m_or_n (FALSE, NULL);
DBMS_OUTPUT.PUT_LINE('------------- FOR m NULL OR n TRUE ---------------------');
 pri_m_or_n (NULL, TRUE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m NULL OR n FALSE ---------------------');
 pri_m_or_n (NULL, FALSE);
END;

--14. Write a PL/SQL block to create a procedure using the "IS [NOT] NULL Operator" and show 
--NOT operator returns the opposite of its operand, unless the operand is NULL.

--Here is the procedure:

CREATE OR REPLACE PROCEDURE pri_bool(
  boo_name   VARCHAR2,
  boo_val    BOOLEAN
) IS
BEGIN
  IF boo_val IS NULL THEN
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = NULL');
  ELSIF boo_val = TRUE THEN
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = TRUE');
  ELSE
    DBMS_OUTPUT.PUT_LINE( boo_name || ' = FALSE');
  END IF;
END;

--Now call the procedure pri_bool:

DECLARE
  PROCEDURE pri_not_m (
    m  BOOLEAN
  ) IS
  BEGIN
    pri_bool ('m', m);
    pri_bool ('NOT m', NOT m);
  END pri_not_m;
 
BEGIN
DBMS_OUTPUT.PUT_LINE('------------- FOR m TRUE ---------------------');
  pri_not_m (TRUE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m FALSE ---------------------');
  pri_not_m (FALSE);
DBMS_OUTPUT.PUT_LINE('------------- FOR m NULL ---------------------');
  pri_not_m (NULL);
END;


--15. Write a PL/SQL block to describe the usage of NULL values in equal comparison, 
--unequal comparison and NOT NULL equals NULL comparison.

DECLARE
  m NUMBER := 7;
  n NUMBER := NULL;

  o NUMBER := NULL;
  p NUMBER := NULL;

  q    INTEGER := 4;
  r    INTEGER := 9;

 large INTEGER;

----------------------------------
BEGIN
  IF m != n THEN  -- yields NULL, not TRUE
    DBMS_OUTPUT.PUT_LINE('m != n');  -- not run
  ELSIF m = n THEN -- also yields NULL
    DBMS_OUTPUT.PUT_LINE('m = n');
  ELSE
    DBMS_OUTPUT.PUT_LINE
      ('Can not say whether m and n are equal or not.');
  END IF;

-----------------------------------
  IF o = p THEN  -- yields NULL, not TRUE
    DBMS_OUTPUT.PUT_LINE('o = p');  -- not run
  ELSIF o != p THEN  -- yields NULL, not TRUE
    DBMS_OUTPUT.PUT_LINE('o != p');  -- not run
  ELSE
    DBMS_OUTPUT.PUT_LINE('Can not say whether two NULLs are equal');
  END IF;
--------------------------------------
  IF (q > r)       -- If q or r is NULL, then (q > r) is NULL
    THEN large  := q;  -- run if (q > r) is TRUE
    ELSE large  := r;  -- run if (q > r) is FALSE or NULL
DBMS_OUTPUT.PUT_LINE('The value of large : '||large);
  END IF;
  
  IF NOT (q > r)   -- If q or r is NULL, then NOT (q > r) is NULL
    THEN large  := r;  -- run if NOT (q > r) is TRUE
    ELSE large  := q;  -- run if NOT (q > r) is FALSE or NULL
DBMS_OUTPUT.PUT_LINE('The value of large : '||large);
  END IF;

END;


--16.Write a PL/SQL block to describe the usage of LIKE operator including wildcard characters and escape character.

DECLARE
  PROCEDURE pat_match (
    test_string   VARCHAR2,
    pattern       VARCHAR2
  ) IS
  BEGIN
    IF test_string LIKE pattern THEN
      DBMS_OUTPUT.PUT_LINE ('TRUE');
    ELSE
      DBMS_OUTPUT.PUT_LINE ('FALSE');
    END IF;
  END;
BEGIN
  pat_match('Blweate', 'B%a_e');
  pat_match('Blweate', 'B%A_E');
END;





--------------------------------------------- DataType ------------------------------------------
-------------------------------------------------------------------------------------------------

--1. Write a PL/SQL block to learn how to declare a character type variable.

----1
DECLARE
  c VARCHAR2(8 CHAR);
BEGIN
  c := 'abc  ';
END;
/
----2
--or can also be declare like this-

DECLARE
  c VARCHAR2(8);
BEGIN
  c := 'abc  ';
END;
/

----3
--if you declare like this and used to insert too long data, see an error message will appear.

DECLARE
  c VARCHAR2(3);
BEGIN
  c := 'abc  ';
END;

--2. Write a PL/SQL block to insert data to a table using character type variable.

DROP TABLE test;
CREATE TABLE test (col1 CHAR(5));
 
DECLARE
  var1 VARCHAR2(5 CHAR) := 'abc ';
BEGIN
  INSERT INTO test(col1) VALUES(var1);
END;
/

--3. Write a PL/SQL block to differenciate between CHAR and VARCHAR2 datatype.

SET SERVEROUTPUT ON;
DECLARE
  f_name  CHAR(15 CHAR);
  l_name   VARCHAR2(15 CHAR);
BEGIN
  f_name := 'Allen  ';
  l_name  := 'Munra  ';
 
  DBMS_OUTPUT.PUT_LINE('*' || f_name || '*');
  DBMS_OUTPUT.PUT_LINE('*' || l_name || '*');
END;
/

--4. Write a PL/SQL procedure to accepts a BOOLEAN parameter and uses a CASE statement to 
--print Unknown if the value of the parameter is NULL, Yes if it is TRUE, and No if it is FALSE.

CREATE PROCEDURE use_of_boolean1 (bl BOOLEAN) AUTHID DEFINER
AS
BEGIN
  DBMS_OUTPUT.put_line (
    CASE
      WHEN bl IS NULL THEN 'Unknown'
      WHEN bl THEN 'Yes'
      WHEN NOT bl THEN 'No'
    END
  );
END;
/

begin
  use_of_boolean1(true);
  end;

--5. Write a PL/SQL program to show the upper limit of PLS_INTEGER.

DECLARE
  n1 PLS_INTEGER := 2147483647;
  n2 PLS_INTEGER := 1;
  s NUMBER;
BEGIN
  s := n1 + n2;
END;
/

--6. Write a PL/SQL program to show the uses of SIMPLE_INTEGER datatype.

DECLARE
  num SIMPLE_INTEGER := 2147483645;
BEGIN
  FOR j IN 1..4 LOOP
    num := num + 1;
    DBMS_OUTPUT.PUT_LINE(TO_CHAR(num, 'S9999999999'));
  END LOOP;
  FOR j IN 1..4 LOOP
   num := num - 1;
   DBMS_OUTPUT.PUT_LINE(TO_CHAR(num, 'S9999999999'));
  END LOOP;
END;
/

--7. Write a PL/SQL program to show the uses of an unconstrained subtype, i.e., the same set of 
--values as its base type.

SET SERVEROUTPUT ON
DECLARE
  SUBTYPE ac_bal IS NUMBER;

  chk_ac        ac_bal(6,2);
  sb_ac         ac_bal(8,2);
  depo_certificate  ac_bal(8,2);
  max_ins_amt  CONSTANT   ac_bal(8,2) := 300000.00;

  SUBTYPE ctr IS NATURAL;

  acno     ctr := 1;
  dep_amt     Ctr := 0;
  wth_amt  Ctr := 0;
  od_amt   Ctr := 0;

  PROCEDURE ac_deposit (
    acbal  IN OUT ac_bal,
    amt   IN     ac_bal
  ) IS
  BEGIN
    acbal  := acbal + amt;
    dep_amt := dep_amt + 1;
  END;
  
BEGIN
  NULL;
END;
/

--8. Write a PL/SQL program to show the uses of a constrained subtype.

DECLARE
 subtype constrained_bi
 IS
 binary_integer range 1..10;
 l_cbi_var1 constrained_bi;
 BEGIN
 l_cbi_var1:=8;
  dbms_output.put_line('The value assigned is:'||to_char(l_cbi_var1));
 END;
/


--------------------------------------Control Statement ---------------------------------
-----------------------------------------------------------------------------------------

--1. Write a PL/SQL program to arrange the number of two variable in such a way that the 
--small number will store in num_small variable and large number will store in num_large variable.

DECLARE
num_small NUMBER := 8;
num_large NUMBER := 5;
num_temp NUMBER;
BEGIN

IF num_small > num_large THEN
num_temp := num_small;
num_small := num_large;
num_large := num_temp;
END IF;

DBMS_OUTPUT.PUT_LINE ('num_small = '||num_small);
DBMS_OUTPUT.PUT_LINE ('num_large = '||num_large);
END;
/

--2. Write a PL/SQL procedure to calculate the incentive on a target achieved and display 
--the message either the record updated or not.

DECLARE
  PROCEDURE test1 (
    sal_achieve  NUMBER,
    target_qty  NUMBER,
    emp_id NUMBER
  )
  IS
    incentive   NUMBER := 0;
    updated  VARCHAR2(3) := 'No';
  BEGIN
    IF sal_achieve > (target_qty + 200) THEN
      incentive := (sal_achieve - target_qty)/4;
 
      UPDATE emp
      SET salary = salary + incentive 
      WHERE employee_id = emp_id;
 
      updated := 'Yes';
    END IF;
 
    DBMS_OUTPUT.PUT_LINE (
      'Table updated?  ' || updated || ', ' || 
      'incentive = ' || incentive || '.'
    );
  END test1;
BEGIN
  test1(2300, 2000, 144);
  test1(3600, 3000, 145);
END;
/

--3. Write a PL/SQL program to check whether a number is even or odd.

DECLARE
n1 NUMBER := &num1;
BEGIN
-- test if the number provided by the user is even
IF MOD(n1,2) = 0 THEN
DBMS_OUTPUT.PUT_LINE ('The number. '||n1||
' is even number');
ELSE
DBMS_OUTPUT.PUT_LINE ('The number '||n1||' is odd number.');
END IF;
DBMS_OUTPUT.PUT_LINE ('Done Successfully');
END;
/

--4. Write a PL/SQL procedure to calculate the incentive on a specific target otherwise a general 
--incentive to be paid using IF-THEN-ELSE.

DECLARE
  PROCEDURE test1 (
    sal_achieve  NUMBER,
    target_qty  NUMBER,
    emp_id NUMBER
  )
  IS
    incentive   NUMBER := 0;

  BEGIN
    IF sal_achieve > (target_qty + 200) THEN
      incentive := (sal_achieve - target_qty)/4;
ELSE
 incentive :=75;
END IF;
DBMS_OUTPUT.PUT_LINE ('incentive = ' || incentive);
      UPDATE emp
      SET salary = salary + incentive 
      WHERE employee_id = emp_id;
   
  END test1;
BEGIN
  test1(2300, 2000, 144);
  test1(3600, 3000, 145);
END;
/

--5. Write a PL/SQL program to check whether a date falls on weekend i.e. SATURDAY or SUNDAY.

DECLARE
dt1 DATE := TO_DATE('&new_dt', 'DD-MON-YYYY');
get_day VARCHAR2(15);
BEGIN
get_day := RTRIM(TO_CHAR(dt1, 'DAY'));
IF get_day IN ('SATURDAY', 'SUNDAY') THEN
dbms_output.new_line;
DBMS_OUTPUT.PUT_LINE 
('The day of the given date is '||get_day||' and it falls on weekend');
ELSE
dbms_output.new_line;
DBMS_OUTPUT.PUT_LINE ('The day of the given date is '||get_day||' and it does not fall on the weekend');
END IF;
DBMS_OUTPUT.PUT_LINE ('Execution  done successfully.');
END;
/

--6. Write a PL/SQL procedure to calculate incentive achieved according to the specific sale limit.

DECLARE
  PROCEDURE test1 (sal_achieve  NUMBER)
  IS
    incentive  NUMBER := 0;
  BEGIN 
    IF sal_achieve > 44000 THEN
      incentive := 1800;
    ELSIF sal_achieve > 32000 THEN
      incentive := 800;
    ELSE
      incentive := 500;
    END IF;
 DBMS_OUTPUT.NEW_LINE;
    DBMS_OUTPUT.PUT_LINE (
      'Sale achieved : ' || sal_achieve || ', incentive : ' || incentive || '.'
    );
  END test1;
BEGIN
  test1(45000);
  test1(36000);
  test1(28000);
END;
/


--7. Write a PL/SQL program to count number of employees in department 50 and check whether 
--this department have any vacancies or not. There are 45 vacancies in this department.

SET SERVEROUTPUT ON
DECLARE
    tot_emp NUMBER;
BEGIN
    SELECT Count(*)
    INTO   tot_emp
    FROM   employees e
           join departments d
             ON e.department_id = d.department_id
    WHERE  e.department_id = 50;

    dbms_output.Put_line ('The employees are in the department 50: '
                          ||To_char(tot_emp));

    IF tot_emp >= 45 THEN
      dbms_output.Put_line ('There are no vacancies in the department 50.');
    ELSE
      dbms_output.Put_line ('There are some vacancies in department 50.');
    END IF;
END; 
/

--8. Write a PL/SQL program to display the description against a grade.

DECLARE
    grd CHAR(1) ;
  BEGIN
    -- Accept value for grade
    grd := '&new_grd';
    IF grd = 'A' THEN
      dbms_output.Put_line('Your Grade is: Outstanding');
    ELSIF grd = 'B' THEN
      dbms_output.Put_line('Your Grade is: Excellent');
    ELSIF grd = 'C' THEN
      dbms_output.Put_line('Your Grade is: Very Good');
    ELSIF grd = 'D' THEN
      dbms_output. Put_line('Your Grade is: Average');
    ELSIF grd = 'F' THEN
      dbms_output.Put_line('Your Grade is: Poor');
    ELSE
      dbms_output.Put_line('No such grade in the list.');
    END IF;
  END;
/

--9. Write a PL/SQL program to count number of employees in a specific department and check 
--whether this department have any vacancies or not. If any vacancies, how many vacancies are in 
--that department.

SET SERVEROUTPUT ON
DECLARE
    tot_emp NUMBER;
	get_dep_id NUMBER;
	
BEGIN
    get_dep_id := '&new_dep_id';
    SELECT Count(*)
    INTO   tot_emp
    FROM   employees e
           join departments d
             ON e.department_id = d.department_id
    WHERE  e.department_id = get_dep_id;

    dbms_output.Put_line ('The employees are in the department '||get_dep_id||' is: '
                          ||To_char(tot_emp));

    IF tot_emp >= 45 THEN
      dbms_output.Put_line ('There are no vacancies in the department '||get_dep_id);
    ELSE
      dbms_output.Put_line ('There are '||to_char(45-tot_emp)||' vacancies in department '|| get_dep_id );
    END IF;
END; 
/

--10. Write a PL/SQL program to display the description against a grade using CASE statement.

DECLARE
    grd CHAR(1);
  BEGIN
    -- Accept value for grade
    grd := '&new_grd';
  CASE grd
    WHEN 'A' THEN dbms_output.Put_line('Your Grade is: Outstanding');
    WHEN 'B' THEN dbms_output.Put_line('Your Grade is: Excellent');
    WHEN 'C' THEN dbms_output.Put_line('Your Grade is: Very Good');
    WHEN 'D' THEN dbms_output. Put_line('Your Grade is: Average');
    WHEN 'F' THEN dbms_output.Put_line('Your Grade is: Poor');
    ELSE dbms_output.Put_line('No such grade in the list.');
  END CASE;	
  END;
/

--11. Write a PL/SQL program to display the description against a grade using CASE statement with EXCEPTION.

DECLARE
    grd CHAR(1);
  BEGIN
    -- Accept value for grade
    grd := '&new_grd';
  CASE 
    WHEN grd = 'A' THEN dbms_output.Put_line('Your Grade is: Outstanding');
    WHEN grd = 'B' THEN dbms_output.Put_line('Your Grade is: Excellent');
    WHEN grd = 'C' THEN dbms_output.Put_line('Your Grade is: Very Good');
    WHEN grd = 'D' THEN dbms_output.Put_line('Your Grade is: Average');
    WHEN grd = 'F' THEN dbms_output.Put_line('Your Grade is: Poor');
  END CASE;
EXCEPTION
  WHEN CASE_NOT_FOUND THEN
    dbms_output.Put_line('No such grade in the list.');
  END;
/

--12. Write a PL/SQL program to check whether a given number is positive, negative or zero.

DECLARE
num1 NUMBER := &get_num;
BEGIN
IF num1 < 0 THEN
DBMS_OUTPUT.PUT_LINE ('The number '||num1||' is a negative number');
ELSIF num1 = 0 THEN
DBMS_OUTPUT.PUT_LINE ('The number '||num1||' is equal to zero');
ELSE
DBMS_OUTPUT.PUT_LINE ('The number '||num1||' is a positive number');
END IF;
END;
/

--13. Write a PL/SQL program to check whether a given character is letter or digit.

DECLARE
    get_ctr CHAR(1) := '&input_a_character';
BEGIN
    IF ( get_ctr >= 'A'
         AND get_ctr <= 'Z' )
        OR ( get_ctr >= 'a'
             AND get_ctr <= 'z' ) THEN
      dbms_output.Put_line ('The given character is a letter');
    ELSE
      dbms_output.Put_line ('The given character is not a letter');

      IF get_ctr BETWEEN '0' AND '9' THEN
        dbms_output.Put_line ('The given character is a number');
      ELSE
        dbms_output.Put_line ('The given character is not a number');
      END IF;
    END IF;
END; 
/

--14. Write a PL/SQL program to convert a temperature in scale Fahrenheit to Celsius and vice versa

DECLARE
    temp1     NUMBER := &input_a_temp;
    t_scale   CHAR := '&input_temp_scale';
    new_temp  NUMBER;
    new_scale CHAR;
  BEGIN
    IF t_scale != 'C'
      AND
      t_scale != 'F' THEN
      dbms_output.Put_line ('The scale you input is not a valid scale');
      new_temp := 0;
      new_scale := 'C';
    ELSE
      IF t_scale = 'C' THEN
        new_temp := ( ( 9 * temp1 ) / 5 ) + 32;
        new_scale := 'F';
      ELSE
        new_temp := ( ( temp1 - 32 ) * 5 ) / 9;
        new_scale := 'C';
      END IF;
    END IF;
    dbms_output.Put_line ('The new temperature in scale '
    ||new_scale
    ||' is: '
    ||new_temp);
  END;
/

--15. Write a PL/SQL program to display which day is a specific date.

SET serveroutput ON
DECLARE
    t_dt  DATE := To_date('&input_a_date', 'DD-MON-YYYY');
    t_day VARCHAR2(1);
BEGIN
    t_day := To_char(t_dt, 'D');

    CASE t_day
      WHEN '1' THEN
        dbms_output.Put_line ('The date you entered is Sunday.');
      WHEN '2' THEN
        dbms_output.Put_line ('The date you entered is Monday.');
      WHEN '3' THEN
        dbms_output.Put_line ('The date you entered is Tuesday.');
      WHEN '4' THEN
        dbms_output.Put_line ('The date you entered is Wednesday.');
      WHEN '5' THEN
        dbms_output.Put_line ('The date you entered is Thursday.');
      WHEN '6' THEN
        dbms_output.Put_line ('The date you entered is Friday.');
      WHEN '7' THEN
        dbms_output.Put_line ('The date you entered is Saturday.');
    END CASE;
END; 
/

--16. Write a program in PL/SQL to print the value of a variable inside and outside a loop using LOOP EXIT statement.

DECLARE
  n NUMBER := 0;
BEGIN
  LOOP
    DBMS_OUTPUT.PUT_LINE ('The value of n inside the loop is:  ' || TO_CHAR(n));
    n := n + 1;
    IF n > 5 THEN
      EXIT;
    END IF;
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('The value of n outside the loop is: ' || TO_CHAR(n));
END;
/

--17. Write a program in PL/SQL to print the value of a variable inside and outside a loop 
--using LOOP WHEN EXIT statement.



DECLARE
  n NUMBER := 0;
BEGIN
  LOOP
    DBMS_OUTPUT.PUT_LINE('The value of n inside the loop is: ' || TO_CHAR(n));
    n := n + 1; 
    EXIT WHEN n > 5;
  END LOOP;
    DBMS_OUTPUT.PUT_LINE('The value of n after exit from the loop is: ' || TO_CHAR(n));
END;
/

--18. Write a program in PL/SQL to show the uses of nested loop.
DECLARE
  m  PLS_INTEGER := 0;
  n  PLS_INTEGER := 0;
  k  PLS_INTEGER;
BEGIN
  
  LOOP
    n := n + 1;
    k := 0;
DBMS_OUTPUT.PUT_LINE ('The values of inner loop are: ');	
    
    LOOP
      k := k + 1;
      m := m + n * k; -- Sum several products
  
      EXIT inner_loop WHEN (k > 3);
DBMS_OUTPUT.PUT_LINE ('n='||TO_CHAR(n)||'  k='||TO_CHAR(k)||'  m='||TO_CHAR(m));		  
      EXIT outer_loop WHEN ((n * k) > 6);
    END LOOP inner_loop;
  END LOOP outer_loop;
  DBMS_OUTPUT.PUT_LINE
    ('The total sum after completing the process is: ' || TO_CHAR(m));
END;
/

--19. Write a program in PL/SQL to update the salary of a specifc employee by 8% if the salary 
--exceeds the mid range of the salary against this job and update up to mid range if the salary 
--is less than the mid range of the salary, and display a suitable message.

DECLARE
  emp_min_salary NUMBER(6,0);
  emp_max_salary NUMBER(6,0);
  emp_mid_salary NUMBER(6,2);
  tmp_salary     EMPLOYEES.SALARY%TYPE;
  tmp_emp_id     EMPLOYEES.EMPLOYEE_ID%TYPE := 167;
  tmp_emp_name	 EMPLOYEES.FIRST_NAME%TYPE;
BEGIN

  SELECT min_salary,
         max_salary
  INTO emp_min_salary,
       emp_max_salary
  FROM JOBS
  WHERE JOB_ID = (SELECT JOB_ID
                 FROM EMPLOYEES
                 WHERE EMPLOYEE_ID = tmp_emp_id);
 
  -- calculate mid-range
  emp_mid_salary := (emp_min_salary + emp_max_salary) / 2;
  -- get salary of the given employee
  SELECT salary,first_name
  INTO tmp_salary,tmp_emp_name
  FROM employees
  WHERE employee_id = tmp_emp_id;
 
  -- update salary 
  
  IF tmp_salary < emp_mid_salary THEN
    UPDATE employees
    SET salary = emp_mid_salary
    WHERE employee_id = tmp_emp_id;
  ELSE
    UPDATE employees
    SET salary = salary + salary * 8 /100
    WHERE employee_id = tmp_emp_id;
  END IF;
   --display message
  IF tmp_salary > emp_mid_salary THEN
    DBMS_OUTPUT.PUT_LINE('The employee '||tmp_emp_name||' ID ' || TO_CHAR(tmp_emp_id) ||
                         ' works in salary ' || TO_CHAR(tmp_salary) ||
                         ' which is higher than mid-range of salary ' || TO_CHAR(emp_mid_salary));
  ELSIF tmp_salary < emp_mid_salary THEN
    DBMS_OUTPUT.PUT_LINE('The employee '||tmp_emp_name||' ID ' || TO_CHAR(tmp_emp_id) ||
                         ' works in salary ' || TO_CHAR(tmp_salary) ||
                         ' which is lower than mid-range of salary ' || TO_CHAR(emp_mid_salary));
 
  ELSE
    DBMS_OUTPUT.PUT_LINE('The employee '||tmp_emp_name||' ID ' || TO_CHAR(tmp_emp_id) ||
                         ' works in salary ' || TO_CHAR(tmp_salary) ||
                         ' which is equal to the mid-range of salary ' || TO_CHAR(emp_mid_salary));
  END IF;
END;
/
select * from hr.jobs;
--20. Write a program in PL/SQL using nested loop with EXIT WHEN statement.

DECLARE
  m PLS_INTEGER := 0;
  n PLS_INTEGER := 0;
 
BEGIN
  LOOP
    m := m + 1;
    DBMS_OUTPUT.PUT_LINE ('The value of m = ' || m);
    
    LOOP
      n := n + 1;
      DBMS_OUTPUT.PUT_LINE ('The value of n = ' || n);
      EXIT WHEN (n > 4);
    END LOOP;
 
    DBMS_OUTPUT.PUT_LINE ('Exited inner loop');
 
    EXIT WHEN (m > 3);
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE ('Exited outer loop');
END;
/

--21. Write a program in PL/SQL using loop with CONTINUE statement.

DECLARE
  n NUMBER := 0;
BEGIN
  LOOP 
    DBMS_OUTPUT.PUT_LINE ('Inside the loop:  n = ' || TO_CHAR(n));
    n := n + 1;
    IF n < 5 THEN
      CONTINUE;
    END IF;
    DBMS_OUTPUT.PUT_LINE
      ('Inside the loop, after CONTINUE:  n = ' || TO_CHAR(n));
    EXIT WHEN n = 7;
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE ('When out from the loop:  n = ' || TO_CHAR(n));
END;
/

--22. Write a program in PL/SQL using loop with CONTINUE WHEN statement.

DECLARE
  n NUMBER := 0;
BEGIN
  LOOP -- After CONTINUE statement, control resumes here
    DBMS_OUTPUT.PUT_LINE ('The value inside the loop:  n = ' || TO_CHAR(n));
    n := n + 1;
    CONTINUE WHEN n < 4;
    DBMS_OUTPUT.PUT_LINE
      ('The value inside loop, after CONTINUE:  n = ' || TO_CHAR(n));
    EXIT WHEN n = 6;
  END LOOP;
  DBMS_OUTPUT.PUT_LINE ('The value after exit from the loop:  n = ' || TO_CHAR(n));
END;
/

--23. Write a program in PL/SQL to print 1st n numbers.

DECLARE
  n number:= &first_n_number;
BEGIN
 DBMS_OUTPUT.PUT_LINE ('The first '||n||' numbers are: ');
    for i in 1..n loop
       dbms_output.put(i||'  ');
    END LOOP;
    dbms_output.new_line;
 END;
/

--24. Write a program in PL/SQL to print 1st n numbers with a difference of 3 and starting from 1.

DECLARE
  n number:= &first_n_number;
  i number:=1;
  m number:=1;
BEGIN
 DBMS_OUTPUT.PUT_LINE ('The first '||n||' numbers are: ');
  DBMS_OUTPUT.PUT (i||'  ');
    for i in 1..n-1 loop
	   m:=m+3;
	   dbms_output.put(m||'  ');
    END LOOP;
    dbms_output.new_line;
 END;
/

--25. Write a program in PL/SQL to show the value of a same variable declared as local and global.

<<main_label>>
DECLARE
  n NUMBER := 6;
BEGIN
  FOR n IN 1..4 LOOP
    DBMS_OUTPUT.PUT_LINE (
      'When local the value: ' || TO_CHAR(n) || ', but the value as global: ' ||
      TO_CHAR(main_label.n)  
    );
  END LOOP;
END main_label;
/

--26. Write a program in PL/SQL to explain the uses of nested for loop with label.


BEGIN
  <>
  FOR j IN 1..5 LOOP
    <<loop_inner>>
    FOR j IN 1..4 LOOP
      IF loop_outer.j = 4 THEN
        DBMS_OUTPUT.PUT_LINE
          ('When the value of j of outer loop: ' || TO_CHAR(loop_outer.j) || ' then the value of j in the inner loop: '
           || TO_CHAR(loop_inner.j));
      END IF;
    END LOOP loop_inner;
  END LOOP loop_outer;
END;
/

--27. Write a program in PL/SQL to print the prime numbers between 1 to 50.


DECLARE
    i NUMBER(3);
    j NUMBER(3);
BEGIN
dbms_output.Put_line('The prime numbers are:');
	dbms_output.new_line;
    i := 2;
    LOOP
        j := 2;
        LOOP
            EXIT WHEN( ( MOD(i, j) = 0 )
                        OR ( j = i ) );
            j := j + 1;
        END LOOP;
        IF( j = i )THEN
          dbms_output.Put(i||'   ');							   
        END IF;
        i := i + 1;
        exit WHEN i = 50;
    END LOOP;
	dbms_output.new_line;
END;
/


--28. Write a program in PL/SQL to check whether a number is prime or not using goto statement with for loop.

DECLARE
  msg  VARCHAR2(30);
  n  PLS_INTEGER := 83;
BEGIN
  FOR i in 2..ROUND(SQRT(n)) LOOP
    IF n MOD i = 0 THEN
      msg := ' is not a prime number';
      GOTO when_prime;
    END IF;
  END LOOP;

  msg := ' is a prime number';
 
  <>
  DBMS_OUTPUT.PUT_LINE(TO_CHAR(n) || msg);
END;
/


--29. Write a program in PL/SQL to insert records from one table to another.

DROP TABLE emp_temp;
CREATE TABLE emp_temp (
  emp_id      NUMBER,
  emp_email  VARCHAR2(40)
);
 
DECLARE
  number_of_emp  NUMBER;
BEGIN
  SELECT COUNT(employee_id) INTO number_of_emp
  FROM employees;
  
  FOR i IN 1..number_of_emp LOOP
    INSERT INTO emp_temp (emp_id, emp_email)
    VALUES(i, 'not available now');
  END LOOP;
END;
/


--30. Write a program in PL/SQL to insert a row if the featched value for a component is specified.

DROP TABLE TEST;
CREATE TABLE TEST(
c1 INTEGER,
c2 INTEGER);

DELETE FROM TEST;
INSERT INTO TEST VALUES(2, 4);
INSERT INTO TEST VALUES(1, 3);


DECLARE
    n1 NUMBER;
    n2 NUMBER;
BEGIN
    SELECT c1,c2 INTO n1,n2 FROM TEST WHERE c1>1;
   IF n2=4 THEN
        INSERT INTO TEST VALUES(n2,n1);
    ELSE
        INSERT INTO TEST VALUES(n2+15,n1+15);
    END IF;
END;
/




--------------------------------------String Functions----------------------------
----------------------------------------------------------------------------------

--Write a PL/SQL block to calculate the bit length of the employee's first name in the employees table for
-- all records.

DECLARE
v_bit_length NUMBER;
BEGIN
  FOR emp IN (SELECT first_name FROM employees) LOOP
v_bit_length := LENGTHB(trim(emp.first_name)) * 8;
    DBMS_OUTPUT.PUT_LINE('Bit length of ' || emp.first_name || ': ' || v_bit_length);
  END LOOP;
END;
/


--Write a PL/SQL function to return the maximum bit length of the department names in the departments table.


CREATE OR REPLACE FUNCTION get_max_department_bit_length RETURN NUMBER AS
v_max_length NUMBER := 0;
v_bit_length NUMBER;
BEGIN
  FOR dept IN (SELECT department_name FROM departments) LOOP
v_bit_length := LENGTHB(dept.department_name) * 8; -- Multiply by 8 to get the number of bits
    IF v_bit_length>v_max_length THEN
v_max_length := v_bit_length;
    END IF;
  END LOOP;

  RETURN v_max_length;
END;
/

To execute the function:
DECLARE
v_result NUMBER;
BEGIN
v_result := get_max_department_bit_length(); -- Call the function and assign the result to a variable
  DBMS_OUTPUT.PUT_LINE('Maximum department name bit length: ' || v_result);
END;
/


--2. PL/SQL exercises on ASCII() Function.

--Write a PL/SQL block to display the ASCII value of each character in the employee's last name 
--for all records in the employees table.

DECLARE
v_ascii NUMBER;
BEGIN
  FOR emp IN (SELECT last_name FROM employees) LOOP
    FOR i IN 1..LENGTH(emp.last_name) LOOP
v_ascii := ASCII(SUBSTR(emp.last_name, i, 1));
      DBMS_OUTPUT.PUT_LINE('ASCII value of character ' || SUBSTR(emp.last_name, i, 1) || ': ' || v_ascii);
    END LOOP;
  END LOOP;
END;
/

--Create a PL/SQL procedure to calculate the sum of ASCII values for all characters in the 
--first name of a specific employee identified by their employee ID.

CREATE OR REPLACE PROCEDURE calculate_first_name_ascii_sum(
p_employee_id IN employees.employee_id%TYPE
) AS
v_first_nameemployees.first_name%TYPE;
v_ascii_sum NUMBER := 0;
BEGIN
  SELECT first_name INTO v_first_name FROM employees WHERE employee_id = p_employee_id;

  FOR i IN 1..LENGTH(v_first_name) LOOP
v_ascii_sum := v_ascii_sum + ASCII(SUBSTR(v_first_name, i, 1));
  END LOOP;

  DBMS_OUTPUT.PUT_LINE('Sum of ASCII values for the first name: ' || v_ascii_sum);
END;
/
To execute the procedure:
DECLARE
v_employee_idemployees.employee_id%TYPE := 100; -- Provide the employee ID as needed
BEGIN
calculate_first_name_ascii_sum(p_employee_id =>v_employee_id); -- Call the procedure with the employee ID
END;
/

--3. PL/SQL exercises on CHR() Function.

--Write a PL/SQL block to display the character representation of each ASCII value in the range of 65 to 90.

DECLARE
v_character CHAR(1);
BEGIN
  FOR i IN 65..90 LOOP
v_character := CHR(i);
    DBMS_OUTPUT.PUT_LINE('Character for ASCII value ' || i || ': ' || v_character);
  END LOOP;
END;
/

--Write a PL/SQL function to determine whether a job title in the employees table contains any 
--non-alphabetic characters. Return 1 if it does, and 0 otherwise. Use the CHAR function to 
--validate each character.

CREATE OR REPLACE FUNCTION has_non_alphabetic_characters(
p_employee_id IN employees.employee_id%TYPE
) RETURN NUMBER AS
v_job_titleemployees.job_id%TYPE;
v_char CHAR(1);
BEGIN
  SELECT job_id INTO v_job_title FROM employees WHERE employee_id = p_employee_id;

  FOR i IN 1..LENGTH(v_job_title) LOOP
v_char := UPPER(SUBSTR(v_job_title, i, 1));

    IF NOT (v_char BETWEEN 'A' AND 'Z') THEN
      RETURN 1;
    END IF;
  END LOOP;

  RETURN 0;
END;
/
To execute the function:
DECLARE
v_result NUMBER;
BEGIN
  -- Call the function and store the result in the variable v_result
v_result := has_non_alphabetic_characters(p_employee_id => 123); -- Replace 123 with the desired employee ID

  -- Do something with the result
  IF v_result = 1 THEN
    DBMS_OUTPUT.PUT_LINE('The job title contains non-alphabetic characters.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('The job title contains only alphabetic characters.');
  END IF;
END;

--4. PL/SQL exercises on LENGTH() Function.

--Write a PL/SQL block to calculate the length of each employee's last name in the employees table.

DECLARE
v_length NUMBER;
BEGIN
  FOR emp IN (SELECT last_name FROM employees) LOOP
v_length := LENGTH(emp.last_name);
    DBMS_OUTPUT.PUT_LINE('Length of last name ' || emp.last_name || ': ' || v_length);
  END LOOP;
END;
/

--Create a PL/SQL procedure to calculate the length of the job title for a specific employee identified by their employee ID.

CREATE OR REPLACE PROCEDURE calculate_job_title_length(
p_employee_id IN employees.employee_id%TYPE
) AS
v_job_titleemployees.job_id%TYPE;
v_length NUMBER;
BEGIN
  SELECT job_id INTO v_job_title FROM employees WHERE employee_id = p_employee_id;
v_length := LENGTH(v_job_title);
  DBMS_OUTPUT.PUT_LINE('Length of job title: ' || v_length);
END;
/
To execute procedure:
BEGIN
  -- Call the procedure and pass the employee ID as the parameter
calculate_job_title_length(p_employee_id => 125); -- Replace 125 with the desired employee ID
END;
/


--5. PL/SQL exercises on CONCAT() Function.

--Write a PL/SQL block to concatenate the first name and last name of each employee in the 
--employees table and display the full name.

DECLARE
v_full_nameVARCHAR2(100);
BEGIN
  FOR emp IN (SELECT first_name, last_name FROM employees) LOOP
v_full_name := emp.first_name || ' ' || emp.last_name;
    DBMS_OUTPUT.PUT_LINE('Full Name: ' || v_full_name);
  END LOOP;
END;
/

--Create a PL/SQL procedure to concatenate the job title and department name for a specific 
--employee identified by their employee ID and display the result.

CREATE OR REPLACE PROCEDURE concatenate_job_title_department(
p_employee_id IN employees.employee_id%TYPE,
p_department_id IN departments.department_id%TYPE
) AS
v_job_titleemployees.job_id%TYPE;
v_department_namedepartments.department_name%TYPE;
v_resultVARCHAR2(100);
BEGIN
  SELECT job_id INTO v_job_title FROM employees WHERE employee_id = p_employee_id;
  SELECT department_name INTO v_department_name FROM departments WHERE department_id = p_department_id;
v_result := v_job_title || ' - ' || v_department_name;
  DBMS_OUTPUT.PUT_LINE('Concatenated Result: ' || v_result);
END;
/
To execute procedure:
DECLARE
employee_idemployees.employee_id%TYPE := 125; -- Provide the employee ID you want to pass
department_iddepartments.department_id%TYPE := 90; -- Provide the department ID you want to pass
BEGIN
concatenate_job_title_department(employee_id, department_id);
END;
/


--6. PL/SQL exercises on INSTR() Function.

--Write a PL/SQL block to find the position of the first occurrence of the letter 'a' in 
--each employee's last name in the employees table.

DECLARE
v_position NUMBER;
BEGIN
  FOR emp IN (SELECT last_name FROM employees) LOOP
v_position := INSTR(emp.last_name, 'a');
    DBMS_OUTPUT.PUT_LINE('Position of "a" in ' || emp.last_name || ': ' || v_position);
  END LOOP;
END;
/

--Create a PL/SQL procedure to check if a specific employee identified by their employee ID 
--has the letter 'e' in their email. Return 1 if it exists, and 0 otherwise.

CREATE OR REPLACE PROCEDURE check_email_for_letter(
p_employee_id IN employees.employee_id%TYPE
) AS
v_emailemployees.email%TYPE;
v_result NUMBER;
BEGIN
  SELECT email INTO v_email FROM employees WHERE employee_id = p_employee_id;
v_result := CASE WHEN INSTR(v_email, 'E') > 0 THEN 1 ELSE 0 END;
  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);
END;
/
To execute the procedure:
DECLARE
employee_idemployees.employee_id%TYPE := 125; -- Provide the employee ID you want to pass
BEGIN
check_email_for_letter(employee_id);
END;
/


--Write a PL/SQL function to return the number of occurrences of the letter 'S' in the 
--job title of a specific employee identified by their employee ID.

CREATE OR REPLACE FUNCTION count_letter_in_job_title(
p_employee_id IN employees.employee_id%TYPE
) RETURN NUMBER AS
v_job_titleemployees.job_id%TYPE;
BEGIN
  SELECT job_id INTO v_job_title FROM employees WHERE employee_id = p_employee_id;
  RETURN REGEXP_COUNT(v_job_title, 'S');
END;
/
To execute the function:
DECLARE
employee_idemployees.employee_id%TYPE := 125; -- Provide the employee ID you want to pass
result NUMBER;
BEGIN
result := count_letter_in_job_title(employee_id);
  DBMS_OUTPUT.PUT_LINE('Letter Count: ' || result);
END;
/

--7. PL/SQL exercises on SUBSTR() Function.

--Write a PL/SQL block to retrieve the first 3 characters of each employee's last name in the employees table.

DECLARE
v_first_three_charsVARCHAR2(3);
BEGIN
  FOR emp IN (SELECT last_name FROM employees) LOOP
v_first_three_chars := SUBSTR(emp.last_name, 1, 3);
    DBMS_OUTPUT.PUT_LINE('First three characters of last name: ' || v_first_three_chars);
  END LOOP;
END;
/

--Create a PL/SQL procedure to retrieve the leftmost n characters of the email for a specific 
--employee identified by their employee ID.

CREATE OR REPLACE PROCEDURE get_left_email(
p_employee_id IN employees.employee_id%TYPE,
p_num_chars IN NUMBER
) AS
v_emailemployees.email%TYPE;
v_left_emailVARCHAR2(100);
BEGIN
  SELECT email INTO v_email FROM employees WHERE employee_id = p_employee_id;
v_left_email := SUBSTR(v_email, 1, p_num_chars);
  DBMS_OUTPUT.PUT_LINE('Left ' || p_num_chars || ' characters of email: ' || v_left_email);
END;
/
To execute the procedure:
DECLARE
p_employee_idemployees.employee_id%TYPE := 125; 
p_num_chars NUMBER := 5; BEGIN
get_left_email(p_employee_id, p_num_chars);
END;
/

--8. PL/SQL exercises on LOWER() Function.

--Write a PL/SQL block to convert the last name of each employee in the 
--employees table to lowercase and display the result.
DECLARE
v_lower_last_nameVARCHAR2(50);
BEGIN
  FOR emp IN (SELECT last_name FROM employees) LOOP
v_lower_last_name := LOWER(emp.last_name);
    DBMS_OUTPUT.PUT_LINE('Lowercase last name: ' || v_lower_last_name);
  END LOOP;
END;
/

--Create a PL/SQL procedure to update the email of a specific employee identified by their employee ID to lowercase.

CREATE OR REPLACE PROCEDURE update_email_to_lowercase(
p_employee_id IN employees.employee_id%TYPE
) AS
v_emailemployees.email%TYPE;
BEGIN
  SELECT email INTO v_email FROM employees WHERE employee_id = p_employee_id;
v_email := LOWER(v_email);
  UPDATE employees SET email = v_email WHERE employee_id = p_employee_id;
  COMMIT;
  DBMS_OUTPUT.PUT_LINE('Email updated to lowercase successfully.');
END;
/
To execute the procedure:
BEGIN
update_email_to_lowercase(p_employee_id => 100); END;
/

--9. PL/SQL exercises on RPAD() Function.

--Write a PL/SQL block that retrieves the first name and repeats the last name three times for 
--all employees in the employees table. Display the results.

DECLARE
v_first_nameemployees.first_name%TYPE;
v_last_nameemployees.last_name%TYPE;
v_repeated_last_nameVARCHAR2(150);
BEGIN
  FOR emp IN (SELECT first_name, last_name FROM employees) LOOP
v_first_name := emp.first_name;
v_last_name := emp.last_name;
v_repeated_last_name := RPAD(v_last_name, LENGTH(v_last_name)*3, v_last_name);
    DBMS_OUTPUT.PUT_LINE('First Name: ' || v_first_name || ', Repeated Last Name: ' || v_repeated_last_name);
  END LOOP;
END
/
--Write a PL/SQL block that prompts the user to enter a string and a repetition count. 
--Use the RPAD function to repeat the string by the specified count. Display the repeated string.
DECLARE
v_input_stringVARCHAR2(100);
v_repetition_count NUMBER;
v_repeated_stringVARCHAR2(1000);
BEGIN
v_input_string := ' AAA ';
v_repetition_count := 3;
v_repeated_string := RPAD(v_input_string, LENGTH(v_input_string)*v_repetition_count, v_input_string);
  DBMS_OUTPUT.PUT_LINE('Repeated String: ' || v_repeated_string);
END;

--Write a PL/SQL block that finds the department names and repeats them twice for all 
--departments in the departments table. Display the results.
DECLARE
v_dept_iddepartments.department_id%TYPE;
v_dept_namedepartments.department_name%TYPE;
v_repeated_dept_nameVARCHAR2(150);
BEGIN
  FOR dept IN (SELECT department_id, department_name FROM departments) LOOP
v_dept_id := dept.department_id;
v_dept_name := dept.department_name;
v_repeated_dept_name := RPAD(v_dept_name, LENGTH(v_dept_name)*2, v_dept_name);
    DBMS_OUTPUT.PUT_LINE('Department ID: ' || v_dept_id || ', Repeated Department Name: ' || v_repeated_dept_name);
  END LOOP;
END;


--10. PL/SQL exercises on REPLACE() Function.

--Write a PL/SQL block that replaces all occurrences of the substring 'SA_MAN' with Sales Manager' 
--in the job titles of employees in the employees table. Display the updated job titles.

DECLARE
v_job_idemployees.job_id%TYPE;
BEGIN
  FOR emp IN (SELECT job_id FROM employees) LOOP
    IF v_job_id = 'SA_MAN' THEN
v_job_id := 'Sales Manager';
    END IF;
    DBMS_OUTPUT.PUT_LINE('Updated Job ID: ' || v_job_id);
  END LOOP;
END;

--Write a PL/SQL block that prompts the user to enter a substring to be replaced and a replacement substring. 
--Use the REPLACE function to replace all occurrences of the entered substring with the replacement substring 
--in the job titles of employees in the employees table. Display the updated job titles.

DECLARE
v_substringVARCHAR2(50);
v_replacementVARCHAR2(50);
v_job_titleemployees.job_id%TYPE;
BEGIN
v_substring := 'SA';
v_replacement := 'Sales';
  FOR emp IN (SELECT job_id FROM employees) LOOP
v_job_title := REPLACE(emp.job_id, v_substring, v_replacement);
    DBMS_OUTPUT.PUT_LINE('Updated Job Title: ' || v_job_title);
  END LOOP;
END;

--Write a PL/SQL block that replaces all occurrences of the string 'MAN' with 'MANAGER' in the department names
-- of departments in the departments table. Display the updated department names.

DECLARE
v_department_iddepartments.department_id%TYPE;
v_department_namedepartments.department_name%TYPE;
BEGIN
  FOR dept IN (SELECT department_id, department_name FROM departments) LOOP
v_department_id := dept.department_id;
v_department_name := REPLACE(dept.department_name, 'IT', 'Info.Tech.');
    DBMS_OUTPUT.PUT_LINE('Department ID: ' || v_department_id || ', Updated Department Name: ' || v_department_name);
  END LOOP;
END;

--11. PL/SQL exercises on TRIM() Function.

--Write a PL/SQL block that prompts the user to enter a string and removes any leading and trailing zeros 
--from it. Display the trimmed string.

DECLARE
v_input_stringVARCHAR2(100);
v_trimmed_stringVARCHAR2(100);
BEGIN
v_input_string := '00000test string00000';

v_trimmed_string := TRIM('0' FROM v_input_string);
  DBMS_OUTPUT.PUT_LINE('Trimmed String: [' || v_trimmed_string || ']');
END;

--Write a PL/SQL block that retrieves the first name and last name of employees in the employees table and 
--removes any leading and trailing spaces from them. Display the trimmed names.

DECLARE
v_first_nameemployees.first_name%TYPE;
v_last_nameemployees.last_name%TYPE;
BEGIN
  FOR emp IN (SELECT first_name, last_name FROM employees) LOOP
v_first_name := TRIM(BOTH ' ' FROM emp.first_name);
v_last_name := TRIM(BOTH ' ' FROM emp.last_name);
    DBMS_OUTPUT.PUT_LINE('First Name: [' || v_first_name || '], Last Name: [' || v_last_name || ']');
  END LOOP;
END;

--Write a PL/SQL block that prompts the user to enter a string and removes any leading or trailing spaces
--from it. Display the trimmed string.

DECLARE
v_input_stringVARCHAR2(100);
v_trimmed_stringVARCHAR2(100);
BEGIN
v_input_string := '     trim_5_leading_and_trailing_spaces     ';
v_trimmed_string := TRIM(v_input_string);
  DBMS_OUTPUT.PUT_LINE('Trimmed String: [' || v_trimmed_string || ']');
END;

--12. PL/SQL exercises on UPPER() Function.

--Write a PL/SQL block that retrieves the first name and last name of employees in the employees table 
--and converts them to uppercase. Display the uppercase names.

DECLARE
n_first_nameemployees.first_name%TYPE;
n_last_nameemployees.last_name%TYPE;  
v_first_nameemployees.first_name%TYPE;
v_last_nameemployees.last_name%TYPE;
BEGIN
  FOR emp IN (SELECT first_name, last_name FROM employees) LOOP
n_first_name := emp.first_name;
n_last_name := emp.last_name;
v_first_name := UPPER(emp.first_name);
v_last_name := UPPER(emp.last_name);
    DBMS_OUTPUT.PUT_LINE('First and Last Name: ' || n_first_name || n_last_name || 'In UPPER First and Last Name: ' || v_first_name || v_last_name);
  END LOOP;
END;

--Write a PL/SQL block that prompts the user to enter a string and converts it to uppercase using the 
--UPPER function. Display the uppercase string.

DECLARE
v_input_stringVARCHAR2(100);
v_uppercase_stringVARCHAR2(100);
BEGIN
v_input_string := 'i_was_a_lowercase_and_transfered_to_uppercase';
v_uppercase_string := UPPER(v_input_string);
  DBMS_OUTPUT.PUT_LINE('Uppercase String: ' || v_uppercase_string);
END;

------------------------------------------While Loop----------------------------------
--------------------------------------------------------------------------------------

--1. Write a PL/SQL program to display the names of all countries.

DECLARE
v_country_namecountry.country_name%TYPE;
  CURSOR c_countries IS SELECT country_name FROM country;
BEGIN
  OPEN c_countries;
  FETCH c_countries INTO v_country_name;
  WHILE c_countries%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE(v_country_name);
    FETCH c_countries INTO v_country_name;
  END LOOP;
  CLOSE c_countries;
END;

--2. Write a PL/SQL program to display the job titles of all employees. Return a heading of job title.

DECLARE
v_job_titleemployees.job_id%TYPE;
  CURSOR c_employees IS SELECT job_id FROM employees;
BEGIN
  OPEN c_employees;
  DBMS_OUTPUT.PUT_LINE('JOB TITLE');
  DBMS_OUTPUT.PUT_LINE('---------');
  FETCH c_employees INTO v_job_title;
  WHILE c_employees%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE(v_job_title);
    FETCH c_employees INTO v_job_title;
  END LOOP;
  CLOSE c_employees;
END;

--3. Write a PL/SQL program to display the location IDs and cities of all locations along with 
--the proper heading.

DECLARE
v_location_idlocations.location_id%TYPE;
v_citylocations.city%TYPE;
  CURSOR c_locations IS SELECT location_id, city FROM locations;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Location ID | City');
  DBMS_OUTPUT.PUT_LINE('-------------------');
  OPEN c_locations;
  FETCH c_locations INTO v_location_id, v_city;
  WHILE c_locations%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE(v_location_id || '       | ' || v_city);
    FETCH c_locations INTO v_location_id, v_city;
  END LOOP;
  CLOSE c_locations;
END;
/

--4. Write a PL/SQL program to display the employee IDs, names, job titles, hire dates, and salaries 
--of all employees.

DECLARE
v_employee_idemployees.employee_id%TYPE;
v_full_nameemployees.first_name%TYPE;
v_job_idemployees.job_id%TYPE;
v_hire_dateemployees.hire_date%TYPE;
v_salaryemployees.salary%TYPE;
  CURSOR c_employees IS
    SELECT employee_id, first_name || ' ' || last_name AS full_name, job_id, hire_date, salary
    FROM employees;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Employee ID | Full Name | Job Title | Hire Date | Salary');
  DBMS_OUTPUT.PUT_LINE('-------------------------------------------------------------------');
  OPEN c_employees;
  FETCH c_employees INTO v_employee_id, v_full_name, v_job_id, v_hire_date, v_salary;
  WHILE c_employees%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE(v_employee_id || '        | ' || v_full_name || ' | ' || v_job_id || ' | ' || v_hire_date || ' | ' || v_salary);
    FETCH c_employees INTO v_employee_id, v_full_name, v_job_id, v_hire_date, v_salary;
  END LOOP;
  CLOSE c_employees;
END;
/

--5. Write a PL/SQL program to display the employee IDs, names, and department names of all employees.

DECLARE
v_employee_idemployees.employee_id%TYPE;
v_first_nameemployees.first_name%TYPE;
v_last_nameemployees.last_name%TYPE;
v_department_namedepartments.department_name%TYPE;
  CURSOR employee_cursor IS
    SELECT e.employee_id, e.first_name, e.last_name, d.department_name
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id;
BEGIN
  OPEN employee_cursor;
  FETCH employee_cursor INTO v_employee_id, v_first_name, v_last_name, v_department_name;
  WHILE employee_cursor%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_employee_id);
    DBMS_OUTPUT.PUT_LINE('Employee First Name: ' || v_first_name);
    DBMS_OUTPUT.PUT_LINE('Employee Last Name: ' || v_last_name);
    DBMS_OUTPUT.PUT_LINE('Department Name: ' || v_department_name);
    DBMS_OUTPUT.PUT_LINE('-------------------');
    FETCH employee_cursor INTO v_employee_id, v_first_name, v_last_name, v_department_name;
  END LOOP;
  CLOSE employee_cursor;
END;

--6. Write a PL/SQL program to display the employee IDs, names, and manager names of all employees.

DECLARE
  CURSOR emp_cursor IS
    SELECT e.employee_id, e.first_name, m.first_name AS manager_name
    FROM employees e
    LEFT JOIN employees m ON e.manager_id = m.employee_id;
emp_recordemp_cursor%ROWTYPE;
BEGIN
  OPEN emp_cursor;
  FETCH emp_cursor INTO emp_record;
  WHILE emp_cursor%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp_record.employee_id);
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || emp_record.first_name);
    DBMS_OUTPUT.PUT_LINE('Manager Name: ' || emp_record.manager_name);
    DBMS_OUTPUT.PUT_LINE('-------------------------');
    FETCH emp_cursor INTO emp_record;
  END LOOP;
  CLOSE emp_cursor;
END;


--7. Write a PL/SQL program to display the job IDs, titles, and minimum salaries of all jobs.

DECLARE
  CURSOR job_cursor IS
    SELECT job_id, job_title, min_salary
    FROM jobs;
job_recordjob_cursor%ROWTYPE;
BEGIN
  OPEN job_cursor;
  FETCH job_cursor INTO job_record;
  WHILE job_cursor%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE('Job ID: ' || job_record.job_id);
    DBMS_OUTPUT.PUT_LINE('Job Title: ' || job_record.job_title);
    DBMS_OUTPUT.PUT_LINE('Minimum Salary: ' || job_record.min_salary);
    DBMS_OUTPUT.PUT_LINE('-------------------------');
    FETCH job_cursor INTO job_record;
  END LOOP;
  CLOSE job_cursor;
END;
/

--8. Write a PL/SQL program to display the employee IDs, names, and job titles of all employees.


DECLARE
  CURSOR employees_cursor IS
    SELECT employee_id, first_name
    FROM employees;
v_employee_idemployees.employee_id%TYPE;
v_employee_nameemployees.first_name%TYPE;
v_job_titlejobs.job_title%TYPE;
BEGIN
  -- Initialize the variables
v_employee_id := NULL;
v_employee_name := NULL;
v_job_title := NULL;
    -- Open the cursor to retrieve employee data
  OPEN employees_cursor;
    -- Print the header
  DBMS_OUTPUT.PUT_LINE('Employee ID' || CHR(9) || 'Employee Name' || CHR(9) || 'Job Title');
  DBMS_OUTPUT.PUT_LINE('----------------------------------------------------');
    -- Fetch the first row
  FETCH employees_cursor INTO v_employee_id, v_employee_name;
    -- Loop through the cursor data
  WHILE employees_cursor%FOUND LOOP
    -- Retrieve the job title for the current employee
    SELECT job_title INTO v_job_title
    FROM jobs
    WHERE job_id = (SELECT job_id FROM employees WHERE employee_id = v_employee_id);
        -- Display the employee data in tabular form
    DBMS_OUTPUT.PUT_LINE(v_employee_id || CHR(9) || v_employee_name || CHR(9) || v_job_title);
        -- Fetch the next row
    FETCH employees_cursor INTO v_employee_id, v_employee_name;
  END LOOP;
    -- Close the cursor
  CLOSE employees_cursor;
  EXCEPTION
  WHEN OTHERS THEN
    -- Handle exceptions
    DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END;


--9. Write a PL/SQL program to display the employee IDs, names, and job history start dates of all employees.

DECLARE
v_employee_idemployees.employee_id%TYPE;
v_first_nameemployees.first_name%TYPE;
v_start_datejob_history.start_date%TYPE;
  CURSOR c_employees IS
    SELECT e.employee_id, e.first_name, jh.start_date
    FROM employees e
    JOIN job_history jh ON e.employee_id = jh.employee_id;
BEGIN
  OPEN c_employees;
  FETCH c_employees INTO v_employee_id, v_first_name, v_start_date;
  WHILE c_employees%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_employee_id);
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_first_name);
    DBMS_OUTPUT.PUT_LINE('Start Date: ' || v_start_date);
    DBMS_OUTPUT.PUT_LINE('----------------------');
    FETCH c_employees INTO v_employee_id, v_first_name, v_start_date;
  END LOOP;
  CLOSE c_employees;
END;


--10. Write a PL/SQL program to display the employee IDs, names, and job history end dates of all employees.

DECLARE
v_employee_idemployees.employee_id%TYPE;
v_first_nameemployees.first_name%TYPE;
v_end_datejob_history.end_date%TYPE;
  CURSOR c_employees IS
    SELECT e.employee_id, e.first_name, jh.end_date
    FROM employees e
    JOIN job_history jh ON e.employee_id = jh.employee_id;
BEGIN
  OPEN c_employees;
  FETCH c_employees INTO v_employee_id, v_first_name, v_end_date;
  WHILE c_employees%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_employee_id);
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_first_name);
    DBMS_OUTPUT.PUT_LINE('End Date: ' || v_end_date);
    DBMS_OUTPUT.PUT_LINE('----------------------');
    FETCH c_employees INTO v_employee_id, v_first_name, v_end_date;
  END LOOP;
  CLOSE c_employees;
END;

--11. Write a PL/SQL program to display the department IDs, names, and the name of the city where 
--the department is located of all departments.

DECLARE
v_department_iddepartments.department_id%TYPE;
v_department_namedepartments.department_name%TYPE;
v_city_namelocations.city%TYPE;
  CURSOR c_departments IS
    SELECT d.department_id, d.department_name, l.city
    FROM departments d
    JOIN locations l ON d.location_id = l.location_id;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Department ID' || CHR(9) || 'Department Name' || CHR(9) || 'City');
  DBMS_OUTPUT.PUT_LINE('-------------------------------------------------');
    OPEN c_departments;
  FETCH c_departments INTO v_department_id, v_department_name, v_city_name;
  WHILE c_departments%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE(v_department_id || CHR(9) || v_department_name || CHR(9) || v_city_name);
    FETCH c_departments INTO v_department_id, v_department_name, v_city_name;
  END LOOP;
  CLOSE c_departments;
END;

--12. Write a PL/SQL program to display all the departments along with the names of employees working 
--in each department.

DECLARE
v_department_iddepartments.department_id%TYPE;
v_department_namedepartments.department_name%TYPE;
v_employee_nameemployees.first_name%TYPE;

  CURSOR c_departments IS
    SELECT department_id, department_name
    FROM departments;
      CURSOR c_employees (p_department_id IN departments.department_id%TYPE) IS
    SELECT first_name
    FROM employees
    WHERE department_id = p_department_id;
BEGIN
  OPEN c_departments;
    FETCH c_departments INTO v_department_id, v_department_name;
    DBMS_OUTPUT.PUT_LINE('Department' || CHR(9) || 'First_Name');
  DBMS_OUTPUT.PUT_LINE('-------------------------------------------------');
    WHILE c_departments%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE(v_department_name || CHR(9));
        OPEN c_employees(v_department_id);
        FETCH c_employees INTO v_employee_name;
        WHILE c_employees%FOUND LOOP
      DBMS_OUTPUT.PUT_LINE(CHR(9) || CHR(9) || v_employee_name);
        FETCH c_employees INTO v_employee_name;
    END LOOP;
      CLOSE c_employees;
      FETCH c_departments INTO v_department_id, v_department_name;
      DBMS_OUTPUT.PUT_LINE('-------------------------------------------------');
  END LOOP;
    CLOSE c_departments;
END;

--13. Write a PL/SQL program to display the average salary for each job. Return job title and average salary in a row.

SET SERVEROUTPUT ON;
DECLARE
v_job_titleemployees.job_title%TYPE;
v_avg_salary NUMBER;
v_total_salary NUMBER;
v_employee_count NUMBER;
    CURSOR c_job_titles IS
    SELECT DISTINCT job_title
    FROM employees;
      CURSOR c_employees (p_job_title IN employees.job_title%TYPE) IS
    SELECT salary
    FROM employees
    WHERE job_title = p_job_title;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Job Title' || CHR(9) || 'Average Salary');
  DBMS_OUTPUT.PUT_LINE('-----------------------------------');
    OPEN c_job_titles;
  FETCH c_job_titles INTO v_job_title;
    WHILE c_job_titles%FOUND LOOP
v_total_salary := 0;
v_employee_count := 0;
        OPEN c_employees(v_job_title);
    FETCH c_employees INTO v_avg_salary;
        WHILE c_employees%FOUND LOOP
v_total_salary := v_total_salary + v_avg_salary;
v_employee_count := v_employee_count + 1;
      FETCH c_employees INTO v_avg_salary;
    END LOOP;
        CLOSE c_employees;
        IF v_employee_count> 0 THEN
v_avg_salary := v_total_salary / v_employee_count;
    ELSE
v_avg_salary := 0;
    END IF;
        DBMS_OUTPUT.PUT_LINE(v_job_title || CHR(9) || v_avg_salary);
        FETCH c_job_titles INTO v_job_title;
  END LOOP;
    CLOSE c_job_titles;
END;

--14. Write a PL/SQL program to display the total salary expense for each department. 
--Return depart name and salary expenses in tabular form.

DECLARE
v_department_namedepartments.department_name%TYPE;
v_total_salary_expense NUMBER;
v_department_count NUMBER;
  CURSOR c_departments IS
    SELECT department_name
    FROM departments;
  CURSOR c_employees (p_department_name IN departments.department_name%TYPE) IS
    SELECT e.salary
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    WHERE d.department_name = p_department_name;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Department Name' || CHR(9) || 'Salary Expense');
  DBMS_OUTPUT.PUT_LINE('----------------------------------');
  OPEN c_departments;
  FETCH c_departments INTO v_department_name;
  WHILE c_departments%FOUND LOOP
v_total_salary_expense := 0;
v_department_count := 0;
    OPEN c_employees(v_department_name);
    FETCH c_employees INTO v_total_salary_expense;
    WHILE c_employees%FOUND LOOP
v_department_count := v_department_count + 1;
      FETCH c_employees INTO v_total_salary_expense;
    END LOOP;
    CLOSE c_employees;
    DBMS_OUTPUT.PUT_LINE(v_department_name || CHR(9) || v_total_salary_expense);
    FETCH c_departments INTO v_department_name;
  END LOOP;
  CLOSE c_departments;
END;

--15. Write a PL/SQL program to display the number of employees in each department using a 
--nested while loop. Return department name and number of employees.

DECLARE
v_department_iddepartments.department_id%TYPE;
v_department_namedepartments.department_name%TYPE;
v_employee_count NUMBER;
v_employee_nameemployees.first_name%TYPE;
  CURSOR c_departments IS
    SELECT department_id, department_name
    FROM departments;
  CURSOR c_employees (p_department_id IN departments.department_id%TYPE) IS
    SELECT first_name
    FROM employees
    WHERE department_id = p_department_id;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Employee Name' || CHR(9) || 'Number of Employees');
  DBMS_OUTPUT.PUT_LINE('-------------------------------');
  OPEN c_departments;
  FETCH c_departments INTO v_department_id, v_department_name;
  WHILE c_departments%FOUND LOOP
v_employee_count := 0;
    DBMS_OUTPUT.PUT(v_department_name || CHR(9) || '');
    OPEN c_employees(v_department_id);
    FETCH c_employees INTO v_employee_name;
    WHILE c_employees%FOUND LOOP
v_employee_count := v_employee_count + 1;
      FETCH c_employees INTO v_employee_name;
    END LOOP;
    CLOSE c_employees;
    DBMS_OUTPUT.PUT_LINE(v_employee_count);
    FETCH c_departments INTO v_department_id, v_department_name;
  END LOOP;
  CLOSE c_departments;
END;


--16. Write a PL/SQL program to display the total number of employees hired each year between 
--1985 and 2000. Return the result in tabular format.

DECLARE
v_year NUMBER := 1985; -- Starting year
v_total NUMBER;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Year    Total Employees');
  DBMS_OUTPUT.PUT_LINE('---------------------');
  WHILE v_year<= 2000 LOOP
v_total := 0; -- Reset total for each year
    DECLARE
      CURSOR c_employees IS
        SELECT COUNT(*) AS emp_count
        FROM employees
        WHERE EXTRACT(YEAR FROM hire_date) = v_year;
r_employeec_employees%ROWTYPE;
    BEGIN
      OPEN c_employees;
      FETCH c_employees INTO r_employee;
      CLOSE c_employees;
v_total := r_employee.emp_count;
    END;
    DBMS_OUTPUT.PUT_LINE(v_year || '     ' || v_total);
v_year := v_year + 1;
  END LOOP;
END;


--17. Write a PL/SQL program to display the number of employees in each country.
-- Return country name and number of employees.

DECLARE
v_country_namecountry.country_name%TYPE;
v_total_employees NUMBER;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Country Name    Total Employees');
  DBMS_OUTPUT.PUT_LINE('-----------------------------');
  DECLARE
    CURSOR c_countries IS
      SELECT country_name
      FROM country;
r_countryc_countries%ROWTYPE;
  BEGIN
    OPEN c_countries;
    FETCH c_countries INTO r_country;
    WHILE c_countries%FOUND LOOP
v_country_name := r_country.country_name;
v_total_employees := 0; -- Reset total for each country
      DECLARE
        CURSOR c_employees IS
          SELECT COUNT(*) AS emp_count
          FROM employees emp
          JOIN departments dept ON emp.department_id = dept.department_id
          JOIN locations loc ON dept.location_id = loc.location_id
          JOIN country ctry ON loc.country_id = ctry.country_id
          WHERE ctry.country_name = v_country_name;
r_employeec_employees%ROWTYPE;
      BEGIN
        OPEN c_employees;
        FETCH c_employees INTO r_employee;
        CLOSE c_employees;
v_total_employees := r_employee.emp_count;
      END;
      DBMS_OUTPUT.PUT_LINE(v_country_name || '           ' || v_total_employees);
      FETCH c_countries INTO r_country;
    END LOOP;
    CLOSE c_countries;
  END;
END;

--18. Write a PL/SQL program to display the average salary for each department.

DECLARE
v_dept_idemployees.department_id%TYPE;
v_avg_salary NUMBER;
v_cursor     SYS_REFCURSOR;
BEGIN
  OPEN v_cursor FOR
    SELECT DISTINCT department_id
    FROM employees;
  WHILE TRUE LOOP
    FETCH v_cursor INTO v_dept_id;
    EXIT WHEN v_cursor%NOTFOUND;
v_avg_salary := 0;
    DECLARE
v_count NUMBER := 0;
v_total_salary NUMBER := 0;
v_employee_recemployees%ROWTYPE;
v_employee_cursor SYS_REFCURSOR;
    BEGIN
      OPEN v_employee_cursor FOR
        SELECT *
        FROM employees
        WHERE department_id = v_dept_id;
      WHILE TRUE LOOP
        FETCH v_employee_cursor INTO v_employee_rec;
        EXIT WHEN v_employee_cursor%NOTFOUND;
v_total_salary := v_total_salary + v_employee_rec.salary;
v_count := v_count + 1;
      END LOOP;
      CLOSE v_employee_cursor;
      IF v_count> 0 THEN
v_avg_salary := v_total_salary / v_count;
      END IF;
    END;
    DBMS_OUTPUT.PUT_LINE('Department ' || v_dept_id || ': Average Salary = ' || v_avg_salary);
  END LOOP;
  CLOSE v_cursor;
END;


--19. Write a PL/SQL program to display the employees who have the highest salary in each 
--department using a nested while loop.

DECLARE
v_dept_idemployees.department_id%TYPE;
v_max_salary NUMBER;
v_employee_idemployees.employee_id%TYPE;
v_cursor     SYS_REFCURSOR;
BEGIN
  OPEN v_cursor FOR
    SELECT DISTINCT department_id
    FROM employees;
  WHILE TRUE LOOP
    FETCH v_cursor INTO v_dept_id;
    EXIT WHEN v_cursor%NOTFOUND;
v_max_salary := 0;
    DECLARE
v_employee_recemployees%ROWTYPE;
v_employee_cursor SYS_REFCURSOR;
    BEGIN
      OPEN v_employee_cursor FOR
        SELECT *
        FROM employees
        WHERE department_id = v_dept_id;
      WHILE TRUE LOOP
        FETCH v_employee_cursor INTO v_employee_rec;
        EXIT WHEN v_employee_cursor%NOTFOUND;
        IF v_employee_rec.salary>v_max_salary THEN
v_max_salary := v_employee_rec.salary;
v_employee_id := v_employee_rec.employee_id;
        END IF;
      END LOOP;
      CLOSE v_employee_cursor;
    END;
DBMS_OUTPUT.PUT_LINE('Department ' || v_dept_id || '   : Employee ID = ' || v_employee_id || ',       Highest Salary = ' || v_max_salary);
  END LOOP;
  CLOSE v_cursor;
END;


--20. Write a PL/SQL program to display the employees who have the lowest salary in each department.

DECLARE
v_dept_idemployees.department_id%TYPE;
v_min_salary   NUMBER;
v_employee_idemployees.employee_id%TYPE;
v_cursor       SYS_REFCURSOR;
BEGIN
  OPEN v_cursor FOR
    SELECT DISTINCT department_id
    FROM employees;
  WHILE TRUE LOOP
    FETCH v_cursor INTO v_dept_id;
    EXIT WHEN v_cursor%NOTFOUND;
v_min_salary := NULL;
    DECLARE
v_employee_recemployees%ROWTYPE;
v_employee_cursor SYS_REFCURSOR;
    BEGIN
      OPEN v_employee_cursor FOR
        SELECT *
        FROM employees
        WHERE department_id = v_dept_id;
      WHILE TRUE LOOP
        FETCH v_employee_cursor INTO v_employee_rec;
        EXIT WHEN v_employee_cursor%NOTFOUND;
        IF v_min_salary IS NULL OR v_employee_rec.salary<v_min_salary THEN
v_min_salary := v_employee_rec.salary;
v_employee_id := v_employee_rec.employee_id;
        END IF;
      END LOOP;
      CLOSE v_employee_cursor;
    END;
    DBMS_OUTPUT.PUT_LINE('Department ' || v_dept_id || '   : Employee ID = ' || v_employee_id || ',       Lowest Salary = ' || v_min_salary);
  END LOOP;
  CLOSE v_cursor;
END;

--21. Write a PL/SQL program to display the department name with the maximum number of employees.

DECLARE
v_max_employees  NUMBER := 0;
v_dept_namedepartments.department_name%TYPE;
v_dept_iddepartments.department_id%TYPE;
v_employee_count NUMBER;
v_cursor         SYS_REFCURSOR;
BEGIN
  OPEN v_cursor FOR
    SELECT department_id, department_name
    FROM departments;
  WHILE TRUE LOOP
    FETCH v_cursor INTO v_dept_id, v_dept_name;
    EXIT WHEN v_cursor%NOTFOUND;
v_employee_count := 0;



    DECLARE
v_employee_recemployees%ROWTYPE;
v_employee_cursor SYS_REFCURSOR;
    BEGIN
      OPEN v_employee_cursor FOR
        SELECT *
        FROM employees
        WHERE department_id = v_dept_id;
      WHILE TRUE LOOP
        FETCH v_employee_cursor INTO v_employee_rec;
        EXIT WHEN v_employee_cursor%NOTFOUND;
v_employee_count := v_employee_count + 1;
      END LOOP;
      CLOSE v_employee_cursor;
    END;

    IF v_employee_count>v_max_employees THEN
v_max_employees := v_employee_count;
v_dept_name := v_dept_name;
    END IF;
  END LOOP;
  CLOSE v_cursor;

  DBMS_OUTPUT.PUT_LINE('Department with the maximum number of employees: ' || v_dept_name);
  DBMS_OUTPUT.PUT_LINE('Number of employees: ' || v_max_employees);
END;


------------------------------cursor function----------------------------
-------------------------------------------------------------------------

--1. Write a program in PL/SQL to show the uses of static PL/SQL statement.

----1
DROP TABLE emp_temp;
CREATE TABLE emp_temp AS
  SELECT employee_id, first_name, last_name 
  FROM employees;

 
DECLARE
  emp_id          emp_temp.employee_id%TYPE := 285;
  emp_f_name  emp_temp.first_name%TYPE  := 'Alen';
  emp_l_name   emp_temp.last_name%TYPE   := 'Gorge';
BEGIN
  INSERT INTO emp_temp (employee_id, first_name, last_name) 
  VALUES (emp_id, emp_f_name, emp_l_name);
 
  UPDATE emp_temp
  SET first_name = 'Alen'
  WHERE employee_id = emp_id;
 
  DELETE FROM emp_temp
  WHERE employee_id = emp_id
  RETURNING first_name, last_name
  INTO emp_f_name, emp_l_name;
 
  COMMIT;
  DBMS_OUTPUT.PUT_LINE (emp_f_name || ' ' || emp_l_name);
END;

select * from emp_temp
where first_name = 'Alen';

----2
DECLARE
  v_employee_count NUMBER;
  v_department_name VARCHAR2(50);
BEGIN
  -- Static SELECT statement to retrieve the number of employees in the HR department
  SELECT COUNT(*)
  INTO v_employee_count
  FROM hr.employees
  WHERE department_id = (SELECT department_id FROM hr.departments WHERE department_name = 'Human Resources');

  -- Static SELECT statement to retrieve the department name for a specific department ID
  SELECT department_name
  INTO v_department_name
  FROM hr.departments
  WHERE department_id = 10;

  -- Output the results
  DBMS_OUTPUT.PUT_LINE('Number of employees in Human Resources department: ' || v_employee_count);
  DBMS_OUTPUT.PUT_LINE('Department Name for ID 10: ' || v_department_name);
END;


select * from hr.departments ;
where department_name = 'Hr' ;

--2. Write a program in PL/SQL to show the uses of CURVAL and NEXTVAL with a sequence name. 

----1
 CREATE SEQUENCE emp_seq INCREMENT BY 1;
drop sequence emp_seq;
  /* Because NEXTVAL values might be referenced
     by different users and applications,
     and some NEXTVAL values might not be stored in database,
     there might be gaps in sequence. */
  
DROP TABLE emp_temp;

CREATE TABLE emp_temp AS
  SELECT employee_id, first_name, last_name 
  FROM employees;
    
  select * from emp_temp1
  where first_name = 'Tim';
  select * from emp_temp
  where first_name = 'Alen';
 
DECLARE
  seq_value NUMBER;
BEGIN
  seq_value := emp_seq.NEXTVAL;
   DBMS_OUTPUT.PUT_LINE (
    'Initial sequence value: ' || TO_CHAR(seq_value)
  );
  -- NEXTVAL have been used to create unique number when inserting data:
     INSERT INTO emp_temp (employee_id, first_name, last_name) 
     VALUES (emp_seq.NEXTVAL, 'Alen', 'George');
  -- CURRVAL have been used to store same value somewhere else:
     INSERT INTO emp_temp1 VALUES (emp_seq.CURRVAL,
                                         'Tim', 'May');
  -- CURRVAL have been used to specify record to delete:
     seq_value := emp_seq.CURRVAL;
     DELETE FROM emp_temp
     WHERE employee_id = seq_value;
  -- The employee_id will be updated with NEXTVAL for specified record:
     UPDATE emp_temp
     SET employee_id = emp_seq.NEXTVAL
     WHERE first_name = 'Alen'
     AND last_name = 'George';
     seq_value := emp_seq.CURRVAL;
     DBMS_OUTPUT.PUT_LINE (
       'Ending sequence value: ' || TO_CHAR(seq_value)
     );
END;

--3.Write a program in PL/SQL to find the number of rows effected by the use of 
--SQL%ROWCOUNT attributes of an implicit cursor

DROP TABLE emp_temp;
CREATE TABLE emp_temp AS
  SELECT employee_id, first_name, last_name,email 
  FROM employees;

BEGIN
    UPDATE emp_temp
    SET    email = 'not available'
    WHERE  first_name LIKE 'B%';

    dbms_output.Put_line('Number of record updated: '
                         ||To_char(SQL%rowcount));
END;

--4. Write a program in PL/SQL to show the uses of implicit cursor without using any attribute.

DECLARE
    emp_first_name VARCHAR2(35);
    emp_last_name  VARCHAR2(35);
	zemp_id NUMBER:=&employee_id;
BEGIN
    SELECT first_name,
           last_name
    INTO   emp_first_name, emp_last_name
    FROM   employees
    WHERE  employee_id = zemp_id;

    dbms_output.Put_line ('Employee name: '
                          || emp_first_name
                          ||' '
                          ||emp_last_name);
EXCEPTION
    WHEN no_data_found THEN
      dbms_output.Put_line ('There is no employee with the ID '||to_char(zemp_id));
END; 


--5. Write a program in PL/SQL to show the uses of SQL%FOUND to determine if a DELETE statement
-- affected any rows.


DROP TABLE emp_temp;
CREATE TABLE emp_temp AS
  SELECT employee_id, first_name, last_name 
  FROM employees;
 
CREATE OR REPLACE PROCEDURE test_proc (
  z_emp_id NUMBER
)  AS
BEGIN
  DELETE FROM emp_temp
  WHERE employee_id = z_emp_id;
 
  IF SQL%FOUND THEN
    DBMS_OUTPUT.PUT_LINE (
      'Delete succeeded for employee_id: ' || z_emp_id
    );
  ELSE
    DBMS_OUTPUT.PUT_LINE ('No employee of ID '|| z_emp_id||'is found.');
  END IF;
END;
/
BEGIN
  test_proc(1);
  test_proc(444);
END;

select * from emp_temp ;

--6. Write a program in PL/SQL to show the uses of SQL%NOTFOUND to determine if a UPDATE statement 
--affected any rows.

DROP TABLE emp_temp;
CREATE TABLE emp_temp AS
  SELECT employee_id, first_name, last_name,email 
  FROM employees;
  
DECLARE
	z_emp_id NUMBER:=&employee_id;
BEGIN
    UPDATE emp_temp
    SET    email = 'not available'
    WHERE employee_id = z_emp_id;
 
  IF SQL%NOTFOUND THEN
      DBMS_OUTPUT.PUT_LINE ('No employee of ID '|| z_emp_id||' is found.');
  ELSE
    DBMS_OUTPUT.PUT_LINE (
      'Update succeeded for employee_id: ' || z_emp_id
    );
  END IF;
END;


--7. Write a program in PL/SQL to create a table-based record using the %ROWTYPE attribute.

DECLARE
    vr_employee employees%ROWTYPE;
	z_emp_id NUMBER:=&employee_id;
BEGIN
    SELECT *
    INTO   vr_employee
    FROM   employees
    WHERE  employee_id = z_emp_id;

    dbms_output.Put_line (vr_employee.first_name
                          ||' '
                          ||vr_employee.last_name
                          ||' has an ID of '||z_emp_id);
EXCEPTION
    WHEN no_data_found THEN
      Raise_application_error(-20001, 'The Employee '
                                     || 'is not in the database');
END; 

--8. Write a program in PL/SQL to display a table based detail information for the employee of ID 149 from 
--the employees table.

DECLARE 
    z_employee employees%ROWTYPE; 
BEGIN 
    SELECT * 
    INTO   z_employee -- INTO clause always notifies only single row can be fetch 
    FROM   employees 
    WHERE  employee_id = 149; 

    dbms_output.Put_line('Employee Details :   ID:' 
                         ||z_employee.employee_id 
                         ||'  Name: ' 
                         ||z_employee.first_name 
                         ||' ' 
                         ||z_employee.last_name 
                         ||'  Salary:  ' 
                         ||z_employee.salary); 
END; 


-- 9. Write a program in PL/SQL to display a cursor based detail information of employees from employees table.

declare
  cursor emp is
    select employee_id, first_name, last_name, email, job_title
      from employees;

  emp_info emp%rowtype;
begin
  open emp;
  loop
    fetch emp
      into emp_info;
    exit when emp%notfound;
    dbms_output.put_line('employee info: ' || 'Id: ' ||
                         emp_info.employee_id || ' F_name: ' ||
                         emp_info.first_name || ' L_name: ' ||
                         emp_info.last_name || ' Email: ' ||
                         emp_info.email || ' Job_title: ' ||
                         emp_info.job_title);
  
  end loop;
  close emp;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Backtrace: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;


select * from employees ;

--10. Write a program in PL/SQL to retrieve the records from the employees table and display them using cursors.

declare
  cursor emp is
    select employee_id, first_name, last_name from hr.employees;
  v_emp_id hr.employees.employee_id%type;
  v_fname  hr.employees.first_name%type;
  v_lname  hr.employees.last_name%type;
begin
  open emp;
  loop
    fetch emp
      into v_emp_id, v_fname, v_lname;
    exit when emp%notfound;
    dbms_output.put_line('Id: ' || v_emp_id || ' Fname: ' || v_fname ||
                         ' Lname: ' || v_lname);
  end loop;
  close emp;
exception
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Backtrace: ' ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;

--11. Write a program in PL/SQL to declare a record datatype with same datatype of tables using %TYPE attribute.


DECLARE
  CURSOR cur_emp_detail IS
    SELECT employee_id, first_name, last_name, salary FROM hr.employees;
  TYPE type_record_type IS RECORD(
    emp_id       hr.employees.employee_id%TYPE,
    emp_f_name   hr.employees.first_name%TYPE,
    emp_l_name   hr.employees.last_name%TYPE,
    emp_s_salary hr.employees.salary%TYPE);
  emp_rec_type type_record_type;
BEGIN
  OPEN cur_emp_detail;
  LOOP
    FETCH cur_emp_detail
      INTO emp_rec_type;
    EXIT WHEN cur_emp_detail%NOTFOUND;
    dbms_output.Put_line('Employees Information::  ' || '  ID: ' ||
                         emp_rec_type.emp_id || '|   Name: ' ||
                         emp_rec_type.emp_f_name || ' ' ||
                         emp_rec_type.emp_l_name || '|   Salary: ' ||
                         emp_rec_type.emp_s_salary);
  END LOOP;
  dbms_output.Put_line('Total number of Employees : ' ||
                       cur_emp_detail%rowcount);
  CLOSE cur_emp_detail;
END;
/*"In this version, I use a custom RECORD type to group related columns with custom names.
It gives me flexibility in naming and lets me standardize how I handle data, 
but I have to keep the record structure in sync with the SELECT list manually."*/
/* When to use
When you want custom field names that are different from column names.

When you want to pass structured data between program units.*/


DECLARE
  CURSOR cur_emp_detail IS
    SELECT employee_id, first_name, last_name, salary FROM hr.employees;
    emp_id       hr.employees.employee_id%TYPE;
    emp_f_name   hr.employees.first_name%TYPE;
    emp_l_name   hr.employees.last_name%TYPE;
    emp_s_salary hr.employees.salary%TYPE;
  --emp_rec_type type_record_type;
BEGIN
  OPEN cur_emp_detail;
  LOOP
    FETCH cur_emp_detail
      INTO emp_id,emp_f_name,emp_l_name,emp_s_salary;
    EXIT WHEN cur_emp_detail%NOTFOUND;
    dbms_output.Put_line('Employees Information::  ' || '  ID: ' ||
                         emp_id || '|   Name: ' ||
                         emp_f_name || ' ' ||
                         emp_l_name || '|   Salary: ' ||
                         emp_s_salary);
  END LOOP;
  dbms_output.Put_line('Total number of Employees : ' ||
                       cur_emp_detail%rowcount);
  CLOSE cur_emp_detail;
END;
/*"This is the simplest approach: I declare one variable for each column, so the FETCH maps directly.
Its easy for a few columns, but if the query grows, this style is hard to maintain."*/
/*When to use
Small queries with few columns.

Ad hoc scripts or very simple anonymous blocks.*/

DECLARE
  CURSOR cur_emp_detail IS
    SELECT employee_id, first_name, last_name, salary FROM hr.employees;

  emp_rec_type cur_emp_detail%rowtype;
BEGIN
  OPEN cur_emp_detail;
  LOOP
    FETCH cur_emp_detail
      INTO emp_rec_type;
    EXIT WHEN cur_emp_detail%NOTFOUND;
    dbms_output.Put_line('Employees Information::  ' || '  ID: ' ||
                         emp_rec_type.employee_id || '|   Name: ' ||
                         emp_rec_type.first_name || ' ' ||
                         emp_rec_type.last_name || '|   Salary: ' ||
                         emp_rec_type.salary);
  END LOOP;
  dbms_output.Put_line('Total number of Employees : ' ||
                       cur_emp_detail%rowcount);
  CLOSE cur_emp_detail;
END;
/*-"I use the cursors %ROWTYPE to automatically match the structure of the SELECT list.
This is easy to maintain  if I add or remove columns, I dont need to update my variable declaration manually.
Its more robust and less error-prone for large rows."*/
/*When to use
Best practice for static cursors when you want to fetch entire rows or partial rows.

Default choice for most real projects  safer than custom record or multiple scalars.*/

--12. Write a program in PL/SQL to create an implicit cursor with for loop.

BEGIN
  FOR emprec IN (SELECT department_name,
                        d.department_id,
                        first_name,
                        last_name,
                        job_id,
                        salary
                   FROM hr.departments d
                   join hr.employees e
                     ON e.department_id = d.department_id
                  WHERE job_id = 'ST_CLERK'
                    AND salary > 3000) LOOP
    dbms_output.Put_line('Name: ' || emprec.first_name || ' ' ||
                         emprec.last_name || chr(9) || ' Department: ' ||
                         emprec.department_name || chr(9) ||
                         ' Department ID: ' || emprec.department_id ||
                         chr(9) || ' Job ID: ' || emprec.job_id || chr(9) ||
                         ' Salary: ' || emprec.salary);
  END LOOP;
END;

--13. Write a program in PL/SQL to create an explicit cursor with for loop.

---implicit cursor FOR loop
begin
  for rec in (select * from hr.employees) loop
    dbms_output.put_line(rec.employee_id || ' ' || rec.first_name || ' ' ||
                         rec.last_name);
  end loop;
end;

---explicit cursor FOR loop
DECLARE
  CURSOR emp_cur IS
    SELECT employee_id, first_name, last_name FROM hr.employees;
BEGIN
  FOR rec IN emp_cur LOOP
    DBMS_OUTPUT.PUT_LINE(rec.employee_id || ' ' || rec.first_name || ' ' || rec.last_name);
  END LOOP;
END;

--14. Create a PL/SQL block to increase salary of employees in the department 50 using WHERE CURRENT OF clause.

DROP TABLE emp_temp;

CREATE TABLE emp_temp AS
  SELECT employee_id,
         first_name,
         last_name,
		 department_id,
         salary
  FROM   hr.employees;

DECLARE
  CURSOR employee_cur IS
    SELECT employee_id, salary
      FROM emp_temp
     WHERE department_id = 50
       FOR UPDATE;
  incr_sal NUMBER;
BEGIN
  FOR employee_rec IN employee_cur LOOP
    IF employee_rec.salary < 15000 THEN
      incr_sal := .15;
    ELSE
      incr_sal := .10;
    END IF;
  
    UPDATE emp_temp
       SET salary = salary + salary * incr_sal
     WHERE CURRENT OF employee_cur;
  END LOOP;
  EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);

END;

select * from emp_temp where salary < 15000 ;

--15. Write a program in PL/SQL to FETCH single record and single column from a table.


DECLARE
  v_emp_name VARCHAR2(50);
  CURSOR emp_cur_name IS
    SELECT first_name
    FROM   employees
    WHERE  employee_id = 105;

BEGIN
  OPEN emp_cur_name;
  FETCH emp_cur_name
  INTO  v_emp_name;
  
  -- Fixing the issue by replacing the incorrect single quotation mark
  dbms_output.put_line('The name of the employee is: ' || v_emp_name);
  CLOSE emp_cur_name;
END;

--16. Write a program in PL/SQL to FETCH more than one record and single column from a table.

DECLARE
  v_emp_name VARCHAR2(20);
  CURSOR cur_emp_name IS
    SELECT first_name
    FROM   hr.employees;

BEGIN
  OPEN cur_emp_name;
  LOOP
    FETCH cur_emp_name
    INTO  v_emp_name;
    EXIT
  WHEN cur_emp_name%NOTFOUND;
  
    dbms_output.put_line('Name of employee: ' || v_emp_name);
  END LOOP;
  CLOSE cur_emp_name;
END;


--17. Write a program in PL/SQL to FETCH multiple records and more than one columns from the same table.

DECLARE
    v_emp_rec hr.employees%ROWTYPE;
    CURSOR cur_emp_name IS
      SELECT *
      FROM   hr.employees;
BEGIN
    OPEN cur_emp_name;
    LOOP
        FETCH cur_emp_name INTO v_emp_rec;
        exit WHEN cur_emp_name%NOTFOUND;
        dbms_output.Put_line('Name: '
                             || v_emp_rec.first_name
                             || '  ::   Salary: '
                             || v_emp_rec.salary);
    END LOOP;
    CLOSE cur_emp_name;      
END; 


--18. Write a program in PL/SQL to FETCH multiple records and more than one columns from different tables.

DECLARE
    CURSOR cur_emp_name IS
      SELECT first_name,
             last_name,
             department_name
      FROM   hr.employees e,
             hr.departments d
      WHERE  d.department_id = e.department_id;
    v_emp_rec cur_emp_name%ROWTYPE;
BEGIN
    OPEN cur_emp_name;
    LOOP
        FETCH cur_emp_name INTO v_emp_rec;
        exit WHEN cur_emp_name%NOTFOUND;
        dbms_output.Put_line('Name:  '
                             || v_emp_rec.first_name
                             || '  '
                             ||v_emp_rec.last_name
                             || '   ::   department: '
                             || v_emp_rec.department_name);
    END LOOP;
    CLOSE cur_emp_name;
END; 

--19. Write a program in PL/SQL to FETCH multiple records with the uses of nested cursor.

DECLARE
    e_dept_no hr.employees.department_id%TYPE;
    CURSOR cur_deptartments IS
      SELECT *
      FROM   hr.departments;
    CURSOR cur_employees IS
      SELECT *
      FROM   hr.employees e
      WHERE  e.department_id = e_dept_no;
    v_deptrec hr.departments%ROWTYPE;
    v_emprec  hr.employees%ROWTYPE;
BEGIN
    OPEN cur_deptartments;
    LOOP
        FETCH cur_deptartments INTO v_deptrec;
        exit WHEN cur_deptartments%NOTFOUND;
        e_dept_no := v_deptrec.department_id;
    
    
      DBMS_OUTPUT.PUT_LINE('----------------------------------');
      DBMS_OUTPUT.PUT_LINE('Department Name : '||v_deptrec.department_name);
      DBMS_OUTPUT.PUT_LINE('----------------------------------');   

        OPEN cur_employees;
        LOOP
            FETCH cur_employees INTO v_emprec;
            exit WHEN cur_employees%NOTFOUND;
            dbms_output.Put_line('Employee: '
                                 || v_emprec.first_name
                 ||chr(9)||'Salary: '
                 || v_emprec.salary);
        END LOOP;
        CLOSE cur_employees;

    END LOOP;
    CLOSE cur_deptartments;
END; 

--20. Write a program in PL/SQL to FETCH records with nested Cursors using Cursor FOR Loops.

DECLARE
  emp_dept_id hr.departments.department_id%TYPE;
 CURSOR cur_dept IS
  SELECT * 
  FROM hr.departments
  WHERE manager_id IS NOT NULL
  ORDER BY department_name;
 CURSOR cur_emp IS
  SELECT * 
  FROM hr.employees
  WHERE department_id = emp_dept_id;
  
BEGIN
    FOR r_dept IN cur_dept
    LOOP
      emp_dept_id := r_dept.department_id;
      DBMS_OUTPUT.PUT_LINE('----------------------------------');
      DBMS_OUTPUT.PUT_LINE('Department Name : '||r_dept.department_name);
      DBMS_OUTPUT.PUT_LINE('----------------------------------');
           FOR r_emp IN cur_emp 
           LOOP
             DBMS_OUTPUT.PUT_LINE('Employee: '||r_emp.last_name);
           END LOOP;   
    END LOOP;
END;

--=======================================================================
--=======================================================================
--------------------------packages-----------------------------------------


--1. Write a PL/SQL code to create a package that includes a procedure to calculate the factorial of a number 
--and a function to check if a number is prime.
-- Package Specification

CREATE OR REPLACE PACKAGE MathUtils IS
  PROCEDURE CalcFact(n IN NUMBER, res OUT NUMBER);
  FUNCTION IsPrime(n IN NUMBER) RETURN BOOLEAN;
END MathUtils;


-- Package Body
CREATE OR REPLACE PACKAGE BODY MathUtils IS

  PROCEDURE CalcFact(n IN NUMBER, res OUT NUMBER) IS
    fact NUMBER := 1;
  BEGIN
    IF n < 0 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Negative number not allowed.');
    END IF;

    FOR i IN 2..n LOOP
      fact := fact * i;
    END LOOP;

    res := fact;
  END CalcFact;

  FUNCTION IsPrime(n IN NUMBER) RETURN BOOLEAN IS
    i NUMBER := 2;
  BEGIN
    IF n < 2 THEN
      RETURN FALSE;
    END IF;

    WHILE i <= SQRT(n) LOOP
      IF MOD(n, i) = 0 THEN
        RETURN FALSE;
      END IF;
      i := i + 1;
    END LOOP;

    RETURN TRUE;
  END IsPrime;

END MathUtils;


-- Anonymous Block to Test
DECLARE
  fact NUMBER;
  prime BOOLEAN;
BEGIN
  MathUtils.CalcFact(7, fact);
  DBMS_OUTPUT.PUT_LINE('Factorial of 7: ' || fact);

  IF MathUtils.IsPrime(7) THEN
    DBMS_OUTPUT.PUT_LINE('7 is prime.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('7 is not prime.');
  END IF;
END;


--Write a procedure to increase salary by 10% for a given employee ID.

create or replace procedure inc_sal(p_id in number) is
  v_sal number;

begin
  select salary into v_sal from hr.employees where employee_id = p_id;
  v_sal := v_sal * 0.10;
  dbms_output.put_line(v_sal);
end;

begin
  inc_sal(100);
end;

--Write a procedure that accepts a department ID and prints the total number of employees in that department.

create or replace procedure dpt_count(v_dpt_id number) is
  v_count number;
begin
  select count(employee_id)
    into v_count
    from hr.employees
   where department_id = v_dpt_id;
  dbms_output.put_line('count_of emp is: ' || v_count ||
                       ' IN department: ' || v_dpt_id);
exception
  when no_data_found then
    dbms_output.put_line('There are no employee in department: ' ||
                         v_dpt_id);
  
end;

begin
dpt_count(20);
end;

--Create a procedure to insert a new record into the departments table.

select * from departmentsss

create or replace procedure dpt_insert(v_dpt_id number, v_dpt_name in varchar2) is
begin
  insert into departmentsss values (v_dpt_id, v_dpt_name);
  dbms_output.put_line(v_dpt_id || v_dpt_name);
end;

begin
dpt_insert(10, 'IT');
end;

--Write a procedure to delete employees whose salary is below a given amount.

select count(*) from employee1

create or replace procedure emp_det(v_sal number) is
 -- v_sal number := 3000;
begin
  delete from employee1 where salary < v_sal ;
  exception
    when others then
      dbms_output.put_line(SQLERRM);
end;
  
begin
  emp_det(4000);
end;

--Write a procedure that updates the email of an employee based on employee ID.
create or replace procedure emp_email_upd(p_emp_id number) is
begin
  update employee1 set email = 'test' where employee_id = p_emp_id;
end;

begin
emp_email_upd(100);
end;

select * from employee1;

--Write a procedure using a cursor to list all employees from a given department.
create or replace procedure emp_all(p_dpt in number) is
  cursor c_emp is
    select employee_id, first_name, department_id
      from employee1
     where department_id = p_dpt;

  v_emp_id     employee1.employee_id%type;
  v_first_name employee1.first_name%type;
  v_dpt_id     employee1.department_id%type;
begin
  open c_emp;
  loop
    fetch c_emp
      into v_emp_id, v_first_name, v_dpt_id;
    exit when c_emp%notfound;
    dbms_output.put_line(v_emp_id || v_first_name || v_dpt_id);
  end loop;
  close c_emp;
end;
         
begin
 emp_all(90);
end;

--Write a procedure that loops through all employees and prints names of those earning more than 
--department average salary.

create or replace procedure all_emp is
  cursor v_cur is
    SELECT employee_id, first_name, salary, department_id
      FROM employee1 e
     WHERE salary > (SELECT AVG(salary)
                       FROM employee1
                      WHERE department_id = e.department_id)
       AND department_id IS NOT NULL;

  v_emp_id     employee1.employee_id%type;
  v_first_name employee1.first_name%type;
  v_sal        employee1.salary%type;
  v_dpt_id     employee1.department_id%type;
begin
  open v_cur;
  loop
    fetch v_cur
      into v_emp_id, v_first_name, v_sal, v_dpt_id;
    exit when v_cur%notfound;
    DBMS_OUTPUT.PUT_LINE('Emp ID: ' || v_emp_id || ', Name: ' ||
                         v_first_name || ', Salary: ' || v_sal ||
                         ', Dept ID: ' || v_dpt_id);
  end loop;
  close v_cur;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error occurred: ' || SQLERRM);
end;

begin
  all_emp;
end;

--Write a procedure to fetch and display the names of all jobs using an explicit cursor.
create or replace procedure job_name is
  cursor c_job_name is
    select job_id, job_title from hr.jobs;

  v_job_id    hr.jobs.job_id%type;
  v_job_title hr.jobs.job_title%type;

begin
  open c_job_name;
  loop
    fetch c_job_name
      into v_job_id, v_job_title;
    exit when c_job_name%notfound;
    DBMS_OUTPUT.PUT_LINE('Job ID: ' || v_job_id || ', Title: ' ||
                         v_job_title);
  end loop;
  close c_job_name;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
end;

begin
  job_name;
end;


--A stored procedure in Oracle PL/SQL is a named block of code (like a function) that performs a specific task
--and is stored in the database. You can call it multiple times, pass parameters, and even include conditional
--logic, loops, cursors, etc.

CREATE OR REPLACE PROCEDURE get_bonus   ----get_bonus(salary,bonus)
(salary IN NUMBER, bonus OUT NUMBER) IS  ---b
BEGIN
  bonus := salary * 0.10;
END;

DECLARE
  b NUMBER;
BEGIN
  get_bonus(5000, b);
  DBMS_OUTPUT.PUT_LINE('Bonus: ' || b);
END;

CREATE OR REPLACE PROCEDURE get_bonus   ----get_bonus(salary,bonus)
(salary IN NUMBER, bonus OUT NUMBER,total out number) IS  ---b
BEGIN
  bonus := salary * 0.10;
  total := salary + bonus;
END;

DECLARE
  b NUMBER;
  t number;
BEGIN
  get_bonus(5000, b, t);
  DBMS_OUTPUT.PUT_LINE('Bonus: ' || b || ' Total : ' || t);
END;
----

CREATE OR REPLACE PROCEDURE show_low_salary_employees IS
BEGIN
  FOR rec IN (SELECT first_name, salary FROM hr.employees WHERE salary < 3000) LOOP
    DBMS_OUTPUT.PUT_LINE(rec.first_name || ' - ' || rec.salary);
  END LOOP;
END;

BEGIN
  show_low_salary_employees;
END;
/

----
CREATE OR REPLACE PROCEDURE increase_salary(emp_id IN NUMBER, pct IN NUMBER) IS
BEGIN
  UPDATE employee1
  SET salary = salary + (salary * pct / 100)
  WHERE employee_id = emp_id;

  DBMS_OUTPUT.PUT_LINE('Salary updated for employee ' || emp_id);
END;

begin
increase_salary(101, 200);
end;
----

--1.Write a stored procedure that accepts a person's name as an IN parameter and prints a welcome message like:
--Hello, [name]! Welcome to our system.
CREATE OR REPLACE PROCEDURE greet_user(p_name IN VARCHAR2) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name || '!');
END;

begin
greet_user('Alex');
end;

--2.Create a procedure that takes a number as IN, calculates its square, and returns it through an OUT parameter.

create or replace procedure p_square(p_number  in number,
                                     p_squarer out number) is
begin
  p_squarer := p_number * p_number;
end;
  
declare
  a number;
  b number := &num;
begin
  p_square(b, a);
  dbms_output.put_line('Square root of ' || b || ' is : ' || a);
end;

--3.Write a procedure that accepts an employee ID as input and prints the employee's name and 
--salary using the employees table.

create or replace procedure p_emp(P_empid in number) is
begin
  for rec in (select first_name, salary
                from employee1
               where employee_id = p_empid) loop
    dbms_output.put_line(rec.first_name || ' - ' || rec.salary);
  end loop;
end;
    
    
  begin
    p_emp(100);
  end;
---way 2     
create or replace procedure p_emp(P_empid in number) is
  cursor c_emp is
    select first_name, salary from employee1 where employee_id = p_empid;
  v_fname employee1.first_name%type;
  v_sal   employee1.salary%type;
begin
  open c_emp;
  loop
    fetch c_emp
      into v_fname, v_sal;
    exit when c_emp%notfound;
    dbms_output.put_line(v_fname || ' - ' || v_sal);
  end loop;
end;

begin
  p_emp(101);
end;
---way 3
create or replace procedure p_emp(P_empid in number,
                                  p_name  out varchar2,
                                  p_sal   out number) is
begin
  select first_name, salary
    into p_name, p_sal
    from employee1
   where employee_id = p_empid;
  dbms_output.put_line(p_name || p_sal);
end;

declare a varchar2(50); b number;
begin
p_emp(100, a, b);
end;
--way4
create or replace procedure p_emp(P_empid in number,
                                  v_fname out varchar2,
                                  v_sal   out number) is
  cursor c_emp is
    select first_name, salary from employee1 where employee_id = p_empid;
  --v_fname employee1.first_name%type;
  --v_sal   employee1.salary%type;
begin
  open c_emp;
  loop
    fetch c_emp
      into v_fname, v_sal;
    exit when c_emp%notfound;
    dbms_output.put_line(v_fname || ' - ' || v_sal);
  end loop;
end;

declare a varchar2(50); b number;
begin
p_emp(101, a, b);
end;
    
--4.Create a procedure that takes a city name as input and prints all customer names from that city 
--(use your customer1 table).

create or replace procedure p_emp(P_cadd in varchar2, p_cname out varchar2) is
begin
  select cname into p_cname from customer1 where cadd = p_cadd;
  dbms_output.put_line(p_cname);
end;

declare a varchar2(30);
begin
p_emp('NEW YORK', a);
end;
---
create or replace procedure p1(p_city in varchar2, p_cname out varchar2) is
  cursor cur is
    select cname into p_cname from customer1 where cadd = P_city;
begin
  open cur;
  loop
    fetch cur
      into p_cname;
    exit when cur%notfound;
    dbms_output.put_line(p_cname || ' - ' || p_city);
  end loop;
end;
 
declare
  add varchar2(100);
begin
  p1('NEW YORK', add);
end;

select * from customer1;

--5.Write a procedure that accepts a vendor ID and additional credit days as IN parameters, 
--and updates the vcreditdays in the vendors table.

create or replace procedure p_v(p_vid in number, p_adddays in number) is
  v_addcredit number := 0;

begin
  for rec in (select vcreditdays from vendors where vid = p_vid) loop
    v_addcredit := rec.vcreditdays + p_adddays;
    dbms_output.put_line(' before add days : ' || rec.vcreditdays ||
                         ' after : ' || v_addcredit);
  
    update vendors1 set vcreditdays = v_addcredit where vid = p_vid;
  
  end loop;
end;

begin
  p_v(2001, 5);
end;

rollback;

create table vendors1 as select * from vendors ;

select * from vendors1;

--6.Create a procedure that accepts a department ID as input. For all employees in that department:
--If salary < 3000, print: Low earner: [name] - [salary]
--If salary >= 3000, print: Eligible for incentive: [name] - [salary]

create or replace procedure p_emp(p_dptid in number) is
begin
  for rec in (select salary, first_name
                from hr.employees
               where department_id = p_dptid) loop
    if rec.salary < 3000 then
      dbms_output.put_line('Low earner : ' || rec.first_name ||
                           ' salary is : ' || rec.salary);
    else
      dbms_output.put_line('Eligible for incentive: ' || rec.first_name ||
                           ' salary is : ' || rec.salary);
    end if;
  end loop;
end;
      
begin
  p_emp(90);
end;

--7.Write a procedure that takes a city name as input and returns the number of customers 
--in that city through an OUT parameter.

create or replace procedure p_city is
begin
  for rec in (select count(e.employee_id) as total_cus, l.city
                from hr.employees e
                join hr.departments d
                  on e.department_id = d.department_id
                join hr.locations l
                  on l.location_id = d.location_id
               where l.city in ('Oxford' , 'London')
               group by l.city) loop
    dbms_output.put_line('Total customer in ' || rec.city || ' is : ' ||
                         rec.total_cus);
  end loop;
  EXCEPTION
  WHEN OTHERS THEN
    dbms_output.put_line('err:-'||dbms_utility.format_error_stack);
    dbms_output.put_line('Backtrace: ' ||dbms_utility.format_error_backtrace);
END;

begin
  p_city;
end;
----Way 2
create or replace procedure p1(p_count out number) is
begin
  
select count(e.employee_id) into p_count  from hr.employees e
    join hr.departments d on e.department_id = d.department_id
    join hr.locations l on l.location_id = d.location_id 
    where l.city = 'Oxford'
    group by l.city ;
    dbms_output.put_line('total customer : '|| p_count);
    end;

declare
v_count  number;
begin
p1(v_count);
end;
 

select * from hr.locations ;
select * from hr.departments ;
select * from hr.employees ;

select count(e.employee_id) as total_cus, l.city  from hr.employees e
    join hr.departments d on e.department_id = d.department_id
    join hr.locations l on l.location_id = d.location_id 
    where l.city in ('Oxford' , 'London')
    group by l.city ;

--8.Create a procedure to loop through all vendors:
--If vcreditdays is below 15, increase it by 5.
--Print updated credit days for such vendors.
--Use a cursor FOR loop.

create or replace procedure p_vendor is
  v_increase number := 0;
begin
  for rec in (select vname, vcreditdays from vendors) loop
    if rec.vcreditdays < 15 then
      v_increase := rec.vcreditdays + 5;
      dbms_output.put_line('Updated credit days is : ' || v_increase ||
                           ' to ' || rec.vcreditdays);
    end if;
  end loop;
end;

begin
p_vendor;
end;

select * from vendors;

--9.Create a procedure that loops through the ser_det table:
--For each row, calculate ser_amt + sp_amt.
--If the total is more than 700, print the SID and total with a message:
--High bill: SID [sid] - Total: [amount]

create or replace procedure p_ser_det is
  v_total number := 0;
begin
  for rec in (select sid, ser_amt, sp_amt from ser_det) loop
    if rec.ser_amt + rec.sp_amt > 700 then
      v_total := rec.ser_amt + rec.sp_amt;
      dbms_output.put_line('High bill : ' || rec.sid || ' Total : ' ||
                           v_total);
    end if;
  end loop;
end;
    
begin
  p_ser_det;
end;


--Write a PL/SQL procedure named Check_Bonus_Eligibility that:
--Uses an explicit cursor to retrieve all employees from the HR.EMPLOYEES table.
--For each employee, based on their salary:
--If the salary is less than 5000, print:
--'Employee [first_name last_name] (ID: [employee_id]) is eligible for bonus.'
--If the salary is between 5000 and 10000, print:
--'Employee [first_name last_name] (ID: [employee_id]) may be considered for bonus.'
--Else, print:
--'Employee [first_name last_name] (ID: [employee_id]) is not eligible for bonus.'
--Count how many employees fall into each category, and display the totals at the end.

create or replace procedure p_emp is
  v_count1 number := 0;
  v_count2 number := 0;
  v_count3 number := 0;
begin
  for rec in (select first_name, last_name, employee_id, salary
                from hr.employees) loop
    if rec.salary < 5000 then
      v_count1 := v_count1 + 1;
      dbms_output.put_line('Employee : ' || rec.first_name || ' ' ||
                           rec.last_name || ' ID : ' || rec.employee_id ||
                           ' is eligible for bonus ');
      dbms_output.put_line('                                                  ');
    elsif rec.salary between 5000 and 10000 then
      v_count2 := v_count2 + 1;
      dbms_output.put_line('Employee : ' || rec.first_name || ' ' ||
                           rec.last_name || ' ID : ' || rec.employee_id ||
                           ' may be considered for bonus ');
      dbms_output.put_line('                                                  ');
    else
      v_count3 := v_count3 + 1;
      dbms_output.put_line('Employee : ' || rec.first_name || ' ' ||
                           rec.last_name || ' ID : ' || rec.employee_id ||
                           '  is not eligible for bonus. ');
      dbms_output.put_line('                                                  ');
    end if;
  end loop;
  dbms_output.put_line('                                                   ');
  dbms_output.put_line('--------------------------------------------------');
  dbms_output.put_line('                                                  ');
  dbms_output.put_line('Total emp that have salary < 5000 is : ' ||
                       v_count1);
  dbms_output.put_line('                                                  ');
  dbms_output.put_line('Total emp that have salary between 5000 and 10000 is : ' ||
                       v_count2);
  dbms_output.put_line('                                                  ');
  dbms_output.put_line('Total emp that have other salary  is : ' ||
                       v_count3);
end;

begin
  p_emp;
end;
-----Way 2
CREATE OR REPLACE PROCEDURE Check_Bonus_Eligibility IS
    -- Declare explicit cursor to fetch employees
    CURSOR emp_cursor IS
        SELECT employee_id, first_name, last_name, salary
        FROM HR.EMPLOYEES;
 
    -- Declare variables to store employee data
    v_employee_id HR.EMPLOYEES.employee_id%TYPE;
    v_first_name HR.EMPLOYEES.first_name%TYPE;
    v_last_name HR.EMPLOYEES.last_name%TYPE;
    v_salary HR.EMPLOYEES.salary%TYPE;
 
    -- Counters for each category
    eligible_count NUMBER := 0;
    consider_count NUMBER := 0;
    not_eligible_count NUMBER := 0;
 
BEGIN
    -- Iterate through employees using a cursor loop
    FOR emp_rec IN emp_cursor LOOP
        v_employee_id := emp_rec.employee_id;
        v_first_name := emp_rec.first_name;
        v_last_name := emp_rec.last_name;
        v_salary := emp_rec.salary;
 
        -- Determine bonus eligibility
        IF v_salary < 5000 THEN
            DBMS_OUTPUT.PUT_LINE('Employee ' || v_first_name || ' ' || v_last_name ||
                                ' (ID: ' || v_employee_id || ') is eligible for bonus.');
            eligible_count := eligible_count + 1;
        ELSIF v_salary BETWEEN 5000 AND 10000 THEN
            DBMS_OUTPUT.PUT_LINE('Employee ' || v_first_name || ' ' || v_last_name ||
                                ' (ID: ' || v_employee_id || ') may be considered for bonus.');
            consider_count := consider_count + 1;
        ELSE
            DBMS_OUTPUT.PUT_LINE('Employee ' || v_first_name || ' ' || v_last_name ||
                                ' (ID: ' || v_employee_id || ') is not eligible for bonus.');
            not_eligible_count := not_eligible_count + 1;
        END IF;
    END LOOP;
 
    -- Print summary counts
    DBMS_OUTPUT.PUT_LINE('Total eligible employees: ' || eligible_count);
    DBMS_OUTPUT.PUT_LINE('Total employees for consideration: ' || consider_count);
    DBMS_OUTPUT.PUT_LINE('Total employees not eligible: ' || not_eligible_count);
END Check_Bonus_Eligibility;

begin
Check_Bonus_Eligibility;
end;


--Q1  Department Bonus Procedure
--Write a procedure dept_bonus that:

Takes p_dept_id (IN) and p_bonus_percentage (IN)
Increases salary for all employees in that department by the given percentage.
Prints how many employees got the bonus.
If no employees exist in that department, print "No employees in department".
--

create or replace procedure dept_bonus(p_dept_id          in varchar2,
                                       p_bonus_percentage in number) is
  cursor c_emp is
    select emp_id, salary
      from employees1
     where department = p_dept_id
       for update;
  v_emp_id employees1.emp_id%type;
  v_salary employees1.salary%type;
  counter  number := 0;
begin
  open c_emp;
  loop
    fetch c_emp
      into v_emp_id, v_salary;
    exit when c_emp%notfound;
    update employees1
       set salary = v_salary + (v_salary * p_bonus_percentage / 100)
    -- where emp_id = v_emp_id
     where current of c_emp;
  
    counter := counter + 1;
  end loop;
  close c_emp;
  if counter > 0 then
    dbms_output.put_line(counter || 'employee updated');
  else
    dbms_output.put_line('no record found');
  end if;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_backtrace);
end;


begin
  dept_bonus('HR', 10);
end;

select * from user_objects where object_name = upper('get_emp_info');

select * from employees1



--Q2  Employee Promotion Procedure
--Write a procedure promote_emp that:

--Takes p_emp_id (IN) and p_increase_amt (IN)
--Checks if employee exists  if not, raise an application error.
--Checks if new salary exceeds jobs max_salary from jobs table  if yes, raise an error.
--Updates salary and commits the change.

create or replace procedure promote_emp(p_emp_id       in number,
                                        p_increase_amt in number) is
  cursor emp is
    select e.salary, e.job_id, j.max_salary, e.employee_id
      from hr.employees e
      join hr.jobs j
        on e.job_id = j.job_id
     where employee_id = p_emp_id
       for update;

  v_salary  hr.employees.salary%type;
  v_job_id  hr.employees.job_id%type;
  v_max_sal hr.jobs.max_salary%type;
  v_emp_id  hr.employees.employee_id%type;

begin
  open emp;
  loop
    fetch emp
      into v_salary, v_job_id, v_max_sal, v_emp_id;
    exit when emp%notfound;
  
    if v_emp_id is null then
      RAISE_APPLICATION_ERROR(-20001, 'NO emp');
    end if;
  
    if p_increase_amt + v_salary > v_max_sal then
      RAISE_APPLICATION_ERROR(-20001, 'salary is greter than max_salary');
    end if;
  
    update hr.employees
       set salary = v_salary + p_increase_amt
     where current of emp;
  end loop;
  commit;

  close emp;
exception
  when others then
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;



select * from hr.jobs ;
select * from hr.employees ;

--Q3  Employee Info Procedure with OUT Parameters
--Write a procedure get_emp_info that:

--Takes p_emp_id (IN)
--Returns employees first_name, salary, and department_name using OUT parameters.
--If employee does not exist, set all OUT parameters to "N/A".


create or replace procedure get_emp_info(p_emp_id        in number,
                                         p_first_name    out hr.employees.first_name%type,
                                         p_salary        out hr.employees.salary%type,
                                         p_department_id out hr.employees.department_id%type) is
begin
  select first_name, salary, department_id
    into p_first_name, p_salary, p_department_id
    from hr.employees
   where employee_id = p_emp_id;
  dbms_output.put_line('Employee first name: ' || p_first_name ||
                       ' Salary: ' || p_salary || ' Employee Dpt: ' ||
                       p_department_id);
exception
  when no_data_found then
    p_first_name    := 'N/A';
    p_salary        := null;
    p_department_id := null;
  
    dbms_output.put_line('Employee first name: ' || p_first_name ||
                         ' Salary: ' || p_salary || ' Employee Dpt: ' ||
                         p_department_id);
end;

declare
  v_first_name    hr.employees.first_name%type;
  v_salary        hr.employees.salary%type;
  v_department_id hr.employees.department_id%type;
begin
  get_emp_info(1021 ,v_first_name,v_salary, v_department_id);
end;

----2

create or replace procedure get_emp_info(
    p_emp_id        in number,
    p_first_name    out varchar2,
    p_salary        out varchar2,
    p_department_id out varchar2
) is
begin
    select first_name, to_char(salary), to_char(department_id)
    into p_first_name, p_salary, p_department_id
    from hr.employees
    where employee_id = p_emp_id;

    dbms_output.put_line(
        'Employee first name: ' || p_first_name ||
        ' Salary: ' || p_salary ||
        ' Employee Dpt: ' || p_department_id
    );

exception
    when no_data_found then
        p_first_name    := 'N/A';
        p_salary        := 'N/A';
        p_department_id := 'N/A';

        dbms_output.put_line(
            'Employee first name: ' || p_first_name ||
            ' Salary: ' || p_salary ||
            ' Employee Dpt: ' || p_department_id
        );
end;

----3

CREATE OR REPLACE PROCEDURE get_emp_info_cur (
    p_emp_id   IN  NUMBER,
    p_emp_cur  OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN p_emp_cur FOR
        SELECT first_name,
               salary,
               department_id
        FROM hr.employees
        WHERE employee_id = p_emp_id;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- No_data_found doesn't trigger for ref cursor, so you handle differently
        OPEN p_emp_cur FOR
            SELECT 'N/A' AS first_name,
                   NULL  AS salary,
                   NULL  AS department_id
            FROM dual;
END;

DECLARE
    v_cur SYS_REFCURSOR;
    v_fname hr.employees.first_name%TYPE;
    v_sal   hr.employees.salary%TYPE;
    v_dept  hr.employees.department_id%TYPE;
BEGIN
    get_emp_info_cur(115, v_cur);  -- Use an ID that may or may not exist
    
    LOOP
        FETCH v_cur INTO v_fname, v_sal, v_dept;
        EXIT WHEN v_cur%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE(
            'Employee Name: ' || v_fname ||
            ', Salary: ' || NVL(TO_CHAR(v_sal), 'N/A') ||
            ', Dept: ' || NVL(TO_CHAR(v_dept), 'N/A')
        );
    END LOOP;
    
    CLOSE v_cur;
END;

select * from user_objects where object_name = upper('get_emp_info');

--Q4  Country-wise Employee Count
--Write a procedure country_emp_count that:

--Takes p_country_id (IN)
--Prints total employees working in departments located in that country.
--If count is zero, print "No employees found in country".

CREATE OR REPLACE PROCEDURE country_emp_count(p_country_id IN hr.countries.country_id%TYPE) IS
    v_count NUMBER;
BEGIN
    SELECT COUNT(e.employee_id)
      INTO v_count
      FROM hr.employees e
      JOIN hr.departments d ON e.department_id = d.department_id
      JOIN hr.locations   l ON d.location_id   = l.location_id
      JOIN hr.countries   c ON l.country_id    = c.country_id
     WHERE c.country_id = p_country_id;

    IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Total employees in country ' || p_country_id || ' : ' || v_count);
    ELSE
        DBMS_OUTPUT.PUT_LINE('No employees found in country ' || p_country_id);
    END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No employees found in country ' || p_country_id);
END;

BEGIN
    country_emp_count('US');
    country_emp_count('ZW'); -- Assume no employees here
END;


--Q5  Insert Employee with Validation
--Write a procedure add_employee that:

--Takes employee details as parameters (first_name, last_name, email, phone_number, 
--hire_date, job_id, salary, department_id)
--Validates that salary is between min_salary and max_salary of the given job.
--Inserts the record into employees.
--Prints "Employee added successfully" or an error message.

CREATE OR REPLACE PROCEDURE add_employee(
    p_first_name   IN hr.employees.first_name%TYPE,
    p_last_name    IN hr.employees.last_name%TYPE,
    p_email        IN hr.employees.email%TYPE,
    p_phone_number IN hr.employees.phone_number%TYPE,
    p_hire_date    IN hr.employees.hire_date%TYPE,
    p_job_id       IN hr.employees.job_id%TYPE,
    p_salary       IN hr.employees.salary%TYPE,
    p_department_id IN hr.employees.department_id%TYPE
) IS
    v_min_salary hr.jobs.min_salary%TYPE;
    v_max_salary hr.jobs.max_salary%TYPE;
BEGIN
    -- 1. Get min and max salary for the given job
    SELECT min_salary, max_salary
    INTO v_min_salary, v_max_salary
    FROM hr.jobs
    WHERE job_id = p_job_id;

    -- 2. Validate salary
    IF p_salary < v_min_salary OR p_salary > v_max_salary THEN
        DBMS_OUTPUT.PUT_LINE('Error: Salary must be between ' ||
                             v_min_salary || ' and ' || v_max_salary ||
                             ' for job ' || p_job_id);
        RETURN;
    END IF;

    -- 3. Insert the employee
    INSERT INTO hr.employees (
        employee_id, first_name, last_name, email,
        phone_number, hire_date, job_id, salary, department_id
    ) VALUES (
        hr.employees_seq.NEXTVAL,  -- Assuming a sequence exists
        p_first_name, p_last_name, p_email,
        p_phone_number, p_hire_date, p_job_id, p_salary, p_department_id
    );

    DBMS_OUTPUT.PUT_LINE('Employee added successfully');

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Job ID ' || p_job_id || ' does not exist.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Unexpected error: ' || SQLERRM);
END;

SET SERVEROUTPUT ON;
BEGIN
    add_employee(
        p_first_name   => 'John',
        p_last_name    => 'Smith',
        p_email        => 'JSMITH',
        p_phone_number => '515.123.4567',
        p_hire_date    => SYSDATE,
        p_job_id       => 'IT_PROG',
        p_salary       => 6000,
        p_department_id => 60
    );
END;

select count(*),employee_id from hr.employees
group by employee_id


--1.Write a procedure to update salary with validation + logging
--Create a procedure update_salary that
--accepts emp_id and hike %
--if hike > 25%  raise custom exception
--update salary
--log old salary, new salary, date into an audit table
--return success or failure message using OUT parameter

select * from employee1 ;
select * from employee1_audit ;

create table employee1_audit(
emp_id number,
old_salary number,
new_salary number,
modify_date date
);

create or replace procedure update_salary(emp_id in number,
                                          hike   in number,
                                          msg    out varchar2) is
  cursor cur is
    select employee_id, salary
      from employee1
     where employee_id = emp_id
       for update;

  v_emp_id employee1.employee_id%type;
  v_salary employee1.salary%type;

  v_updated_sal number;
  sal exception;
begin
  open cur;
  loop
    fetch cur
      into v_emp_id, v_salary;
    exit when cur%notfound;
    if hike > 0.25 then
      raise sal;
    
    else
      v_updated_sal := v_salary + (v_salary * hike);
      update employee1 set salary = v_updated_sal where current of cur;
    
      insert into employee1_audit
        (emp_id, old_salary, new_salary, modify_date)
      values
        (v_emp_id, v_salary, v_updated_sal, sysdate);
    end if;
  
  end loop;
  close cur;
  msg := 'Salary updated successfuly !';
exception
  when sal then
    dbms_output.put_line('Hike must be less than 25% !');
    msg := 'Salary update failed !';
  when others then
    dbms_output.put_line(SQLERRM || dbms_utility.format_error_backtrace);
end;

declare
  d_hike number := 0.26;
  d_msg  varchar2(100);
begin
  update_salary(105, d_hike, d_msg);
  dbms_output.put_line(d_msg);
end;

select salary from employee1 where employee_id = 105 ;

--2.Procedure to return employee details using REF CURSOR
--Write a procedure get_emp_details that:
--accepts department_id
--returns all employees of that department using SYS_REFCURSOR
--handle "No Data Found" and return empty cursor

create or replace procedure get_emp_details(dpt_id  in number,
                                            emp_cur OUT SYS_REFCURSOR) is

begin
  open emp_cur for
    select employee_id, first_name
      from employee1
     where department_id = dpt_id;
  --dbms_output.put_line(employee_id || first_name);
exception
  when NO_DATA_FOUND  then
    dbms_output.put_line('There is no employee with department_id ' ||
                         dpt_id);
  when others then
    dbms_output.put_line(SQLERRM || dbms_utility.format_error_backtrace);
end;

DECLARE
  c      SYS_REFCURSOR;
  v_id   employee1.employee_id%TYPE;
  v_name employee1.first_name%TYPE;
  l_rows number := 0;
BEGIN
  get_emp_details(900, c); -- pass department_id

  LOOP
    FETCH c
      INTO v_id, v_name;
    EXIT WHEN c%NOTFOUND;
    l_rows := l_rows + 1;
  
    DBMS_OUTPUT.PUT_LINE(v_id || ' - ' || v_name);
  END LOOP;
  IF l_rows = 0 THEN
    DBMS_OUTPUT.PUT_LINE('No employees found for department 900');
  END IF;

  CLOSE c;
END;

--3.Procedure to insert data using a loop
--Write a procedure insert_bulk_emp that:
--accepts n rows as input
--inserts n dummy employees using a FOR loop
--returns count of rows inserted using OUT parameter

CREATE OR REPLACE PROCEDURE insert_bulk_emp(
    p_num IN NUMBER,           -- number of employees to insert
    p_count OUT NUMBER         -- returns number of rows inserted
) IS
BEGIN
    p_count := 0;  -- initialize counter
    
    FOR i IN 1 .. p_num LOOP
        INSERT INTO employee(emp_id, emp_name, job_title, salary)
        VALUES (
            employee_seq.NEXTVAL,             -- assuming sequence exists
            'Dummy_Emp_' || i,                -- dummy name
            'Developer',                      -- dummy job
            5000 + i * 100                    -- dummy salary
        );
        p_count := p_count + 1;              -- increment counter
    END LOOP;
    
    COMMIT;  -- commit all inserts
END;
/



--4. Procedure that uses explicit cursor + FETCH
--Write a procedure get_max_salary_emp that:
--fetches employee with highest salary using a cursor
--returns name, salary in OUT parameters
--raise an exception if no employees exist

create or replace procedure get_max_salary_emp(name out varchar2,
                                               sal  out number) is
  cursor c_emp is
    select first_name, salary
      from hr.employees
     where salary = (select max(salary) from hr.employees);
begin
  open c_emp;
  fetch c_emp
    into name, sal;
  if c_emp%notfound then
    close c_emp;
    raise_application_error(-20001,
                            'no employee exist with this employee_id');
  end if;
  close c_emp;
exception

  when others then
    dbms_output.put_line(SQLERRM || SQLCODE);
end;

declare
  v_n   varchar2(100);
  v_sal number;
begin
  get_max_salary_emp(v_n, v_sal);
     dbms_output.put_line(v_n || v_sal);
end;

select * from user_objects where object_name = upper('get_max_salary_emp');


create or replace procedure get_max_salary_emp_with_bulk is
  cursor emp is
    select first_name, salary
      from hr.employees
     where salary = (select max(salary) from hr.employees);

  type c_emp is table of hr.employees.first_name%type;
  type c_sal is table of hr.employees.salary%type; -- with two collection.

  v_emp c_emp;
  v_sal c_sal;
begin
  open emp;
  fetch emp bulk collect
    into v_emp, v_sal;
  close emp;

  if v_emp.COUNT = 0 THEN
    raise_application_error(-20001, 'Employee not found.');
  end if;

  for i in 1 .. v_emp.count loop
    dbms_output.put_line(v_emp(i) || ' ' || v_sal(i));
  end loop;
exception
  when others then
    dbms_output.put_line(SQLERRM || dbms_utility.format_error_stack);
end;

begin
get_max_salary_emp_with_bulk;
end;
--

create or replace procedure get_max_salary_emp_with_bulk_1 is
  cursor emp is
    select first_name, salary
      from hr.employees
     where salary = (select max(salary) from hr.employees);

  type c_emp is table of emp%rowtype;  -- single collection.

  v_emp c_emp;
begin
  open emp;
  fetch emp bulk collect
    into v_emp;
  close emp;

  if v_emp.COUNT = 0 THEN
    raise_application_error(-20001, 'Employee not found.');
  end if;

  for i in 1 .. v_emp.count loop
    dbms_output.put_line(v_emp(i).first_name || ' ' || v_emp(i).salary);
  end loop;
exception
  when others then
    dbms_output.put_line(SQLERRM || dbms_utility.format_error_stack);
end;

begin
get_max_salary_emp_with_bulk_1;
end;

--5. Procedure to check credit limit (real-time banking scenario)
--Create a procedure withdraw_amount:
--accepts cust_id, amount
--check current balance
--if amount > balance  raise insufficient funds
--deduct amount
--commit
--return updated balance

CREATE TABLE bank_accounts (
    cust_id        NUMBER PRIMARY KEY,
    cust_name      VARCHAR2(100),
    balance_amount NUMBER(10,2),
    last_updated   DATE
);

INSERT INTO bank_accounts VALUES (101, 'Rohit Sharma', 50000, SYSDATE);
INSERT INTO bank_accounts VALUES (102, 'Virat Kohli', 25000, SYSDATE);
INSERT INTO bank_accounts VALUES (103, 'MS Dhoni', 100000, SYSDATE);
INSERT INTO bank_accounts VALUES (104, 'Hardik Pandya', 0, SYSDATE);

COMMIT;

select * from bank_accounts ;

create or replace procedure withdraw_amount(c_id      in number,
                                            amount    in number,
                                            v_new_bal out number) is
  v_bal number;
begin
  select balance_amount
    into v_bal
    from bank_accounts
   where cust_id = c_id
     for update;

  if amount > v_bal then
    raise_application_error(-20001, 'insufficient funds.');
  else
    v_new_bal := v_bal - amount;
    update bank_accounts
       set balance_amount = v_new_bal
     where cust_id = c_id;
    dbms_output.put_line('successfully withdraw.');
  end if;

  dbms_output.put_line('updated balance of cust = ' || c_id || ' is ');
  commit;
exception
  WHEN NO_DATA_FOUND THEN
    dbms_output.put_line('Customer does not exist');
  when others then
    rollback;
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;

declare
v_n_bal number ;
begin
  withdraw_amount(101, 50000,v_n_bal);
  dbms_output.put_line(v_n_bal);
end;

select status from user_objects where object_name = upper('withdraw_amount');

--6. Procedure to validate user login
--Create a procedure validate_login:
--accepts username, password
--check if both match
--if wrong  raise custom exception
--if right  return last login time using OUT param
--update login timestamp

CREATE TABLE app_users (
    user_id        NUMBER PRIMARY KEY,
    username       VARCHAR2(50) UNIQUE,
    user_password  VARCHAR2(50),
    last_login     DATE
);

INSERT INTO app_users VALUES (1, 'admin', 'admin123', SYSDATE - 2);
INSERT INTO app_users VALUES (2, 'scott', 'tiger', SYSDATE - 1);

COMMIT;

select * from app_users;

create or replace procedure validate_login(u_name  varchar2,
                                           u_pass  varchar2,
                                           login_t out date) is
  e_invalid_login EXCEPTION;
  v_time date;
  v_pass varchar2(100);
begin
  select last_login, user_password
    into v_time, v_pass
    from app_users
   where username = u_name;
  if u_pass != v_pass then
    raise e_invalid_login;
  else
    login_t := v_time;
    dbms_output.put_line('Login successful :' || login_t);
    update app_users set last_login = sysdate where username = u_name;
  end if;
exception
  when e_invalid_login then
    dbms_output.put_line('something is wrong');
    when NO_DATA_FOUND THEN
      dbms_output.put_line('user not found with that name : '||u_name);
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;
  
declare
  t date ;
begin
  validate_login('scott', 'tiger', t);
end;


select status from user_objects where object_name = upper('get_emp_record');

--7. Procedure to return multiple values using RECORD
--Write a procedure get_emp_record that:
--uses a RECORD type OUT parameter
--returns employee name, salary, job, hiredate
--raise exception if emp_id not found

--way 1st
create or replace procedure get_emp_record(e_id in hr.employees.employee_id%type,
                                           ab   out hr.employees%rowtype) is
begin
  select * into ab from hr.employees where employee_id = e_id;

exception
  when NO_DATA_FOUND then
    dbms_output.put_line('Emloyee not available');
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;


declare
  v_cur hr.employees%rowtype;
begin
  get_emp_record(105,v_cur);
  dbms_output.put_line(v_cur.first_name||' '||v_cur.salary||' '||v_cur.job_id||' '||v_cur.hire_date);
end; 

--way 2nd
--using RECURSOR
create or replace procedure get_emp_record(ab out SYS_REFCURSOR) is
begin
  open ab for
    select first_name, salary, job_id, hire_date from hr.employees;

exception
  when NO_DATA_FOUND then
    dbms_output.put_line('Emloyee not available');
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;

DECLARE
  c SYS_REFCURSOR;
  v_name hr.employees.first_name%TYPE;
  v_sal  hr.employees.salary%TYPE;
  v_job  hr.employees.job_id%TYPE;
  v_hire hr.employees.hire_date%TYPE;
BEGIN
  get_emp_record(c);

  LOOP
    FETCH c INTO v_name, v_sal, v_job, v_hire;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name || ' ' || v_sal);
  END LOOP;

  CLOSE c;
END;



--8. Procedure to archive old data
--Create a procedure archive_orders that:
--moves orders older than 1 year from ORDERS table to ORDERS_ARCHIVE table
--uses BULK COLLECT + FORALL for performance
--returns total archived count
-- Main orders table

CREATE TABLE orders1 (
    order_id NUMBER PRIMARY KEY,
    customer_id NUMBER,
    order_date DATE,
    amount NUMBER
);

-- Archive table
CREATE TABLE orders_archive (
    order_id NUMBER PRIMARY KEY,
    customer_id NUMBER,
    order_date DATE,
    amount NUMBER
);

INSERT INTO orders1 (order_id, customer_id, order_date, amount) VALUES (1, 101, ADD_MONTHS(SYSDATE, -14), 500);
INSERT INTO orders1 (order_id, customer_id, order_date, amount) VALUES (2, 102, ADD_MONTHS(SYSDATE, -10), 1000);
INSERT INTO orders1 (order_id, customer_id, order_date, amount) VALUES (3, 103, ADD_MONTHS(SYSDATE, -18), 750);
INSERT INTO orders1 (order_id, customer_id, order_date, amount) VALUES (4, 104, ADD_MONTHS(SYSDATE, -5), 1200);
INSERT INTO orders1 (order_id, customer_id, order_date, amount) VALUES (5, 105, ADD_MONTHS(SYSDATE, -20), 300);

COMMIT;

select * from orders1 ;
select * from orders_archive ;
--
CREATE OR REPLACE PROCEDURE archive_orders(total_archive out number) IS
  TYPE ord IS TABLE OF orders1%ROWTYPE;
  o_det ord;
BEGIN
  SELECT *
    BULK COLLECT
    INTO o_det
    FROM orders1
   WHERE order_date < ADD_MONTHS(SYSDATE, -12);

if o_det.count > 0  then 
  FORALL i IN o_det.FIRST .. o_det.LAST
    INSERT INTO orders_archive
      (order_id, customer_id, order_date, amount)
      SELECT o_det(i).order_id,
             o_det(i).customer_id,
             o_det(i).order_date,
             o_det(i).amount
        FROM dual
       WHERE NOT EXISTS (SELECT 1
                FROM orders_archive oa
               WHERE oa.order_id = o_det(i).order_id);

  forall i in 1 .. o_det.last
    delete from orders1 where order_id = o_det(i).order_id;
    
    total_archive:= SQL%ROWCOUNT;
    else
      total_archive := 0;
     end if;
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Error Stack: ' ||
                         DBMS_UTILITY.FORMAT_ERROR_STACK || 'Backtrace: ' ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;

declare
  total number;
begin
  archive_orders(total);
  dbms_output.put_line('total archived count is : ' || total);
end;


--A package is a collection of related procedures, functions, variables, cursors, 
--and other PL/SQL constructs grouped together in a single unit.
--**It has two parts:
-- 1. Package Specification (what is available publicly)
-- 2. Package Body (actual code/logic for those procedures/functions)

-- Basic Syntax
-- 1. Package Specification
CREATE OR REPLACE PACKAGE emp_pkg AS
  PROCEDURE add_employee(p_id NUMBER, p_name VARCHAR2, p_salary NUMBER);
  FUNCTION get_total_employees RETURN NUMBER;
END emp_pkg;

-- 2. Package Body
CREATE OR REPLACE PACKAGE BODY emp_pkg AS

  PROCEDURE add_employee(p_id NUMBER, p_name VARCHAR2, p_salary NUMBER) IS
  BEGIN
    INSERT INTO employee (emp_id, name, salary)
    VALUES (p_id, p_name, p_salary);
  END;

  FUNCTION get_total_employees RETURN NUMBER IS
    v_total NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_total FROM employee;
    RETURN v_total;
  END;

END emp_pkg;
-----
-- Example 1: Package for Employee Operations
CREATE OR REPLACE PACKAGE employee_pkg AS
  PROCEDURE raise_salary(p_emp_id NUMBER, p_percent NUMBER);
  FUNCTION get_salary(p_emp_id NUMBER) RETURN NUMBER;
END employee_pkg;
--Package Body:
CREATE OR REPLACE PACKAGE BODY employee_pkg AS

  PROCEDURE raise_salary(p_emp_id NUMBER, p_percent NUMBER) IS
  BEGIN
    UPDATE employee
    SET salary = salary + (salary * p_percent / 100)
    WHERE emp_id = p_emp_id;
  END;

  FUNCTION get_salary(p_emp_id NUMBER) RETURN NUMBER IS
    v_salary NUMBER;
  BEGIN
    SELECT salary INTO v_salary
    FROM employee
    WHERE emp_id = p_emp_id;
    RETURN v_salary;
  END;

END employee_pkg;
--Call from SQL*Plus or PL/SQL:
BEGIN
  employee_pkg.raise_salary(107, 10);
  DBMS_OUTPUT.PUT_LINE('New Salary: ' || employee_pkg.get_salary(107));
END;

-- Example 2: Package with Global Variable
CREATE OR REPLACE PACKAGE session_pkg AS
  g_user_name VARCHAR2(100); -- Global variable
  PROCEDURE set_user(p_name VARCHAR2); 
  PROCEDURE show_user;
END session_pkg;

CREATE OR REPLACE PACKAGE BODY session_pkg AS

  PROCEDURE set_user(p_name VARCHAR2) IS
  BEGIN
    g_user_name := p_name;
  END;

  PROCEDURE show_user IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Current User: ' || g_user_name);
  END;

END session_pkg;

BEGIN
  session_pkg.set_user('Shubham');
  session_pkg.show_user;
END;

--Practice
-- Q1: Math Utility Package
--Create a package math_utils_pkg with:
--A function square(p_number NUMBER) RETURN NUMBER
--A function cube(p_number NUMBER) RETURN NUMBER
--A procedure show_result(p_number NUMBER) that prints both square and cube

create or replace package math_utils_pkg as
  function square(p_number number) return number;
  function cube1(p_number number) return number;
  procedure show_result(p_number number);
  v_num  number;
  v_num1 number;
end;

create or replace package body math_utils_pkg as
function square(p_number number) return number is
begin
-- v_num := p_number * p_number;
return p_number * p_number;
end;

function cube1(p_number number) return number is
begin
--v_num1 := p_number * p_number * p_number;
return p_number * p_number * p_number;
end;

procedure show_result(p_number number) is
square1 number; cube11 number;
begin
square1 := square(p_number); cube11 := cube1(p_number);

dbms_output.put_line('Square : ' || square1); dbms_output.put_line('Cube : ' || cube11);
end;
end math_utils_pkg;

begin
math_utils_pkg.show_result(5);
end;

----06-06-2025  Friday-----------------------------------------------------------------------------------

CREATE TABLE student1 (
  rollno NUMBER PRIMARY KEY,
  name   VARCHAR2(50),
  marks  NUMBER
);

select * from student1;

--Create a package student_pkg with:
--A procedure add_student(p_id NUMBER, p_name VARCHAR2, p_marks NUMBER)
--A function get_grade(p_id NUMBER) RETURN VARCHAR2
--(Return A/B/C based on marks: A  75, B  50, C otherwise)

create or replace package student_pkg as
procedure  add_student (p_id NUMBER, p_name VARCHAR2, p_marks NUMBER) ;
function  get_grade (p_id NUMBER) RETURN VARCHAR2 ;
end ;

create or replace package body student_pkg as
  procedure add_student(p_id NUMBER, p_name VARCHAR2, p_marks NUMBER) is
  begin
    insert into student1
      (rollno, name, marks)
    values
      (p_id, p_name, p_marks);
  end;

  function get_grade(p_id NUMBER) RETURN VARCHAR2 is
    v_grade varchar2(1);
    v_marks number;
  begin
    select marks into v_marks from student1 where rollno = p_id;
    if v_marks >= 75 then
      v_grade := 'A';
    elsif v_marks >= 50 then
      v_grade := 'B';
    else
      v_grade := 'C';
    end if;
    return v_grade;
  end;

end student_pkg;

begin
  student_pkg.add_student(101, 'Ravi', 95);
  dbms_output.put_line(student_pkg.get_grade(101));
end;


--     Q3: Global Counter Package
--Create a package counter_pkg with:
--A global variable g_counter (initial value 0)
--A procedure increment_counter
--A procedure reset_counter
--A function get_counter RETURN NUMBER

create or replace package counter_pkg as
  -- g_counter number := 0;
  procedure increment_counter;
  procedure reset_counter;
  function get_counter RETURN NUMBER;
end;

 create or replace package body counter_pkg as
   g_counter number := 0;

   procedure increment_counter is
     v_count number := 1;
   begin
     g_counter := g_counter + v_count;
     dbms_output.put_line('Counter increment : ' || g_counter);
   end;
 
   procedure reset_counter is
   begin
     g_counter := 0;
     dbms_output.put_line('Counter reset : ' || g_counter);
   end;
 
   function get_counter return number is
   begin
     return g_counter;
   end;
 end counter_pkg;

begin
  counter_pkg.increment_counter;
  counter_pkg.increment_counter;
  dbms_output.put_line('current counter : ' || counter_pkg.get_counter);
  counter_pkg.reset_counter;
  dbms_output.put_line('After reset : ' || counter_pkg.get_counter);
end;

--     Q4: Salary Validation Package
--Given this table:
CREATE TABLE employe1 (
    emp_id   NUMBER PRIMARY KEY,
    name     VARCHAR2(50),
    salary   NUMBER
);
INSERT INTO employe1 (emp_id, name, salary) VALUES (101, 'Shubham', 50000);
INSERT INTO employe1 (emp_id, name, salary) VALUES (102, 'Nikita', 60000);
INSERT INTO employe1 (emp_id, name, salary) VALUES (103, 'Rohan', 45000);
INSERT INTO employe1 (emp_id, name, salary) VALUES (104, 'Priya', 70000);
INSERT INTO employe1 (emp_id, name, salary) VALUES (105, 'Amit', 55000);
--Create a package salary_pkg with:
--A procedure update_salary(p_id NUMBER, p_new_salary NUMBER)
--Raise error if new salary < 10000
--A function get_salary(p_id NUMBER) RETURN NUMBER

create or replace package salary_pkg as
procedure update_salary(p_id NUMBER, p_new_salary NUMBER);
function get_salary(p_id NUMBER) RETURN NUMBER ;
end;

create or replace package body salary_pkg as
  procedure update_salary(p_id NUMBER, p_new_salary NUMBER) is
  begin
    if p_new_salary < 10000 then
      RAISE_APPLICATION_ERROR(-20001, 'Salary must be at least 10000');
    --  DBMS_OUTPUT.PUT_LINE('p_new_salary < 10000 not allowed ' || p_id);
    end if;
    update employe1 set salary = p_new_salary where emp_id = p_id; 
        DBMS_OUTPUT.PUT_LINE('Salary updated for emp_id ' || p_id);

  end;

  function get_salary(p_id NUMBER) RETURN NUMBER is
    v_sal number;
  begin
    select salary into v_sal from employe1 where emp_id = p_id;
    return v_sal;
  end;
end salary_pkg;
      
begin
  salary_pkg.update_salary(101, 9000);
  dbms_output.put_line('current salary is : ' || salary_pkg.get_salary(101) );
end;

select * from employe1 where emp_id = 101 ;



-- Q5: Bank Account Package
Given this table:
CREATE TABLE account (
    acc_no   NUMBER PRIMARY KEY,
    name     VARCHAR2(50),
    balance  NUMBER
);

--Create a package bank_pkg with:
--A procedure deposit(p_acc_no NUMBER, p_amount NUMBER)
--A procedure withdraw(p_acc_no NUMBER, p_amount NUMBER)
--Raise error if withdrawal amount > balance
--A function get_balance(p_acc_no NUMBER) RETURN NUMBER

create or replace package bank_pkg as 
procedure deposit(p_acc_no NUMBER, p_amount NUMBER) ;
 procedure withdraw(p_acc_no NUMBER, p_amount NUMBER);
function get_balance(p_acc_no NUMBER) RETURN NUMBER;
end;

create or replace package body bank_pkg is

  procedure deposit(p_acc_no NUMBER, p_amount NUMBER) is
    v_balance number;
    v_total number := 0 ;
  begin
    select balance into v_balance from account where acc_no = p_acc_no;
    update account
       set balance = balance + p_amount
     where acc_no = p_acc_no;
     v_total := v_balance + p_amount ;
    dbms_output.put_line('Blance succesfully updated : ' || v_total);
  end;

  procedure withdraw(p_acc_no NUMBER, p_amount NUMBER) is
    -- v_with number ;
    v_bal number;
  begin
    select balance into v_bal from account where acc_no = p_acc_no;
    if p_amount > v_bal then
      RAISE_APPLICATION_ERROR(-20001, 'Amount must be less than balance');
      --dbms_output.put_line('Amount should be less that current balance');
    else
      --v_bal < p_amount then --v_with := v_bal - p_amount ;
      update account
         set balance = balance - p_amount
       where acc_no = p_acc_no;
      dbms_output.put_line('Balance sucessfully withdraw : ' || p_amount);
    
    end if;
  end;

  function get_balance(p_acc_no NUMBER) RETURN NUMBER is
    v_balance number;
  begin
    select balance into v_balance from account where acc_no = p_acc_no;
    return v_balance;
  end;
end bank_pkg;

begin
  bank_pkg.deposit(201,10000) ;
  bank_pkg.withdraw(201,15000);
  dbms_output.put_line('Current balance is : ' || bank_pkg.get_balance(201));
end;

select balance from account where acc_no = 201;


CREATE OR REPLACE PACKAGE pkg_employee AS
    PROCEDURE add_employee(p_emp_id NUMBER, p_name VARCHAR2, p_salary NUMBER);
    PROCEDURE update_salary(p_emp_id NUMBER, p_new_salary NUMBER);
    PROCEDURE get_employee_details(p_emp_id NUMBER);
END pkg_employee;
/
 
CREATE OR REPLACE PACKAGE BODY pkg_employee AS
 
    -- Procedure to add a new employee
    PROCEDURE add_employee(p_emp_id NUMBER, p_name VARCHAR2, p_salary NUMBER) IS
    BEGIN
        INSERT INTO employees (employee_id, first_name, salary) VALUES (p_emp_id, p_name, p_salary);
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Employee added successfully.');
    END add_employee;
 
    -- Procedure to update employee salary
    PROCEDURE update_salary(p_emp_id NUMBER, p_new_salary NUMBER) IS
    BEGIN
        UPDATE employees SET salary = 120/0 WHERE employee_id = p_emp_id;
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Salary updated successfully.');
        exception when others
        then 
        DBMS_OUTPUT.PUT_LINE('Err:-'||dbms_utility.format_error_stack||
            dbms_utility.format_error_backtrace);
    END update_salary;
 
    -- Procedure to fetch employee details
    PROCEDURE get_employee_details(p_emp_id NUMBER) IS
        v_name employees.first_name%TYPE;
        v_salary employees.salary%TYPE;
    BEGIN
        SELECT first_name, salary INTO v_name, v_salary FROM employees WHERE employee_id = p_emp_id;
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name || ', Salary: ' || v_salary);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No employee found with ID ' || p_emp_id);
    END get_employee_details;
 
END pkg_employee;
/
 
CREATE OR REPLACE PACKAGE pkg_salary_manager AS
    PROCEDURE increase_salary(p_emp_id NUMBER, p_increment NUMBER);
END pkg_salary_manager;
/
 
CREATE OR REPLACE PACKAGE BODY pkg_salary_manager AS
 
    PROCEDURE increase_salary(p_emp_id NUMBER, p_increment NUMBER) IS
        v_current_salary employees.salary%TYPE;
    BEGIN
        -- Fetch current salary
        SELECT salary INTO v_current_salary FROM employees WHERE employee_id = p_emp_id;
 
        -- Increase salary
        pkg_employee.update_salary(p_emp_id, v_current_salary + p_increment);
        DBMS_OUTPUT.PUT_LINE('Salary increased successfully.');
    EXCEPTION
        WHEN others THEN
            DBMS_OUTPUT.PUT_LINE('Err:-'||dbms_utility.format_error_stack||
            dbms_utility.format_error_backtrace);
    END increase_salary;
 
END pkg_salary_manager;
/
 
 
BEGIN
    --pkg_employee.add_employee(101, 'John Doe', 50000);
    pkg_salary_manager.increase_salary(110, 5000);
    --pkg_employee.get_employee_details(101);
END;


-- 1. Package Example: Audit Utility Package
CREATE OR REPLACE PACKAGE audit_pkg IS
  PROCEDURE log_event(p_msg VARCHAR2);
END;
/

CREATE OR REPLACE PACKAGE BODY audit_pkg IS
  PROCEDURE log_event(p_msg VARCHAR2) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO event_log(msg, log_time) VALUES (p_msg, SYSDATE);
    COMMIT;
  END;
END;

-- 2. Package Example: Tracking Access from UI
CREATE OR REPLACE PACKAGE user_track_pkg IS
  PROCEDURE record_access(p_user VARCHAR2);
END;
/

CREATE OR REPLACE PACKAGE BODY user_track_pkg IS
  PROCEDURE record_access(p_user VARCHAR2) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO user_access_log(username, access_time)
    VALUES (p_user, SYSDATE);
    COMMIT;
  END;
END;


--PRAGMA SERIALLY_REUSABLE

1-scenario
You want to reduce memory usage for frequently called packages.

--Use for global variables that dont need to retain state between calls (especially in high-load systems).

create or replace package pkg_test is
  pragma serially_reusable;
  procedure p1;
end;

create or replace package body pkg_test is
  pragma serially_reusable;
  g_counter number := 0;

  procedure p1 is
  begin
    g_counter := g_counter + 1;
    dbms_output.put_line('Counter : ' || g_counter);
  exception
    when others then
      dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                           DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  end;
end ;

select * from user_objects where object_name = upper('memory_test_package') ;

begin
  pkg_test.p1;
  pkg_test.p1;
  pkg_test.p1;
end;

begin
  pkg_test.p1;
end ;

begin
  pkg_test.p1;
end ;

-- Example 2: Shared Package State  Reset Happens on Each Call

create or replace package sharde_pkg is
  pragma serially_reusable;
  v_data varchar2(100);
  procedure p1(v_val varchar2);
  procedure p2;
end;

create or replace package body sharde_pkg is
  pragma serially_reusable;

  procedure p1(v_val varchar2) is
  begin
    v_data := v_val;
  end;

  procedure p2 is
  begin
    dbms_output.put_line(v_data);
  end;
end;

BEGIN
  sharde_pkg.p1('ABC');
  sharde_pkg.p2;
  -- Will print: Data:
  -- Because g_data resets on next call
END;

begin
  sharde_pkg.p2;
end;

-- Example 3: Save Memory When Handling Bulk Data

select * from user_objects where object_name = upper('memory_test_package') ;

CREATE OR REPLACE PACKAGE memory_test_pkg IS
  PRAGMA SERIALLY_REUSABLE;
  TYPE arr IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  g_arr arr;
  PROCEDURE load_data;
  PROCEDURE print_data;
END;
/

CREATE OR REPLACE PACKAGE BODY memory_test_pkg IS
  PRAGMA SERIALLY_REUSABLE;

  PROCEDURE load_data IS
  BEGIN
    FOR i IN 1..1000 LOOP
      g_arr(i) := i * 2;
    END LOOP;
  END;

  PROCEDURE print_data IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('g_arr(10) = ' || g_arr(10)); -- Likely NULL
  END;
END;

BEGIN
  memory_test_pkg.load_data;
  memory_test_pkg.print_data;
END;
/

-- First call
BEGIN
  memory_test_pkg.load_data;
END;
/

-- Second call
BEGIN
  memory_test_pkg.print_data; -- Will likely raise NO_DATA_FOUND or show NULL
END;


--Q1. Employee Salary Audit Package
--Create a package pkg_salary_audit for the employees table that:
--Specification Requirements:
--Procedure update_salary(p_emp_id, p_new_salary)
--Update employee salary.
--Validate: new salary must be greater than old salary.
--If invalid  raise custom exception.
--Procedure get_salary_history(p_emp_id)
--Display all old salary changes from an audit table.
--Function get_total_hikes(p_emp_id)
--Return number of salary hikes done so far.
--Additional Conditions:
--Maintain an audit table emp_salary_audit with:
--emp_id, old_salary, new_salary, changed_by, changed_on
--Use PRAGMA AUTONOMOUS_TRANSACTION in the audit-insert part.

create table emp_salary_audit(
emp_id number ,
old_salary number,
new_salary number,
changed_by varchar2(80),
changed_on date
);

select * from emp_salary_audit ;


create or replace package pkg_salary_audit is

  procedure update_salary(p_emp_id number, p_new_salary number);
  Procedure get_salary_history(p_emp_id number);
  Function get_total_hikes(p_emp_id number) return number;
end pkg_salary_audit;

create or replace package body pkg_salary_audit is
  PROCEDURE log_audit(p_emp_id NUMBER, p_old_sal NUMBER, p_new_sal NUMBER) IS
    PRAGMA AUTONOMOUS_TRANSACTION; 
  BEGIN
    INSERT INTO emp_salary_audit
      (emp_id, old_salary, new_salary, changed_by, changed_on)
    VALUES
      (p_emp_id, p_old_sal, p_new_sal, USER, SYSDATE);
  
    COMMIT; 
  END log_audit;

  procedure update_salary(p_emp_id number, p_new_salary number) is
    v_old_sal number;
    sal_not_greater EXCEPTION;
  begin
    select salary
      into v_old_sal
      from employee1
     where employee_id = p_emp_id;
    if p_new_salary < v_old_sal then
      raise sal_not_greater;
    end if;
  
    update employee1
       set salary = p_new_salary
     where employee_id = p_emp_id;
    dbms_output.put_line('Salary successfully updated !');
  
    log_audit(p_emp_id, v_old_sal, p_new_salary);
     
    commit;
    
  exception
    when sal_not_greater then
      dbms_output.put_line('Salary must be greater that old salary \n and old salary is: ' ||
                           v_old_sal || ' Ans new salary is: ' ||
                           p_new_salary);
    when others then
      dbms_output.put_line(SQLERRM || dbms_utility.format_error_backtrace);
  end;

  Procedure get_salary_history(p_emp_id number) is
    cursor cur is
      select emp_id, old_salary, new_salary, changed_by, changed_on
        from emp_salary_audit
       where emp_id = p_emp_id;
  
    v_emp_id     number;
    v_old_salary number;
    v_new_salary number;
    v_changed_by varchar2(90);
    v_changed_on date;
  
  begin
    open cur;
    loop
      fetch cur
        into v_emp_id,
             v_old_salary,
             v_new_salary,
             v_changed_by,
             v_changed_on;
      exit when cur%notfound;
      dbms_output.put_line('emp_id: ' || v_emp_id || ' old_sal: ' ||
                           v_old_salary || ' New_sal: ' || v_new_salary ||
                           ' Who_changes: ' || v_changed_by ||
                           ' Which_time: ' || TO_CHAR(v_changed_on, 'DD-MON-YYYY HH24:MI:SS'));
    
    end loop;
    close cur;
  exception
    when others then
      dbms_output.put_line(SQLERRM || dbms_utility.format_error_backtrace);
  end;

  FUNCTION get_total_hikes(p_emp_id NUMBER) RETURN NUMBER IS
    v_count NUMBER;
  BEGIN
    SELECT COUNT(*)
      INTO v_count
      FROM emp_salary_audit
     WHERE emp_id = p_emp_id;
  
    RETURN v_count;
  
  exception
    when others then
    
      dbms_output.put_line(SQLERRM || dbms_utility.format_error_backtrace);
      return 0;
  END get_total_hikes;
end pkg_salary_audit;

--  Calling package

DECLARE
    v_hikes NUMBER;
BEGIN
    pkg_salary_audit.update_salary(102, 55002);

    pkg_salary_audit.get_salary_history(102);

    v_hikes := pkg_salary_audit.get_total_hikes(101);
    DBMS_OUTPUT.PUT_LINE('Total salary hikes: ' || v_hikes);
END;

DECLARE
  v_hikes NUMBER;
begin
  v_hikes := pkg_salary_audit.get_total_hikes(102);
  DBMS_OUTPUT.PUT_LINE('Total salary hikes: ' || v_hikes);
END;


--Write a function to check if a number is prime (return 'YES' or 'NO').

CREATE OR REPLACE FUNCTION f_check_prime_num(f_num NUMBER)
RETURN VARCHAR2
IS
  i NUMBER := 2;
BEGIN
  -- Handle numbers <= 1
  IF f_num <= 1 THEN
    RETURN 'NO';
  END IF;

  -- Loop from 2 to sqrt(f_num) to check divisibility
  WHILE i <= TRUNC(SQRT(f_num)) LOOP
    IF MOD(f_num, i) = 0 THEN
      RETURN 'NO'; -- Not prime
    END IF;
    i := i + 1;
  END LOOP;

  RETURN 'YES'; -- Prime
END;


DECLARE
  v_num    NUMBER := &num;
  v_result VARCHAR2(10);
BEGIN
  v_result := f_check_prime_num(v_num);
  DBMS_OUTPUT.PUT_LINE('Is ' || v_num || ' prime?  ' || v_result);
END;


--Create a function get_age(dob DATE) that returns employees age.

create or replace function get_age(dob date) return number is
  age number;
begin
    age := TRUNC(MONTHS_BETWEEN(SYSDATE, dob) / 12);
  --age := trunc(age/30)/12 ;
  return age;
end;

declare
  v_age  date := to_date('03-07-2003', 'DD-MM-YYYY');
  result number;
begin
  result := get_age(v_age);
  dbms_output.put_line('Employee Age is : ' || result || ' Years');
end;


--Create a function to return the grade of student based on marks.

create or replace function s_grade(v_marks number) return varchar2 is
begin
  if v_marks > 100 or v_marks < 0 then
    raise_application_error(-20001, 'Marks shoulb be between 1 to 100 ');
  end if;

  if v_marks >= 90 then
    return 'A';
  elsif v_marks >= 80 then
    return 'B';
  elsif v_marks >= 60 then
    return 'C';
  elsif v_marks >= 40 then
    return 'D';
  else
    return 'F';
  end if;
end;

declare
  get_marks number := &num;
  output    varchar2(20);
begin
  output := s_grade(get_marks);
  dbms_output.put_line('Student marks is ' || get_marks ||
                       ' and grade is ' || output);
end;


--Create a deterministic function that returns square of a number.                                      

create or replace function square_number(f_num number) return number
  DETERMINISTIC is
begin
  return f_num * f_num;
end;
                                 
declare
 v_num  number := &num;
 result number;
begin
 result := square_number(v_num);
 dbms_output.put_line('Square root of '||v_num || ' is ' || result);
end;
                                       
-- Define a table function that returns a table of employee records
CREATE OR REPLACE FUNCTION get_employee_records  
RETURN SYS_REFCURSOR  
IS  
    v_cursor SYS_REFCURSOR;  
BEGIN  
    OPEN v_cursor FOR  
    SELECT employee_id, salary FROM hr.employees WHERE salary > 50000;  
    RETURN v_cursor;  
END get_employee_records;  
/



DECLARE
    v_cursor SYS_REFCURSOR;
    v_emp_id NUMBER;
    v_salary NUMBER;
BEGIN
    v_cursor := get_employee_records;
    LOOP
        FETCH v_cursor INTO v_emp_id, v_salary;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_id || ', Salary: ' || v_salary);
    END LOOP;
    CLOSE v_cursor;
END;
/


--Functions that return a record consisting of multiple fields.

-- Define a record type
CREATE OR REPLACE TYPE emp_record AS OBJECT (
    empno NUMBER,
    ename VARCHAR2(50),
    salary NUMBER
);
/

-- Define the function that returns a record
CREATE OR REPLACE FUNCTION get_employee_details (p_emp_id NUMBER)  
RETURN emp_record  
IS  
    v_emp emp_record;  
BEGIN  
    SELECT employee_id, first_name, salary  
    INTO v_emp.empno, v_emp.ename, v_emp.salary  
    FROM hr.employees  
    WHERE employee_id = p_emp_id;  
    RETURN v_emp;  
END get_employee_details;  
/


DECLARE
    v_emp emp_record;
BEGIN
    v_emp := get_employee_details(101);
    DBMS_OUTPUT.PUT_LINE('Emp No: ' || v_emp.empno || ', Name: ' || v_emp.ename || ', Salary: ' || v_emp.salary);
END;                    


--Q1. Function With Validation + Defaulting + Exception Handling
--Write a function calc_bonus(emp_id) that:
--Fetches salary of employee
--If salary < 20,000  return 10% bonus
--If salary between 20,00050,000  return 15% bonus
--If salary > 50,000  return 20% bonus
--If employee does not exist  return 0 (instead of raising error)
--If salary is NULL or negative  return -1

create or replace function calc_bonus(emp_id number) return number is
  v_salary number;
begin
  select salary into v_salary from employee1 where employee_id = emp_id;
  IF v_salary IS NULL OR v_salary < 0 THEN
    RETURN - 1;
  END IF;

  if v_salary < 20000 then
    return v_salary * 0.10;
  elsif v_salary between 20000 and 50000 then
    return v_salary * 0.15;
  else
    return v_salary * 0.20;
  end if;

exception
  when NO_DATA_FOUND then
    return 0;
  when others then
    dbms_output.put_line(SQLERRM || dbms_utility.format_error_backtrace);
    return - 1;
end;

declare
  emp_id number := &_num;
  result number;
begin
  result := calc_bonus(emp_id);
  dbms_output.put_line('Bonus : ' || result);
end;
            

--Q2. Function Returning Multiple Values With RECORD Type
--Create a function that:
--Accepts employee_id
--Returns a custom RECORD containing
--name, salary, hire_date, job_id
--Use %ROWTYPE or user-defined TYPE
--Display result inside an anonymous block

create or replace package emp_pac is
  TYPE emp_rec_type IS RECORD(
    emp_name VARCHAR2(100),
    sal      NUMBER,
    hire     DATE,
    job      VARCHAR2(20));

  FUNCTION get_emp_details(p_emp_id NUMBER) RETURN emp_rec_type;
END emp_pac;

create or replace package body emp_pac is
  function get_emp_details(p_emp_id number)
    return emp_rec_type is v_rec emp_rec_type;
  begin
    SELECT first_name || ' ' || last_name, salary, hire_date, job_id
      INTO v_rec
      FROM employee1
     WHERE employee_id = p_emp_id;
  
    RETURN v_rec;
  exception
    when others then
      v_rec.emp_name := 'Not Found';
      v_rec.sal      := NULL;
      v_rec.hire     := NULL;
      v_rec.job      := NULL;
      return v_rec;
  end get_emp_details;
end emp_pac;

DECLARE
    v_result emp_pac.emp_rec_type;
BEGIN
    v_result := emp_pac.get_emp_details(101);

    DBMS_OUTPUT.PUT_LINE('Name: ' || v_result.emp_name);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_result.sal);
    DBMS_OUTPUT.PUT_LINE('Hire Date: ' || v_result.hire);
    DBMS_OUTPUT.PUT_LINE('Job ID: ' || v_result.job);
END;



--Fetch all employee salaries and print them.
CREATE OR REPLACE PROCEDURE show_salaries IS
  TYPE t_sal IS TABLE OF employee1.salary%TYPE;
  v_sals t_sal;
BEGIN
  SELECT salary
  BULK COLLECT INTO v_sals
  FROM employee1;

  FOR i IN 1 .. v_sals.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE(v_sals(i));
  END LOOP;
END;

begin
  show_salaries;
end;


--Fetch full employee rows and print name + salary.
CREATE OR REPLACE PROCEDURE show_emp IS
  TYPE t_emp IS TABLE OF employee1%ROWTYPE;
  v_emp t_emp;
BEGIN
  SELECT *
  BULK COLLECT INTO v_emp
  FROM employee1;

  FOR i IN v_emp.FIRST .. v_emp.LAST LOOP
    DBMS_OUTPUT.PUT_LINE(
      v_emp(i).first_name || '_' || v_emp(i).last_name || ' - ' || v_emp(i).salary
    );
  END LOOP;
END;

begin
  show_emp;
end;


--Fetch employees of a given department.
CREATE OR REPLACE PROCEDURE emp_by_dept(p_dept NUMBER) IS
  TYPE t_emp IS TABLE OF employee1%ROWTYPE;
  v_emp t_emp;
BEGIN
  SELECT *
  BULK COLLECT INTO v_emp
  FROM employee1
  WHERE department_id = p_dept;

  DBMS_OUTPUT.PUT_LINE('Count: ' || v_emp.COUNT);
END;

begin
 emp_by_dept(20);
end;


--Process employees in batches of 10.
CREATE OR REPLACE PROCEDURE bulk_limit IS
  CURSOR c_emp IS SELECT * FROM employee1;
  TYPE t_emp IS TABLE OF c_emp%ROWTYPE;
  v_emp t_emp;
BEGIN
  OPEN c_emp;
  LOOP
    FETCH c_emp BULK COLLECT INTO v_emp LIMIT 10;
    EXIT WHEN v_emp.COUNT = 0;

    FOR i IN 1 .. v_emp.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE(v_emp(i).employee_id);
    END LOOP;
  END LOOP;
  CLOSE c_emp;
END;

begin
 bulk_limit;
end;


--Increase salary for dept 10 employees.
CREATE OR REPLACE PROCEDURE bulk_update IS
  TYPE t_id IS TABLE OF employee1.employee_id%TYPE;
  v_ids t_id;
BEGIN
  SELECT employee_id
  BULK COLLECT INTO v_ids
  FROM employee1
  WHERE department_id = 10;

  FORALL i IN v_ids.FIRST .. v_ids.LAST
    UPDATE employee1
    SET salary = salary + 1000
    WHERE employee_id = v_ids(i);
END;

begin
  bulk_update;
end;


--Return count of high-paid employees.
CREATE OR REPLACE FUNCTION high_paid_cnt
RETURN NUMBER IS
  TYPE t_sal IS TABLE OF employee1.salary%TYPE;
  v_sal t_sal;
BEGIN
  SELECT salary
  BULK COLLECT INTO v_sal
  FROM employee1
  WHERE salary > 50000;

  RETURN v_sal.COUNT;
END;

declare
  result number;
begin
  result := high_paid_cnt;
  dbms_output.put_line(result);
end;


--Fetch emp_id, salary, dept_id into separate collections, process salary hike differently per dept.
CREATE OR REPLACE PROCEDURE bulk_parallel IS
  TYPE t_id   IS TABLE OF employees.emp_id%TYPE;
  TYPE t_sal  IS TABLE OF employees.salary%TYPE;
  TYPE t_dept IS TABLE OF employees.dept_id%TYPE;

  v_ids   t_id;
  v_sals  t_sal;
  v_depts t_dept;
BEGIN
  SELECT emp_id, salary, dept_id
  BULK COLLECT INTO v_ids, v_sals, v_depts
  FROM employees;

  FOR i IN 1 .. v_ids.COUNT LOOP
    IF v_depts(i) = 10 THEN
      v_sals(i) := v_sals(i) * 1.2;
    ELSE
      v_sals(i) := v_sals(i) * 1.1;
    END IF;
  END LOOP;

  FORALL i IN 1 .. v_ids.COUNT
    UPDATE employees
    SET salary = v_sals(i)
    WHERE emp_id = v_ids(i);
END;


--Declare a nested table collection to store employee_id of all employees from EMPLOYEES table and display them.

declare
  type ab is record(
    V_id   hr.employees.employee_id%type,
    v_name hr.employees.first_name%type);
  type abis is table of ab;
  v_emp abis;
begin
  select employee_id, first_name bulk collect into v_emp from hr.employees;
  for i in v_emp.first .. v_emp.last loop
    dbms_output.put_line('Details : ' || v_emp(i).v_name || ' ' || v_emp(i).v_id);
  end loop;
end;

declare
  type emp_row is record(
    v_empid hr.employees.employee_id%type,
    v_fname hr.employees.first_name%type);

  type emp_tab is table of emp_row;
  v_emp emp_tab := emp_tab();
begin
  for i in (select employee_id, first_name from hr.employees) loop
    v_emp.extend;
    v_emp(v_emp.count).v_empid := i.employee_id;
    v_emp(v_emp.count).v_fname := i.first_name;
  end loop;

  for i in 1 .. v_emp.count loop
    dbms_output.put_line('employee_id: ' || v_emp(i).v_empid ||
                         ', first_name: ' || v_emp(i).v_fname);
  end loop;
end;


--Use a VARRAY to store first 5 first_name values from EMPLOYEES table and print them.

declare
  type varrayy is varray(10) of varchar2(100);
  v_name varrayy;
begin
  select first_name
    bulk collect
    into v_name
    from hr.employees
   where rownum <= 11;

  for i in 1 .. v_name.last loop
    dbms_output.put_line(v_name(i));
  end loop;
end;


--Declare an associative array to store employee_id and salary and display employees earning more than 10000.

declare
  type emp is table of hr.employees.employee_id%type index by PLS_INTEGER;
  type f_name is table of hr.employees.salary%type index by PLS_INTEGER;

  v_emp emp;
  v_sal f_name;
begin
  select employee_id, salary
    bulk collect
    into v_emp, v_sal
    from hr.employees
    where salary > 10000;

  for i in 1 .. v_emp.last loop
    dbms_output.put_line('id :' || v_emp(i) || ' Name :' || v_sal(i));
  end loop;
end;

declare
  type emp is table of hr.employees.employee_id%type index by PLS_INTEGER;
  type f_sal is table of hr.employees.salary%type index by PLS_INTEGER;
  type f_name is table of hr.employees.first_name%type index by PLS_INTEGER;

  v_emp emp;
  v_sal f_sal;
  v_name f_name;
begin
  select employee_id, salary, first_name
    bulk collect
    into v_emp, v_sal,v_name
    from hr.employees
    where salary > 10000;

  for i in 1 .. v_emp.last loop
    dbms_output.put_line('id :' || v_emp(i) || ' Name :' || v_name(i)||' Sal:'||v_sal(i));
  end loop;
end;


declare
  type emp is table of hr.employees.employee_id%type index by PLS_INTEGER;
  type f_sal is table of hr.employees.salary%type index by PLS_INTEGER;
  type f_name is table of hr.employees.first_name%type index by varchar2(900); -- not allowed with buli collect

  v_emp emp;
  v_sal f_sal;
  v_name f_name;
begin
  select employee_id, salary, first_name
    bulk collect
    into v_emp, v_sal,v_name
    from hr.employees
    where salary > 10000;

  for i in 1 .. v_emp.last loop
    dbms_output.put_line('id :' || v_emp(i) || ' Name :' || v_name(i)||' Sal:'||v_sal(i));
  end loop;
  exception
    when others then
      dbms_output.put_line(SQLERRM || SQLCODE);
end;

--Fetch all department_id values into a collection and display distinct department ids.

declare
  type abis is table of hr.employees.department_id%type;
  v_emp abis;
begin
  select distinct department_id bulk collect into v_emp from hr.employees order by department_id nulls last;
  for i in v_emp.first .. v_emp.last loop
    dbms_output.put_line('Details : ' || v_emp(i));
  end loop;
end;

--Create a weak ref cursor to fetch and display all records from DEPARTMENTS table.

declare
  type emp is ref cursor;  ---Weak
  v_dpt  emp;
  v_dept hr.departments%rowtype;
begin
  open v_dpt for
    select * from hr.departments;

  loop
    fetch v_dpt
      into v_dept;
    exit when v_dpt%notfound;
  
    dbms_output.put_line(v_dept.department_id || ' ' ||
                         v_dept.department_name);
  end loop;
  close v_dpt;
end;


declare
  type emp is ref cursor return hr.departments%rowtype; --strong
  v_dpt  emp;
  v_dept hr.departments%rowtype;
begin
  open v_dpt for
    select * from hr.departments;

  loop
    fetch v_dpt
      into v_dept;
    exit when v_dpt%notfound;
  
    dbms_output.put_line(v_dept.department_id || ' ' ||
                         v_dept.department_name);
  end loop;
  close v_dpt;
end;




--Write a PL/SQL block using a ref cursor to display employee_id and first_name for employees working in department 50.

declare
  type emp is ref cursor;  ---Weak
  v_dpt  emp;
  v_dept hr.employees%rowtype;
begin
  open v_dpt for
    select * from hr.employees where department_id = 50;

  loop
    fetch v_dpt
      into v_dept;
    exit when v_dpt%notfound;
  
    dbms_output.put_line(v_dept.employee_id || ' ' ||
                         v_dept.first_name);
  end loop;
  close v_dpt;
end;

declare
  type r is record(
    r_rmp  hr.employees.employee_id%type,
    r_name hr.employees.first_name%type);
  type emp is ref cursor return r; ---Strong
  v_dpt  emp;
  v_dept r;
begin
  open v_dpt for
    select employee_id,first_name from hr.employees where department_id = 50;

  loop
    fetch v_dpt
      into v_dept;
    exit when v_dpt%notfound;
  
    dbms_output.put_line(v_dept.r_rmp || ' ' || v_dept.r_name);
  end loop;
  close v_dpt;
end;

--Use a strong ref cursor to fetch employee_id, first_name, and salary from EMPLOYEES.
declare
  type r is record(
    r_rmp  hr.employees.employee_id%type,
    r_name hr.employees.first_name%type,
    r_sal hr.employees.salary%type);
  type emp is ref cursor return r; ---Strong
  v_dpt  emp;
  v_dept r;
begin
  open v_dpt for
    select employee_id,first_name,salary from hr.employees;

  loop
    fetch v_dpt
      into v_dept;
    exit when v_dpt%notfound;
  
    dbms_output.put_line(v_dept.r_rmp || ' ' || v_dept.r_name||' '||v_dept.r_sal);
  end loop;
  close v_dpt;
end;

create or replace procedure emp_p(cur out sys_refcursor) as
begin
  open cur for
    select employee_id, first_name, salary from hr.employees;
end;
  
  declare
    emp     sys_refcursor;
    v_eid   hr.employees.employee_id%type;
    v_fname hr.employees.first_name%type;
    v_sal   hr.employees.salary%type;
  begin
    emp_p(emp);
    loop
      fetch emp
        into v_eid, v_fname, v_sal;
      exit when emp%notfound;
      dbms_output.put_line(v_eid || v_fname || v_sal);
    end loop;
  end;


select * from user_objects where object_name = 'EMP_11'

--Pass department_id as input and use a ref cursor to display employees of that department.
create or replace procedure emp_11(dpt in number, cur out sys_refcursor) as
begin
  open cur for
    select employee_id, first_name, department_id
      from hr.employees
     where department_id = dpt;
end;
  declare
    emp     sys_refcursor;
    vdpt    number := 50;
    v_eid   hr.employees.employee_id%type;
    v_fname hr.employees.first_name%type;
    v_sal   hr.employees.department_id%type;
  begin
    emp_11(vdpt, emp);
    loop
      fetch emp
        into v_eid, v_fname, v_sal;
      exit when emp%notfound;
      dbms_output.put_line(v_eid || v_fname || v_sal);
    end loop;
  end;
;



create or replace procedure emp_11(dpt in number, cur out sys_refcursor) as
  v_eid   hr.employees.employee_id%type;
    v_fname hr.employees.first_name%type;
    v_sal   hr.employees.department_id%type;
begin
  open cur for
    select employee_id, first_name, department_id
      from hr.employees
     where department_id = dpt;
         loop
      fetch emp
        into v_eid, v_fname, v_sal;
      exit when emp%notfound;
      dbms_output.put_line(v_eid || v_fname || v_sal);
    end loop;
end;


/*SQL  Question 1 (Analytical + Join)
Find highest-paid employee per department
 Window functions NOT allowed*/
--aggregation + join 
select h.department_id, h.first_name, h.salary
  from hr.employees h
  join (select department_id, max(salary) as max_sal
          from hr.employees
         group by department_id) m
    on h.department_id = m.department_id
 where h.salary = m.max_sal;
--using corelated subquery
select department_id, first_name, salary
  from hr.employees e
 where salary = (select max(salary)
                   from hr.employees h
                  where e.department_id = h.department_id);
--multicolumn cubquery
select department_id, first_name, salary
  from hr.employees
 where (department_id, salary) in
       (select department_id, max(salary)
          from hr.employees
         group by department_id);
--Using analytical but that are not saib in a Q 
select *
  from (select department_id,
               first_name,
               salary,
               dense_rank() over(partition by department_id order by salary desc) rn
          from hr.employees)
 where rn = 1
   and department_id is not null;


/*SQL  Question 2 (CTE + Aggregate)
Using a CTE, find departments where:
Employee count > average employee count of all departments*/
with emp as
 (select department_id, count(*) as total_emp
    from hr.employees
   group by department_id),
avg_count_emp as
 (select avg(total_emp) as avg_count from emp)
select e.department_id, e.total_emp
  from emp e
 where e.total_emp > (select avg_count from avg_count_emp);
 -- with Inline view
select department_id, total_emp
  from (select department_id, count(*) as total_emp
          from hr.employees
         group by department_id)
 where total_emp > (select avg(ct)
                      from (select department_id, count(*) as ct
                              from hr.employees
                             group by department_id));
--single CTE scalar subquey
with emp as
 (select department_id, count(*) as total_emp
    from hr.employees
   group by department_id)
select e.department_id, e.total_emp
  from emp e
 where e.total_emp > (select avg(total_emp) from emp);


/*SQL  Question 3 (CASE vs DECODE)
Classify employees:
salary < 5000  LOW
50008000  MEDIUM
8000  HIGH
Use CASE, not IF.*/
select first_name,
       salary,
       case
         when salary < 5000 then
          'low'
         when salary between 5000 and 8000 then
          'medium'
         when salary > 8000 then
          'high'
       end as salary_specification
  from hr.employees;


/*SQL  Question 4 (Correlated Subquery)
Find employees earning more than department average salary*/
select employee_id, first_name, salary
  from hr.employees e
 where salary > (select avg(salary)
                   from hr.employees
                  where department_id = e.department_id);


/*SQL  Question 5 (Analytical Function)
Find 2nd highest salary per department
 ROWNUM   MAX*/
select department_id, first_name, salary
  from (select department_id,
               first_name,
               salary,
               dense_rank() over(partition by department_id order by salary desc) as rn
          from hr.employees)
 where rn = 2;

select * from (
select distinct department_id ,salary from hr.employees 
order by salary desc )
where rownum <= 2 ;


/*SQL  Question 6 (Set Operator)
Find customers who:
Purchased in 2023
Purchased in 2024
(use INTERSECT)*/
SELECT customer_id
FROM customer
WHERE EXTRACT(YEAR FROM purchase_date) = 2023

INTERSECT

SELECT customer_id
FROM customer
WHERE EXTRACT(YEAR FROM purchase_date) = 2024;


/*SQL  Question 7 (View  Complex)
Create a view showing:
dept_id
total salary
average salary
View must be non-updatable
Explain why it is non-updatable.*/
create view sample_view as
select department_id as dept_id,
       sum(salary) as "total salary",
       avg(salary) as "average salary"
  from hr.employees
 group by department_id;
--This view is non-updatable because it uses aggregate functions (SUM, AVG) and GROUP BY.
--Due to aggregation, each row in the view does not map to a single row in the base table, 
--so Oracle cannot determine how to perform INSERT, UPDATE, or DELETE operations.

select * from sample_view ;


/*SQL  Question 8 (ANTI JOIN)
Find employees without any orders*/
SELECT e.emp_id, e.emp_name
FROM employees e
WHERE NOT EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.emp_id = e.emp_id
);


/*SQL  Question 9 (Subquery in SELECT)
Show:
emp_id
emp_name
department average salary (in same row)*/
select e.employee_id,
       e.first_name,
       (select avg(salary)
          from hr.employees e2
         where e.department_id = e2.department_id) as dept_avg
  from hr.employees e;


/*SQL  Question 10 (Execution Plan Logic)
Two queries differ only in literal values
Explain:
Hard parse or soft parse?
Why?*/
Ans:= If two queries differ only in literal values, Oracle performs a hard parse for the first 
      execution and a soft parse for subsequent executions, provided cursor sharing is possible.



--PART 3  MIXED SQL + PL/SQL ADVANCED QUESTIONS (10 Questions)
--These are REAL INTERVIEW KILLER QUESTIONS


/*MIX  Question 1 (Trigger + Procedure)
Create:
A trigger that calls a procedure
Procedure logs salary change history
Explain:
 Why trigger should not contain full logic*/

create or replace procedure sal_change_his(v_emp_id  number,
                                           v_old_sal number,
                                           v_new_sal number) is
begin
  insert into salary_history
  values
    (salary_hist_seq.NEXTVAL,
     v_emp_id,
     v_old_sal,
     v_new_sal,
     sysdate,
     user);
  dbms_output.put_line('Insertion succesful in employee1 table !');
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_backtrace ||
                         dbms_utility.format_error_stack);
end;

create or replace trigger call_pro
  after update of salary on employee1
  for each row
begin
  if :OLD.salary != :NEW.salary then
    sal_change_his(:OLD.emp_id, :OLD.salary, :NEW.salary);
  end if;
end;

update employee1
set salary = 29000
where emp_id = 103;

select * from hr.employees
select * from salary_history;
select * from user_objects where lower(object_name) = 'c_view_trg' ;

/*MIX  Question 2 (Function Used in SQL)
Create a function that:
Returns bonus based on salary
Used inside a SELECT statement
Explain:
 Restrictions of function used in SQL*/

create or replace function get_bonus(p_salary in number) return number is
  v_bonus number;
begin
  if p_salary < 30000 then
    v_bonus := 2000;
  elsif p_salary between 30000 and 50000 then
    v_bonus := 5000;
  else
    v_bonus := 10000;
  end if;
  return v_bonus;
end;

select emp_id, emp_name, salary, get_bonus(salary) as bonus from employee1;


/*MIX  Question 3 (View + INSTEAD OF Trigger)
Create a complex view joining EMP and DEPT
Allow INSERT using INSTEAD OF trigger*/
CREATE VIEW c_view AS
SELECT
    e.employee_id   AS emp_id,
    e.salary        AS salary,
    d.dept_name     AS dept_name
FROM employees e
JOIN departments d
ON e.dept_id = d.dept_id;

CREATE OR REPLACE TRIGGER c_view_trg
INSTEAD OF INSERT ON c_view
FOR EACH ROW
BEGIN
    INSERT INTO employees (employee_id, salary, dept_id)
    VALUES (:NEW.emp_id, :NEW.salary, 20);
END;

INSERT INTO c_view VALUES (7,10000,'SALES');
COMMIT;

SELECT * FROM employees WHERE employee_id = 7;



/*MIX  Question 4 (Package + REF CURSOR)
Package returns REF CURSOR
Cursor used in SQL*Plus to fetch data
Explain cursor lifecycle*/

create or replace package emp_pkg as
  procedure fetch_emp(dpt_id number, det out sys_refcursor);
end emp_pkg;

create or replace package body emp_pkg is
  procedure fetch_emp(dpt_id number, det out sys_refcursor) is
  begin
    open det for
      select employee_id, emp_name, salary
        from employees
       where dept_id = dpt_id;
  end fetch_emp;
end emp_pkg;
 
declare
  emp    sys_refcursor;
  v_emp  number;
  v_name varchar2(90);
  v_sal  number;
begin
  emp_pkg.fetch_emp(10, emp);
  loop
    fetch emp
      into v_emp, v_name, v_sal;
    exit when emp%notfound;
    dbms_output.put_line(v_emp || ' ' || v_name || ' ' || v_sal);
  end loop;
  close emp;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;



/*MIX  Question 5 (Autonomous Transaction + Trigger)
Trigger logs DELETE operations
Explain:
 Why autonomous transaction is mandatory here*/
create or replace trigger sal_trg
  after delete on employees
  for each row
declare
  pragma autonomous_transaction;
begin
  insert into sal_audit_log_table
  values
    (:OLD.id, 'salary deleted', :OLD.salary);
  commit;
end;


/*MIX  Question 6 (Collection + Bulk Collect + FORALL)
Migrate data from one table to another:
Use BULK COLLECT
Use FORALL
Handle partial failures*/
create or replace procedure data_trns is
  type emp is table of employee%rowtype;
  v_emp emp;
begin
  select * bulk collect into v_emp from employee;

  forall i in v_emp.first .. v_emp.last save exceptions
    insert into emp
    values
      (v_emp(i).employee_id,
       v_emp(i).department,
       v_emp(i).project,
       v_emp(i).work_date,
       v_emp(i).hours_worked,
       v_emp(i).tasks_completed);

exception
  when others then
    for j in 1 .. SQL%BULK_EXCEPTIONS.COUNT loop
      DBMS_OUTPUT.PUT_LINE('Error at row ' || SQL%BULK_EXCEPTIONS(j)
                           .ERROR_INDEX || ' Code: ' || SQL%BULK_EXCEPTIONS(j)
                           .ERROR_CODE);
    end loop;
end;

begin
  data_trns;
end;


--Q1. Simple Procedure
--Write a procedure to increase salary by 10% for all employees in a given department.
--NO_DATA_FOUND cannot be used with UPDATE statements, 
--so I use SQL%ROWCOUNT to check whether any rows were affected.

create or replace procedure incre_sal(dpt_name in varchar2) is
begin
  update employees1
     set salary = salary + (salary * 0.10)
   where department = dpt_name;

  if SQL%ROWCOUNT = 0 then
    dbms_output.put_line('departmet name ' || dpt_name || ' not found');
  else
    dbms_output.put_line('salary updated sucessfully');
  end if;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_backtrace ||
                         dbms_utility.format_error_stack);
end;

begin
  incre_sal('hr');
end;

select * from employees1;


--Q2. IN + OUT Parameters
--Write a procedure that accepts department id as input and returns:
--total number of employees
--average salary

create or replace procedure dpt_avg(dpt_id  in number,
                                    t_emp   out number,
                                    avg_sal out number) is
begin
  select avg(salary), count(employee_id)
    into avg_sal, t_emp
    from hr.employees
   where department_id = dpt_id;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_backtrace ||
                         dbms_utility.format_error_stack);
end;

declare
  dpt_id  number := &_num;
  t_emp   number;
  avg_sal number;
begin
  dpt_avg(dpt_id, t_emp, avg_sal);
  dbms_output.put_line('total employee in department ' || dpt_id || ' is ' ||
                       t_emp || ' and avg salary is ' || round(avg_sal,2));
end;

--Q3. Validation + Exception
--Write a procedure to insert a new employee.
--If employee ID already exists, raise a user-defined exception.
create or replace procedure emp_valid(emp_id in number,
                                      dpt_id in varchar2,
                                      w_date in date,
                                      task_c in number) is
  v_emp number;
  emp_exist exception;
begin
  select count(*) into v_emp from employee where employee_id = emp_id;
  if v_emp >= 1 then
    raise emp_exist;
  else
    insert into employee
      (employee_id, department, work_date, tasks_completed)
    values
      (emp_id, dpt_id, sysdate, task_c);
    dbms_output.put_line('insertion successful');
  end if;
exception
  when emp_exist then
    dbms_output.put_line('employee allready exist with employee_id :' ||
                         emp_id);
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;

begin
  emp_valid(101,'IT',sysdate,5);
end;

select * from employee where employee_id = 101;
select * from user_objects where lower(object_name) = ('emp_valid');
select * from user_source where name = 'EMP_VALID';
select * from user_errors where name = 'EMP_VALID';


--Q4. Cursor + Loop
--Write a procedure to display employee names and salaries for a given department using an explicit cursor.
create or replace procedure emp_name(dpt_no in number) is
  cursor cur is
    select first_name, salary
      from hr.employees
     where department_id = dpt_no;
  v_name  hr.employees.first_name%type;
  v_sal   hr.employees.salary%type;
  v_count boolean := false;
begin
  open cur;
  loop
    fetch cur
      into v_name, v_sal;
    exit when cur%notfound;
    v_count := true;
    dbms_output.put_line('emp_name : ' || v_name || ' salary is : ' ||
                         v_sal);
  end loop;
  close cur;
  if not v_count then
    dbms_output.put_line('Employee not found ');
  end if;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;

  begin
    emp_name(900);
  end;

--Q5. Procedure Returning Multiple Rows
--Write a procedure that returns all employees of a department using an OUT SYS_REFCURSOR.
create or replace procedure all_emp(dpt_id in number,
                                    emp    out sys_refcursor) is
begin
  open emp for
    select employee_id, first_name, salary, department_id
      from hr.employees
     where department_id = dpt_id;
end;
  
declare
  emp sys_refcursor;
  a number := &_num ;
  v_emp  hr.employees.employee_id%type;
  v_name hr.employees.first_name%type;
  v_sal  hr.employees.salary%type;
  v_dpt  hr.employees.department_id%type;
begin
  all_emp(a, emp);
  loop
    fetch emp
      into v_emp, v_name, v_sal, v_dpt;
    exit when emp%notfound;
    dbms_output.put_line(v_emp || ' | ' || v_name || ' | ' || v_sal ||
                         ' | ' || v_dpt);
  end loop;
  close emp ;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;

--Q6. Collection Usage
--Write a procedure that:
--  fetches all salaries into a collection
--  prints only salaries greater than 8000
create or replace procedure col_sal is
  type sal is table of number;
  v_sal sal;
begin
  select salary bulk collect into v_sal from employees where salary > 8000;

  if v_sal.count = 0 then
    dbms_output.put_line('No salary above 8000');
    return;
  end if;

  for i in 1 .. v_sal.count loop
    dbms_output.put_line(v_sal(i));
  end loop;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;

begin
  col_sal;
end;

select * from user_source where lower(name) = 'col_sal' ;
select * from user_errors where lower(name) = 'col_sal' ;
--Q7. Procedure with Transaction Control
--Write a procedure to transfer salary from one employee to another using:
--SAVEPOINT
--ROLLBACK

create or replace procedure transfer_salary(p_from_emp in number,
                                            p_to_emp   in number,
                                            p_amount   in number) is
  v_from_sal number;
begin

  -- Get sender salary and lock row
  select salary
    into v_from_sal
    from employees
   where emp_id = p_from_emp
     for update;

  -- Check sufficient balance
  if v_from_sal < p_amount then
    dbms_output.put_line('Insufficient salary to transfer');
    return;
  end if;

  -- Savepoint before transfer
  savepoint before_transfer;

  -- Deduct from sender
  update employees
     set salary = salary - p_amount
   where emp_id = p_from_emp;

  -- Add to receiver
  update employees set salary = salary + p_amount where emp_id = p_to_emp;

  commit;

  dbms_output.put_line('Salary transferred successfully');

exception
  when no_data_found then
    rollback;
    dbms_output.put_line('Employee not found');
  
  when others then
    rollback to before_transfer;
    dbms_output.put_line('Transfer failed. Rolled back to savepoint');
    raise;
end;

--Q8. Procedure with DDL
--Write a procedure that checks whether an index exists on a column.
--If not, create the index dynamically.
create or replace procedure check_ind(v_column_name in varchar2,
                                      v_table_name  in varchar2) is
  v_cunt number;
  v_sql  varchar2(900);
begin
  select count(*)
    into v_cunt
    from user_ind_columns
   where lower(column_name) = lower(v_column_name)
     and lower(table_name) = lower(v_table_name);

  if v_cunt = 0 then
    v_sql := 'create index idx_' || v_table_name || ' on ' || v_table_name || '(' ||
             v_column_name || ')';
    execute immediate v_sql;
    dbms_output.put_line('index created successful');
  else
    dbms_output.put_line('Index present');
  end if;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;

begin
  check_ind('salary','employees');
end;

drop index idx_salary;
select * from employees ;

select * from user_source where lower(name) = 'check_ind' ;
select * from user_errors where lower(name) = 'check_ind' ;

--Q9. Audit Procedure
--Write a procedure that updates employee salary and logs old and new salary into an audit table 
--using an autonomous transaction.
create or replace procedure audit_sal(v_emp_id  in number,
                                      v_old_sal in number,
                                      v_new_sal in number) is
  pragma autonomous_transaction;
begin
  insert into sal_audit
    (emp_id, old_sal, new_sal, change_date, change_by)
  values
    (v_emp_id, v_old_sal, v_new_sal, sysdate, user);
  commit;

exception
  when others then
    rollback;
    raise;
end;

create or replace procedure sal_update(v_emp_id in number, v_sal in number) is
v_old_sal number;
begin
select salary into v_old_sal from employees where emp_id = v_emp_id;

update employees set salary = v_sal where emp_id = v_emp_id;

audit_sal(v_emp_id, v_old_sal, v_sal);

commit;

dbms_output.put_line('Salary updated and audited');

exception
when no_data_found then dbms_output.put_line('no emplyeee found '); when others then rollback; raise;
end;


--Q10. Advanced Scenario
--Write a procedure that:
--accepts department id
--calculates highest salary in that department
--updates all employees earning below average to average salary
create or replace procedure cal_avg_sal(v_dpt_id in number) is
  v_max_sal number;
  v_avg_sal number;
begin
  select max(salary), avg(salary)
    into v_max_sal, v_avg_sal
    from employees
   where dept_id = v_dpt_id;

  if v_max_sal is null then
    dbms_output.put_line('No employee available');
    return;
  end if;

  update employees
     set salary = v_avg_sal
   where salary < v_avg_sal
     and dept_id = v_dpt_id;

  dbms_output.put_line(sql%rowcount || ' employee updated');
  commit;
exception
  when others then
    rollback;
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;


--Q1. Simple Function
--Write a function that returns the annual salary of an employee
--(salary * 12) for a given employee_id.
create or replace function anu_sal(emp_id in number) return number is
  annual_sal number;
begin
  select salary * 12
    into annual_sal
    from hr.employees
   where employee_id = emp_id;
  return annual_sal;
exception
  when NO_DATA_FOUND then
    dbms_output.put_line('Emplooyee Not Found With EMP_ID :' || emp_id);
    return null;
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
    return null;
end;

select anu_sal(1011) from dual ;

declare
  b      number;
begin
  b := anu_sal(101);
  DBMS_OUTPUT.PUT_LINE('Annual Salary = ' || b);
end;

select * from user_errors where lower(name) = 'cal_avg_sal' ;

--Q2. Function with Validation
--Write a function that accepts employee_id and:
--returns salary if employee exists
--returns -1 if employee does not exist
create or replace function emp_sal(emp_id in number) return number is
  sal number;
begin
  select salary into sal from hr.employees where employee_id = emp_id;
  return sal;
exception
  when no_data_found then
    return - 1;
  when others then
    return null;
end;

declare
  salary number;
begin
  salary := emp_sal(1011);
  if salary = -1 then
    dbms_output.put_line('employee not found ');
  else
    dbms_output.put_line('salary of employee is :' || salary);
  end if;
end;

--Q3. Function with Conditional Logic
--Write a function that returns employee grade based on salary:
-- < 5000  'LOW'
-- 50008000  'MEDIUM'
-- > 8000  'HIGH'
create or replace function emp_grade(emp_id in number) return varchar2 is
  v_sal number;
  v_emp number;
begin
  select salary, employee_id
    into v_sal, v_emp
    from hr.employees
   where employee_id = emp_id;

  if v_sal < 5000 then
    return 'Low';
  elsif v_sal between 5000 and 8000 then
    return 'Medium';
  else
    return 'High';
  end if;

exception
  when no_data_found then
    return 'no employee found';
  when others then
    return 'error';
end;

select emp_grade(1101) from dual ;

DECLARE
  v_grade VARCHAR2(30);
BEGIN
  v_grade := emp_grade(1061);   -- function call
  DBMS_OUTPUT.PUT_LINE('Employee Grade = ' || v_grade);
END;


--Q4. Function Using Aggregate
--Write a function that returns the average salary of a department
--for a given department_id
create or replace function f_dpt_avg(dpt_id in number) return number is
  v_avg_sal number;
begin
  select avg(salary) as avg_sal
    into v_avg_sal
    from hr.employees
   where department_id = dpt_id;

  return v_avg_sal;
exception
  when others then
    raise;
end;

select f_dpt_avg(200) from dual ;

declare
  a number;
begin
  a := f_dpt_avg(200);
  dbms_output.put_line('avg salary is : ' || a);
end;

--Q5. Function Using Correlated Logic
--Write a function that checks whether an employees salary is greater than their department average
--and returns 'YES' or 'NO'
create or replace function sal_check(emp_id in number) return varchar2 is
  v_sal number;
begin
  select count(*)
    into v_sal
    from hr.employees e
   where employee_id = emp_id
     and salary > (select avg(salary)
                     from hr.employees d
                    where e.department_id = d.department_id);
  if v_sal > 0 then
    return 'Yes';
  else
    return 'No';
  end if;
exception
  when no_data_found then
    return 'No';
  when others then
    return 'Error';
end;

select sal_check(100) from dual ;

declare
a varchar2(10);
begin
  a := sal_check(101);
   dbms_output.put_line(a);
  end;

select * from user_source  where name = ('SAL_CHECK') ;
select * from user_errors where name = ('SAL_CHECK') ;

--Q6. Function with Exception Handling
--Write a function that returns the manager name of an employee.
  --If no manager exists, return 'NO MANAGER'.
create or replace function manager_name(emp_id in number) return varchar2 is
  v_mgr varchar2(90);
begin
  select first_name
    into v_mgr
    from hr.employees e
   where employee_id =
         (select manager_id from hr.employees d where employee_id = emp_id);

  return v_mgr;
exception
  when no_data_found then
    return 'No Manager';
  when others then
    return 'Error';
end;

select manager_name(1001) from dual ;

declare
  a varchar2(90);
begin
  a := manager_name(100);
  dbms_output.put_line(a);
end;

select * from user_objects where lower(object_name) = 'count_emp'

--Q7. Function Using Cursor
--Write a function that returns the count of employees earning more than 8000
--using an explicit cursor.
create or replace function count_emp return number is
  cursor emp is
    select count(*) as emp_count from employees where salary > 800;
  v_emp number;
begin
  open emp;
  loop
    fetch emp
      into v_emp;
    exit when emp%notfound;
  end loop;
  close emp;
  return v_emp;
  exception
    when no_data_found then
      return 0 ;
      when others then 
        return -1 ;
end;
 
select count_emp from dual ;
----------
create or replace function count_emp return number is
  cursor emp is
    select count(*) as emp_count from employees where salary > 800;
  v_emp number;
begin
  open emp;
  fetch emp
    into v_emp; --Best one 
  return v_emp;
exception
  when no_data_found then
    return 0;
  when others then
    return - 1;
end;
 
select count_emp from dual ;
---------------------------
create or replace function count_emp return number is
begin
  for i in (select count(*) as emp_count from employees where salary > 800) loop
    return i.emp_count;
  end loop;
  return 0;
exception
  when others then
    return - 1;
end;

select count_emp from dual ;

 select * from user_errors where lower(name) = 'second_high_sal';
 
--Q8. Function Using Collection
--Write a function that:
--collects all salaries of a department into a collection
--returns the maximum salary from that collection
create or replace function max_sal_dpt(dpt_id in number) return number is
  type emp is table of number;
  v_sal emp;
  v_max number := 0;
begin
  select salary
    bulk collect
    into v_sal
    from employees
   where dept_id = dpt_id;

  for i in 1 .. v_sal.count loop
    if v_sal(i) > v_max then
      v_max := v_sal(i);
    end if;
  end loop;
  return v_max;
exception
  when no_data_found then   --never fire because bulk collect return 0 if no data found 
    return 0;
  when others then
    return - 1;
end;

select max_sal_dpt(11) from dual ;

select * from employees;
--Q9. Function with Autonomous Transaction
--Write a function that:
--logs an error message into a log table
--returns 1
--(use PRAGMA AUTONOMOUS_TRANSACTION)

create or replace function log_msg(v_msg in varchar2) return number is
  pragma autonomous_transaction;
begin
  insert into log_table (log_msg) values (v_msg);
  return 1;  --Once RETURN runs, the function exits immediately.
  commit;    --So COMMIT is dead code   it will never execute.
exception
  when others then
    return - 1;
end;
      
create or replace function log_msg(v_msg in varchar2) return number is
  pragma autonomous_transaction;
begin
  insert into log_table (log_msg) values (v_msg);
  commit;
  return 1;
exception
  when others then
    rollback;
    return - 1;
end;

--Q10. Advanced Function
--Write a function that:
--accepts department_id
--returns the 2nd highest salary in that department
--(Analytical functions allowed)
create or replace function second_high_sal(v_dpt_id in number)
  return number is
  v_sal number;
begin

  select max(salary)
    into v_sal
    from (select dept_id,
                 salary,
                 dense_rank() over(partition by dept_id order by salary desc) as rn
            from employees
           where dept_id = v_dpt_id)
   where rn = 2;
  if v_sal is null then
    return - 1;
  end if;
  return v_sal;
exception
  when others then
    raise;
end;
  
select second_high_sal(160) from dual ;

declare
  a number;
begin
  a := second_high_sal(120);
  if a = -1 then
    dbms_output.put_line('No data found in current department');
  else
    dbms_output.put_line('Second highest salary of department is: ' || a);
  end if;
end;


-Procedures
--Aggregate functions can be used to calculate summary values dynamically.

create or replace procedure get_total_salary(p_dpt in number) is
  v_total number;
begin
  select sum(salary)
    into v_total
    from hr.employees
   where department_id = p_dpt;

  dbms_output.put_line('Total salary : ' || v_total || ' From dpt : ' ||
                       p_dpt);
end;

begin
  get_total_salary(20);
end;


--Functions
--Used in user-defined functions for reusable summary logic.

create or replace function get_avg_salary(p_dpt in number)
return number  is
  v_avg number;
begin
  select avg(salary)
    into v_avg
    from hr.employees
   where department_id = p_dpt;
   
   return v_avg ;
  
end;

declare
  v_dp number;
begin
  v_dp := 20;
  dbms_output.put_line('Average salary : ' || get_avg_salary(v_dp) ||
                       ' From dpt : ' || v_dp);
end;


--Packages
--Aggregate logic can be bundled inside packages for modular reporting.

CREATE OR REPLACE PACKAGE sales_pkg IS
  FUNCTION yearly_sales (p_year NUMBER) RETURN NUMBER;
END;

CREATE OR REPLACE PACKAGE BODY sales_pkg IS
  FUNCTION yearly_sales (p_year NUMBER) RETURN NUMBER IS
    v_total NUMBER;
  BEGIN
    SELECT SUM(salary) INTO v_total
    FROM hr.employees
    WHERE EXTRACT(YEAR FROM hire_date) = p_year;
    RETURN v_total;
  END;
END;

DECLARE
  v_total NUMBER;
BEGIN
  v_total := sales_pkg.yearly_sales(2005);
  DBMS_OUTPUT.PUT_LINE('Total salary for 2005 hires: ' || v_total);
END;


--Triggers
--Aggregate functions can be used in triggers to validate or restrict data.
--Example: Prevent inserting employee if depts total salary exceeds a limit.

CREATE OR REPLACE TRIGGER salary_limit
BEFORE INSERT OR UPDATE ON emp
FOR EACH ROW
DECLARE
  v_total NUMBER;
BEGIN
  SELECT SUM(sal) INTO v_total
  FROM emp
  WHERE deptno = :NEW.deptno;

  IF v_total + :NEW.sal > 100000 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Salary limit exceeded for department!');
  END IF;
END;


-- 1. Function Example: Logging Errors During Validation Without Interrupting Flow

CREATE OR REPLACE FUNCTION validate_salary(p_emp_id NUMBER, p_new_salary NUMBER)
RETURN VARCHAR2 IS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  IF p_new_salary < 0 THEN
    INSERT INTO error_log(log_id, error_message, log_time)
    VALUES (p_emp_id, 'Negative salary not allowed.', SYSDATE);
    COMMIT;
    RETURN 'Invalid';
  END IF;
                    
  RETURN 'Valid';
END;

select * from error_log

DECLARE
  v_result VARCHAR2(10);
BEGIN
  v_result := validate_salary(102, 500);
  DBMS_OUTPUT.PUT_LINE('Validation result: ' || v_result);
END;
--This function validates salary input, logs error autonomously, and continues flow without blocking user.

-- 2. Function Example: Tracking Report Generation Time Independently
create table activity_log (
msg varchar2(100),
log_time date
);

select * from activity_log ;

create or replace function log_activity(p_msg varchar2) return varchar2 is
  pragma autonomous_transaction;
begin
  insert into activity_log (msg, log_time) values (p_msg, sysdate);
  commit;
  return 'Activity Log';
end;

BEGIN
  -- Doing some dummy operation (you can imagine this part)
  DBMS_OUTPUT.put_line('Doing some operation...');
  
  -- Calling the autonomous function
  DBMS_OUTPUT.put_line(log_activity('Main block accessed by user'));

  -- This rollback will NOT affect the insert done inside the function
  ROLLBACK;
END;

--  2. Function Example: Tracking Report Generation Time Independently

CREATE OR REPLACE FUNCTION report_audit(p_user VARCHAR2)
RETURN VARCHAR2 IS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO report_log(username, generated_on)
  VALUES (p_user, SYSDATE);
  COMMIT;
  RETURN 'Report generation logged';
END;

select * from report_log ;

--Autonomous Transaction In Triggers.

-- 1. Trigger Example: Auditing Delete Operations Separately

create or replace trigger trg_emp_delete
  before delete on aaa
  for each row
declare
  pragma autonomous_transaction;
begin
  INSERT INTO delete_audit
    (emp_id, deleted_at)
  VALUES
    (:OLD.emp_id, SYSDATE);
  COMMIT;
END;

-- 2. Trigger Example: Error Logging During Row Update Failure

create or replace trigger trg_update_error 
after delete  on aaa
for each row
  declare 
  pragma autonomous_transaction ;
  begin
    if :NEW.salary < 0 then 
      insert into error_log(emp_id, error_msg, log_time)
    VALUES (:NEW.emp_id, 'Invalid salary after update', SYSDATE);
    COMMIT;
  END IF;
END;

select * from aaa ;
select * from error_log ;

create table error_log (
emp_id number,
error_msg varchar2(50),
log_time date
);

-- 1. Package Example: Audit Utility Package
CREATE OR REPLACE PACKAGE audit_pkg IS
  PROCEDURE log_event(p_msg VARCHAR2);
END;
/

CREATE OR REPLACE PACKAGE BODY audit_pkg IS
  PROCEDURE log_event(p_msg VARCHAR2) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO event_log(msg, log_time) VALUES (p_msg, SYSDATE);
    COMMIT;
  END;
END;

-- 2. Package Example: Tracking Access from UI
CREATE OR REPLACE PACKAGE user_track_pkg IS
  PROCEDURE record_access(p_user VARCHAR2);
END;
/

CREATE OR REPLACE PACKAGE BODY user_track_pkg IS
  PROCEDURE record_access(p_user VARCHAR2) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO user_access_log(username, access_time)
    VALUES (p_user, SYSDATE);
    COMMIT;
  END;
END;


-- Example 1: Handle Zero Divide Error Gracefully

DECLARE
  e_zero_divide EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_zero_divide, -1476); -- ORA-01476

  v_result NUMBER;
BEGIN
  v_result := 100 / 0;
EXCEPTION
  WHEN e_zero_divide THEN
    DBMS_OUTPUT.PUT_LINE('Division by zero is not allowed!');
END;


-- Example 2: Handle Value Too Large for Column

declare
  e_val_large exception;
  pragma exception_init(e_val_large, -12899);

begin
  INSERT INTO test_table (col1) VALUES (RPAD('A', 500, 'A'));
  exception
  when e_val_large then
    dbms_output.put_line('Data To Large For Column');
end;


select * from  test_table ; 

create table test_table(
col1 varchar2(10) );

drop table test_table ;

-- Example 3: Duplicate Record Handling (Unique Constraint)

declare
  e_dub exception;
  pragma exception_init(e_dub, -1);
begin
  insert into studentt (rollno,marks, grade) values (108,43, 'A');
exception
  when e_dub then
    dbms_output.put_line('This value Are allready exist');
end;


--Use for global variables that dont need to retain state between calls (especially in high-load systems).

create or replace package pkg_test is
  pragma serially_reusable;
  procedure p1;
end;

create or replace package body pkg_test is
  pragma serially_reusable;
  g_counter number := 0;

  procedure p1 is
  begin
    g_counter := g_counter + 1;
    dbms_output.put_line('Counter : ' || g_counter);
  exception
    when others then
      dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                           DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  end;
end ;

select * from user_objects where object_name = upper('memory_test_package') ;

begin
  pkg_test.p1;
  pkg_test.p1;
  pkg_test.p1;
end;

begin
  pkg_test.p1;
end ;

begin
  pkg_test.p1;
end ;

-- Example 2: Shared Package State  Reset Happens on Each Call

create or replace package sharde_pkg is
  pragma serially_reusable;
  v_data varchar2(100);
  procedure p1(v_val varchar2);
  procedure p2;
end;

create or replace package body sharde_pkg is
  pragma serially_reusable;

  procedure p1(v_val varchar2) is
  begin
    v_data := v_val;
  end;

  procedure p2 is
  begin
    dbms_output.put_line(v_data);
  end;
end;

BEGIN
  sharde_pkg.p1('ABC');
  sharde_pkg.p2;
  -- Will print: Data:
  -- Because g_data resets on next call
END;

begin
  sharde_pkg.p2;
end;

-- Example 3: Save Memory When Handling Bulk Data

select * from user_objects where object_name = upper('memory_test_package') ;

CREATE OR REPLACE PACKAGE memory_test_pkg IS
  PRAGMA SERIALLY_REUSABLE;
  TYPE arr IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  g_arr arr;
  PROCEDURE load_data;
  PROCEDURE print_data;
END;
/

CREATE OR REPLACE PACKAGE BODY memory_test_pkg IS
  PRAGMA SERIALLY_REUSABLE;

  PROCEDURE load_data IS
  BEGIN
    FOR i IN 1..1000 LOOP
      g_arr(i) := i * 2;
    END LOOP;
  END;

  PROCEDURE print_data IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('g_arr(10) = ' || g_arr(10)); -- Likely NULL
  END;
END;

BEGIN
  memory_test_pkg.load_data;
  memory_test_pkg.print_data;
END;
/

-- First call
BEGIN
  memory_test_pkg.load_data;
END;

-- Q1: Error Logging from Trigger
--You have an employees table and a log_table for error messages. Create a trigger that logs an error into 
--log_table when someone tries to insert an employee with a salary above 1,00,000.

--Use PRAGMA AUTONOMOUS_TRANSACTION inside the trigger to make sure logs are saved even if the main transaction fails.

create table worker (
id number,
name varchar2(50),
salary number );

insert into worker values (1,'Danny',50000);

create table sal_audit_log_table (
id number,
msg varchar2(100),
salary number );

create or replace trigger sal_audit 
  after insert on worker
  for each row
declare
  pragma autonomous_transaction;
begin
  if :NEW.salary > 100000 then
    insert into sal_audit_log_table
      (id, msg, salary)
    values
      (:NEW.id, 'salary inserted more that 100000', :NEW.salary);
  end if;
  commit;
end;

insert into worker values (23,'Alice',11000);

select * from worker ;
select * from sal_audit_log_table ;

select * from user_objects where object_name = upper('withdrawal_cursor') ;


-- Q2: Bank Withdrawal System
--Table: bank_account(account_id, balance)
--Design a procedure withdraw_amount(p_id, p_amt) that deducts the amount and logs the transaction into a 
--transaction_audit table, 
--even if the main withdrawal fails due to insufficient balance.

--Use AUTONOMOUS_TRANSACTION to log all attempts.
select * from hr.employees ;
-
create table bank_account (
account_id number,
balance number);

insert into bank_account values(101,20000);
insert into bank_account values(102,452000);
insert into bank_account values(103,35000);
insert into bank_account values(104,2000);

create table transaction_audit (
id number,
withdrawal_amount number,
balance number ,
withdraw_time date
);

drop table transaction_audit ;

create or replace procedure withdraw_amount(account_id     number,
                                            p_balance      number,
                                            p_withdraw_amt number) is
  pragma autonomous_transaction;
begin
  insert into transaction_audit
    (id, withdrawal_amount, balance, withdraw_time)
  values
    (account_id, p_withdraw_amt, p_balance, sysdate);
  commit;
end;

create or replace procedure withdrawal(p_id              number,
                                       p_withdraw_amount number) is
  v_bal     bank_account.balance%type;
  v_new_bal number;
begin
  select balance
    into v_bal
    from bank_account
   where account_id = p_id
     for update;

  if p_withdraw_amount <= v_bal then
    v_new_bal := v_bal - p_withdraw_amount;
  
    update bank_account set balance = v_new_bal where account_id = p_id;
  
    withdraw_amount(p_id, v_new_bal,p_withdraw_amount);
  
    commit;
    DBMS_OUTPUT.PUT_LINE('Withdrawal successful. New balance: ' ||
                         v_new_bal);
  ELSE
    DBMS_OUTPUT.PUT_LINE('Insufficient funds. Current balance: ' ||
                         v_bal);
                          withdraw_amount(p_id,v_bal,p_withdraw_amount);
  END IF;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('Account not found');
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Withdrawal error: ' || SQLERRM);
    RAISE;
END;


begin
  withdrawal(101,1000);
  end;

select * from bank_account ;
select * from transaction_audit ;

--- Way 2nd using cursor
create or replace procedure log_withdrawal (account_id     number,
                                            p_balance      number,
                                            p_withdraw_amt number) is
  pragma autonomous_transaction;
begin
  insert into transaction_audit
    (id, withdrawal_amount, balance, withdraw_time)
  values
    (account_id, p_withdraw_amt, p_balance, sysdate);
  commit;
end;

BEGIN
  withdrawal_cursor(101, 10000);
END;

---
CREATE OR REPLACE PROCEDURE withdrawal_cursor(p_id              NUMBER,
                                              p_withdraw_amount NUMBER) IS
  CURSOR c_withdraw IS
    SELECT account_id, balance
      FROM bank_account
     WHERE account_id = p_id
       FOR UPDATE;

  v_id  bank_account.account_id%TYPE;
  v_bal bank_account.balance%TYPE;

BEGIN
  OPEN c_withdraw;
  FETCH c_withdraw
    INTO v_id, v_bal;

  IF c_withdraw%FOUND THEN
    IF p_withdraw_amount <= v_bal THEN
      UPDATE bank_account
         SET balance = v_bal - p_withdraw_amount
       WHERE account_id = v_id;
    
      log_withdrawal(p_id,  v_bal - p_withdraw_amount, p_withdraw_amount);
      COMMIT;
    
      DBMS_OUTPUT.PUT_LINE('Withdrawal successful. New balance: ' ||
                           (v_bal - p_withdraw_amount));
    ELSE
      DBMS_OUTPUT.PUT_LINE('Insufficient balance: ' || v_bal);
      log_withdrawal(p_id,  p_withdraw_amount); -- attempt log
    END IF;
  ELSE
    DBMS_OUTPUT.PUT_LINE('Account not found');
  END IF;

  CLOSE c_withdraw;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
--

select * from bank_account ;
select * from transaction_audit ;

-- Q3: Track Login Failures
-- You have a table user_logins(username, login_time, status) and login_audit(username, attempt_time, status_msg).
-- If a user fails to login (say, incorrect password), a procedure should log this attempt immediately, 
--regardless of final outcome.

-- Create a log_login_failure(p_user, p_msg) procedure using AUTONOMOUS_TRANSACTION.

-- 1. Table Setup (for demo)
CREATE TABLE user_logins (
    username    VARCHAR2(50),
    login_time  DATE,
    status      VARCHAR2(20)
);

CREATE TABLE login_audit (
    username    VARCHAR2(50),
    attempt_time DATE,
    status_msg  VARCHAR2(200)
);

-- Optional: Create a users table for more realistic testing
CREATE TABLE users (
    username VARCHAR2(100) PRIMARY KEY,
    password VARCHAR2(100)
);

-- Insert some test users
INSERT INTO users VALUES ('john_doe', 'secure123');
INSERT INTO users VALUES ('jane_smith', 'password456');
COMMIT;
-- 2. Procedure using AUTONOMOUS_TRANSACTION
CREATE OR REPLACE PROCEDURE log_login_failure (
    p_user VARCHAR2,
    p_msg  VARCHAR2
)
IS
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    INSERT INTO login_audit (username, attempt_time, status_msg)
    VALUES (p_user, SYSDATE, p_msg);

    COMMIT; -- Important: commit inside autonomous transaction
EXCEPTION
    WHEN OTHERS THEN
        -- Optional: handle logging errors separately
        ROLLBACK;
END;
/

-- 3. Example Usage
BEGIN
    -- Simulating a failed login attempt
    log_login_failure('john_doe', 'Invalid password');

    -- Simulating main login insert that fails
    INSERT INTO user_logins (username, login_time, status)
    VALUES ('john_doe', SYSDATE, 'FAILED');

    ROLLBACK; -- Rollback main transaction
END;
/

-- 4. Verification
SELECT * FROM login_audit;

-- Test simple logging
BEGIN
    log_login_failure('test_user', 'Incorrect password');
END;
/

-- Verify the record was inserted
SELECT * FROM login_audit;

-- Test that the log persists even when main transaction fails
BEGIN
    -- Log a failure
    log_login_failure('john_doe', 'Invalid credentials');
    
    -- Force an error in the main transaction
    RAISE_APPLICATION_ERROR(-20001, 'Simulated error');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Main transaction failed: ' || SQLERRM);
        ROLLBACK;
END;
/

-- Check if the audit record exists despite the rollback
SELECT * FROM login_audit WHERE username = 'john_doe';

-- Test with a mock authentication procedure
CREATE OR REPLACE PROCEDURE test_authentication(
    p_username IN VARCHAR2,
    p_password IN VARCHAR2
) AS
    v_user_exists NUMBER;
BEGIN
    -- Check if user exists
    SELECT COUNT(*) INTO v_user_exists
    FROM users
    WHERE username = p_username;
    
    IF v_user_exists = 0 THEN
        log_login_failure(p_username, 'User not found');
        RAISE_APPLICATION_ERROR(-20001, 'Authentication failed');
    END IF;
    
    -- Simulate password check failure
    log_login_failure(p_username, 'Incorrect password');
    RAISE_APPLICATION_ERROR(-20002, 'Invalid credentials');
END;
/

-- Test with non-existent user
BEGIN
    test_authentication('unknown_user', 'anypassword');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

-- Test with existing user but wrong password
BEGIN
    test_authentication('john_doe', 'wrongpass');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

-- Verify both attempts were logged
SELECT * FROM login_audit ORDER BY attempt_time DESC;


--Scenario
--Requirement:
--When inserting an employee record into the employees table:
--If insert fails, rollback the main transaction but log the error into an error_audit table immediately.
--The error log must be saved even if the main transaction rolls back.

select * from user_objects where object_name = upper('add_employee') ;


-- 1. Setup tables for demo
CREATE TABLE employees2 (
    emp_id     NUMBER PRIMARY KEY,
    emp_name   VARCHAR2(50),
    salary     NUMBER
);

CREATE TABLE error_audit1 (
    --log_id       NUMBER  PRIMARY KEY,
    proc_name    VARCHAR2(50),
    error_msg    VARCHAR2(4000),
    error_time   DATE
);
 
drop table error_audit1 ;
-- 2. Logging procedure (AUTONOMOUS TRANSACTION)
CREATE OR REPLACE PROCEDURE log_error(
    p_proc_name IN VARCHAR2,
    p_err_msg   IN VARCHAR2
) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    INSERT INTO error_audit1 (proc_name, error_msg, error_time)
    VALUES (p_proc_name, p_err_msg, SYSDATE);

    COMMIT; -- independent commit
EXCEPTION
    WHEN OTHERS THEN
        -- If logging itself fails, rollback only the autonomous transaction
        ROLLBACK;
END;

-- 3. Main procedure with exception handling & rollback
CREATE OR REPLACE PROCEDURE add_employee(
    p_id     IN NUMBER,
    p_name   IN VARCHAR2,
    p_salary IN NUMBER
) IS
BEGIN
    INSERT INTO employees2 (emp_id, emp_name, salary)
    VALUES (p_id, p_name, p_salary);

    COMMIT; -- for demo purposes only (avoid in real general procs)

EXCEPTION
    WHEN OTHERS THEN
        -- Rollback the main transaction
        ROLLBACK;
        
        -- Log the error (independent transaction)
        log_error('add_employee', SQLERRM);
        
        DBMS_OUTPUT.PUT_LINE('Main transaction rolled back, error logged.');
END;


-- 4. Test the procedure
BEGIN
   -- add_employee(2, 'John', 5000); -- works
    add_employee(2, 'Duplicate Key', 6000); -- will fail (PK violation)
END;


--Write a procedure dept_bonus that:

/*Takes p_dept_id (IN) and p_bonus_percentage (IN)
Increases salary for all employees in that department by the given percentage.
Prints how many employees got the bonus.
If no employees exist in that department, print "No employees in department".*/
--

create or replace procedure dept_bonus(p_dept_id          in varchar2,
                                       p_bonus_percentage in number) is
  cursor c_emp is
    select emp_id, salary
      from employees1
     where department = p_dept_id
       for update;
  v_emp_id employees1.emp_id%type;
  v_salary employees1.salary%type;
  counter  number := 0;
begin
  open c_emp;
  loop
    fetch c_emp
      into v_emp_id, v_salary;
    exit when c_emp%notfound;
    update employees1
       set salary = v_salary + (v_salary * p_bonus_percentage / 100)
    -- where emp_id = v_emp_id
     where current of c_emp;
  
    counter := counter + 1;
  end loop;
  close c_emp;
  if counter > 0 then
    dbms_output.put_line(counter || 'employee updated');
  else
    dbms_output.put_line('no record found');
  end if;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_backtrace);
end;


begin
  dept_bonus('HR', 10);
end;


--Q2  Employee Promotion Procedure
--Write a procedure promote_emp that:

--Takes p_emp_id (IN) and p_increase_amt (IN)
--Checks if employee exists  if not, raise an application error.
--Checks if new salary exceeds jobs max_salary from jobs table  if yes, raise an error.
--Updates salary and commits the change.

create or replace procedure promote_emp(p_emp_id       in number,
                                        p_increase_amt in number) is
  cursor emp is
    select e.salary, e.job_id, j.max_salary, e.employee_id
      from hr.employees e
      join hr.jobs j
        on e.job_id = j.job_id
     where employee_id = p_emp_id
       for update;

  v_salary  hr.employees.salary%type;
  v_job_id  hr.employees.job_id%type;
  v_max_sal hr.jobs.max_salary%type;
  v_emp_id  hr.employees.employee_id%type;

begin
  open emp;
  loop
    fetch emp
      into v_salary, v_job_id, v_max_sal, v_emp_id;
    exit when emp%notfound;
  
    if v_emp_id is null then
      RAISE_APPLICATION_ERROR(-20001, 'NO emp');
    end if;
  
    if p_increase_amt + v_salary > v_max_sal then
      RAISE_APPLICATION_ERROR(-20001, 'salary is greter than max_salary');
    end if;
  
    update hr.employees
       set salary = v_salary + p_increase_amt
     where current of emp;
  end loop;
  commit;

  close emp;
exception
  when others then
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;


--Q3  Employee Info Procedure with OUT Parameters
--Write a procedure get_emp_info that:

--Takes p_emp_id (IN)
--Returns employees first_name, salary, and department_name using OUT parameters.
--If employee does not exist, set all OUT parameters to "N/A".


create or replace procedure get_emp_info(p_emp_id        in number,
                                         p_first_name    out hr.employees.first_name%type,
                                         p_salary        out hr.employees.salary%type,
                                         p_department_id out hr.employees.department_id%type) is
begin
  select first_name, salary, department_id
    into p_first_name, p_salary, p_department_id
    from hr.employees
   where employee_id = p_emp_id;
  dbms_output.put_line('Employee first name: ' || p_first_name ||
                       ' Salary: ' || p_salary || ' Employee Dpt: ' ||
                       p_department_id);
exception
  when no_data_found then
    p_first_name    := 'N/A';
    p_salary        := null;
    p_department_id := null;
  
    dbms_output.put_line('Employee first name: ' || p_first_name ||
                         ' Salary: ' || p_salary || ' Employee Dpt: ' ||
                         p_department_id);
end;

declare
  v_first_name    hr.employees.first_name%type;
  v_salary        hr.employees.salary%type;
  v_department_id hr.employees.department_id%type;
begin
  get_emp_info(1021 ,v_first_name,v_salary, v_department_id);
end;

----2

create or replace procedure get_emp_info(
    p_emp_id        in number,
    p_first_name    out varchar2,
    p_salary        out varchar2,
    p_department_id out varchar2
) is
begin
    select first_name, to_char(salary), to_char(department_id)
    into p_first_name, p_salary, p_department_id
    from hr.employees
    where employee_id = p_emp_id;

    dbms_output.put_line(
        'Employee first name: ' || p_first_name ||
        ' Salary: ' || p_salary ||
        ' Employee Dpt: ' || p_department_id
    );

exception
    when no_data_found then
        p_first_name    := 'N/A';
        p_salary        := 'N/A';
        p_department_id := 'N/A';

        dbms_output.put_line(
            'Employee first name: ' || p_first_name ||
            ' Salary: ' || p_salary ||
            ' Employee Dpt: ' || p_department_id
        );
end;

----3

CREATE OR REPLACE PROCEDURE get_emp_info_cur (
    p_emp_id   IN  NUMBER,
    p_emp_cur  OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN p_emp_cur FOR
        SELECT first_name,
               salary,
               department_id
        FROM hr.employees
        WHERE employee_id = p_emp_id;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- No_data_found doesn't trigger for ref cursor, so you handle differently
        OPEN p_emp_cur FOR
            SELECT 'N/A' AS first_name,
                   NULL  AS salary,
                   NULL  AS department_id
            FROM dual;
END;

DECLARE
    v_cur SYS_REFCURSOR;
    v_fname hr.employees.first_name%TYPE;
    v_sal   hr.employees.salary%TYPE;
    v_dept  hr.employees.department_id%TYPE;
BEGIN
    get_emp_info_cur(115, v_cur);  -- Use an ID that may or may not exist
    
    LOOP
        FETCH v_cur INTO v_fname, v_sal, v_dept;
        EXIT WHEN v_cur%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE(
            'Employee Name: ' || v_fname ||
            ', Salary: ' || NVL(TO_CHAR(v_sal), 'N/A') ||
            ', Dept: ' || NVL(TO_CHAR(v_dept), 'N/A')
        );
    END LOOP;
    
    CLOSE v_cur;
END;

select * from user_objects where object_name = upper('get_emp_info');

--Q4  Country-wise Employee Count
--Write a procedure country_emp_count that:

--Takes p_country_id (IN)
--Prints total employees working in departments located in that country.
--If count is zero, print "No employees found in country".

CREATE OR REPLACE PROCEDURE country_emp_count(p_country_id IN hr.countries.country_id%TYPE) IS
    v_count NUMBER;
BEGIN
    SELECT COUNT(e.employee_id)
      INTO v_count
      FROM hr.employees e
      JOIN hr.departments d ON e.department_id = d.department_id
      JOIN hr.locations   l ON d.location_id   = l.location_id
      JOIN hr.countries   c ON l.country_id    = c.country_id
     WHERE c.country_id = p_country_id;

    IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Total employees in country ' || p_country_id || ' : ' || v_count);
    ELSE
        DBMS_OUTPUT.PUT_LINE('No employees found in country ' || p_country_id);
    END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No employees found in country ' || p_country_id);
END;

BEGIN
    country_emp_count('US');
    country_emp_count('ZW'); -- Assume no employees here
END;


--Q5  Insert Employee with Validation
--Write a procedure add_employee that:

--Takes employee details as parameters (first_name, last_name, email, phone_number, 
--hire_date, job_id, salary, department_id)
--Validates that salary is between min_salary and max_salary of the given job.
--Inserts the record into employees.
--Prints "Employee added successfully" or an error message.

CREATE OR REPLACE PROCEDURE add_employee(
    p_first_name   IN hr.employees.first_name%TYPE,
    p_last_name    IN hr.employees.last_name%TYPE,
    p_email        IN hr.employees.email%TYPE,
    p_phone_number IN hr.employees.phone_number%TYPE,
    p_hire_date    IN hr.employees.hire_date%TYPE,
    p_job_id       IN hr.employees.job_id%TYPE,
    p_salary       IN hr.employees.salary%TYPE,
    p_department_id IN hr.employees.department_id%TYPE
) IS
    v_min_salary hr.jobs.min_salary%TYPE;
    v_max_salary hr.jobs.max_salary%TYPE;
BEGIN
    -- 1. Get min and max salary for the given job
    SELECT min_salary, max_salary
    INTO v_min_salary, v_max_salary
    FROM hr.jobs
    WHERE job_id = p_job_id;

    -- 2. Validate salary
    IF p_salary < v_min_salary OR p_salary > v_max_salary THEN
        DBMS_OUTPUT.PUT_LINE('Error: Salary must be between ' ||
                             v_min_salary || ' and ' || v_max_salary ||
                             ' for job ' || p_job_id);
        RETURN;
    END IF;

    -- 3. Insert the employee
    INSERT INTO hr.employees (
        employee_id, first_name, last_name, email,
        phone_number, hire_date, job_id, salary, department_id
    ) VALUES (
        hr.employees_seq.NEXTVAL,  -- Assuming a sequence exists
        p_first_name, p_last_name, p_email,
        p_phone_number, p_hire_date, p_job_id, p_salary, p_department_id
    );

    DBMS_OUTPUT.PUT_LINE('Employee added successfully');

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error: Job ID ' || p_job_id || ' does not exist.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Unexpected error: ' || SQLERRM);
END;

SET SERVEROUTPUT ON;
BEGIN
    add_employee(
        p_first_name   => 'John',
        p_last_name    => 'Smith',
        p_email        => 'JSMITH',
        p_phone_number => '515.123.4567',
        p_hire_date    => SYSDATE,
        p_job_id       => 'IT_PROG',
        p_salary       => 6000,
        p_department_id => 60
    );
END;



--Fetch 1000 records at a time and update them in batches.
--Used in data migration scripts or large table updates.
DECLARE
  CURSOR c_emp IS SELECT employee_id FROM employees WHERE department_id = 50;
  TYPE emp_tab IS TABLE OF employees.employee_id%TYPE;
  v_emp emp_tab;
BEGIN
  OPEN c_emp;
  LOOP
    FETCH c_emp BULK COLLECT INTO v_emp LIMIT 1000;
    EXIT WHEN v_emp.COUNT = 0;

    FORALL i IN 1 .. v_emp.COUNT
      UPDATE employees
      SET salary = salary * 1.10
      WHERE employee_id = v_emp(i);

    COMMIT;
  END LOOP;
  CLOSE c_emp;
END;
---
DECLARE
  CURSOR c_parts IS SELECT part_id, part_name FROM sparepart;
  TYPE part_tab IS TABLE OF sparepart%ROWTYPE;
  v_parts part_tab;
BEGIN
  OPEN c_parts;
  LOOP
    FETCH c_parts BULK COLLECT INTO v_parts LIMIT 1000;
    EXIT WHEN v_parts.COUNT = 0;

    -- Process batch here
    FOR i IN 1 .. v_parts.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE(v_parts(i).part_id || ' - ' || v_parts(i).part_name);
    END LOOP;
  END LOOP;
  CLOSE c_parts;
END;


--Advanced Example (Multiple Columns)
DECLARE
  TYPE emp_rec IS RECORD (
    emp_id hr.employees.employee_id%TYPE,
    name   hr.employees.first_name%TYPE
  );
  TYPE emp_tab IS TABLE OF emp_rec;
  v_emp emp_tab;
BEGIN
  SELECT employee_id, first_name
  BULK COLLECT INTO v_emp
  FROM hr.employees
  WHERE department_id = 100;

  FOR i IN 1 .. v_emp.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE(v_emp(i).emp_id || ' - ' || v_emp(i).name);
  END LOOP;
END;

--Task 1  Basic BULK COLLECT
--Goal: Fetch all employee names into two separate collections and print them.

declare
  type fname_tab is table of employees_sample.first_name%type;
  type lname_tab is table of employees_sample.last_name%type;

  v_first_name fname_tab;
  v_last_name  lname_tab;

begin
  select first_name, last_name
    bulk collect
    into v_first_name, v_last_name
    from employees_sample;

  for i in 1 .. v_first_name.count loop
    DBMS_OUTPUT.PUT_LINE(v_first_name(i) || ' ' || v_last_name(i));
  END LOOP;
END;


--Task 2  BULK COLLECT with LIMIT
--Goal: Process large data in batches of 2 rows.
declare
  cursor emp_cur is
    select employee_id, first_name, salary from employees_sample;

  type emp_id_tab is table of employees_sample.employee_id%type;
  type fname_tab is table of employees_sample.first_name%type;
  type salary_tab is table of employees_sample.salary%type;

  v_ides  emp_id_tab;
  v_names fname_tab;
  v_sals  salary_tab;

begin
  open emp_cur;
  loop
    fetch emp_cur bulk collect
      into v_ides, v_names, v_sals limit 2;
    exit when v_ides.count = 0;
  
    for i in 1 .. v_ides.count loop
      DBMS_OUTPUT.PUT_LINE('ID: ' || v_ides(i) || ', Name: ' || v_names(i) ||
                           ', Salary: ' || v_sals(i));
    end loop;
  end loop;
  close emp_cur;
end;


--Task 3  BULK COLLECT into Records
--Goal: Store multiple columns into a collection of records.
declare
  type emp_rec is record(
    emp_id     employees_sample.employee_id%TYPE,
    emp_name   employees_sample.first_name%TYPE,
    emp_salary employees_sample.salary%TYPE);

  type emp_tab is table of emp_rec;
  v_emp emp_tab;

begin
  select employee_id, first_name, salary
    bulk collect
    into v_emp from employees_sample
    where department_id = 10;

  for i in 1 .. v_emp.count loop
    DBMS_OUTPUT.PUT_LINE('Emp ID: ' || v_emp(i).emp_id || ', Name: ' || v_emp(i)
                         .emp_name || ', Salary: ' || v_emp(i).emp_salary);
  end loop;
end;


--Task 4  BULK COLLECT with RETURNING Clause
--Goal: Delete employees with salary < 6000 and get their IDs in bulk.
DECLARE
    TYPE emp_id_tab IS TABLE OF employees_sample.employee_id%TYPE;
    v_deleted_ids emp_id_tab;
BEGIN
    DELETE FROM employees_sample
    WHERE salary < 6000
    RETURNING employee_id BULK COLLECT INTO v_deleted_ids;

    DBMS_OUTPUT.PUT_LINE('Deleted Employee IDs:');
            rollback;

    FOR i IN 1 .. v_deleted_ids.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE(v_deleted_ids(i));
    END LOOP;
END;

select * from employees_sample where salary < 6000


--Task 5  Real-World Batch Processing
--Goal: Increase salary by 10% for employees in dept 20 using BULK COLLECT and FORALL together.
declare
  type emp_id_tab is table of employees_sample.employee_id%type;
  type sal_tab is table of employees_sample.salary%type;

  v_ides emp_id_tab;
  v_sals sal_tab;
begin
  SELECT employee_id, salary
    BULK COLLECT
    INTO v_ides, v_sals
    FROM employees_sample
   WHERE department_id = 30;

  for i in 1 .. v_ides.count loop
    v_sals(i) := v_sals(i) * 1.10;
  end loop;

  forall i in 1 .. v_ides.count
    update employees_sample
       set salary = v_sals(i)
     where employee_id = v_ides(i);

  DBMS_OUTPUT.PUT_LINE(v_ides.COUNT || ' employees updated.');
END;

select * from employees_sample where department_id = 30 ;


--Scenario 1  Department-Wise Salary Hike with Audit
Problem:
--Increase salary of all employees in department 50 by 10%, but before updating, 
--store their current salary details in an emp_audit table.
--Why BULK COLLECT? Reduce context switches and handle updates in bulk.
create table emp_audit(
emp_id number,
dpt_id number,
salary number,
tim date );
-- This is my thinking and my answer
create or replace procedure p_emp_audit(p_emp_id in number,
                                        p_dpt_id in number,
                                        p_salary in number) is
  pragma autonomous_transaction;
begin
  insert into emp_audit
    (emp_id,dpt_id, salary, tim)
  values
    (p_emp_id,p_dpt_id, p_salary, sysdate);
  commit;
end;

create or replace procedure dpt_sal_incre(v_dpt_id in number) is
  type emp_id_tab is table of hr.employees.employee_id%type;
  type sal_tab is table of hr.employees.salary%type;
  v_emp_id emp_id_tab;
  v_sal    sal_tab;

begin
  select employee_id, salary
    bulk collect
    into v_emp_id, v_sal
    from hr.employees
   where department_id = v_dpt_id;

  for i in 1 .. v_emp_id.count loop
    p_emp_audit(v_emp_id(i), v_dpt_id, v_sal(i));
  end loop;

  for i in 1 .. v_sal.count loop
    v_sal(i) := v_sal(i) * 1.10;
  end loop;

  forall i in 1 .. v_emp_id.count
    update hr.employees
       set salary = v_sal(i)
     where employee_id = v_emp_id(i);
     
     dbms_output.put_line('all emp in dept '|| v_dpt_id || ' salary updated' ) ;

  rollback;
end;


--Scenario 2  Delete Old Job History Records in Batches
Problem:
--Delete entries from job_history where end_date is older than 2000-01-01.
--Perform deletion in batches of 100 rows using BULK COLLECT ... LIMIT.
--Why BULK COLLECT? Memory management and efficient batch delete.

declare
  cursor c_emp is
    select employee_id, end_date
      from hr.job_history
     where end_date < DATE '2000-01-01';

  type emp_tab is table of hr.job_history.employee_id%type;
  type end_date_tab is table of hr.job_history.end_date%type;

  v_emp_id   emp_tab;
  v_end_date end_date_tab;
begin
  open c_emp;
  loop
    fetch c_emp bulk collect
      into v_emp_id, v_end_date limit 2;
    exit when v_emp_id.count = 0;
  
    forall i in 1 .. v_emp_id.count
      delete from hr.job_history
       where employee_id = v_emp_id(i)
         and end_date = v_end_date(i);
  
    rollback;
  end loop;
  close c_emp;
  DBMS_OUTPUT.PUT_LINE('Old job history records deleted in batches.');
END;
---Refine code.
DECLARE
    -- Batch size constant (easy to maintain/change later)
    l_limit CONSTANT PLS_INTEGER := 100;

    CURSOR c_job IS
        SELECT employee_id, end_date
        FROM hr.job_history
        WHERE end_date < DATE '2000-01-01';

    TYPE emp_tab IS TABLE OF hr.job_history.employee_id%TYPE;
    TYPE end_date_tab IS TABLE OF hr.job_history.end_date%TYPE;

    v_emp_id   emp_tab;
    v_end_date end_date_tab;
BEGIN
    OPEN c_job;
    LOOP
        FETCH c_job BULK COLLECT INTO v_emp_id, v_end_date LIMIT l_limit;

        EXIT WHEN v_emp_id.COUNT = 0;

        FORALL i IN 1 .. v_emp_id.COUNT
            DELETE FROM hr.job_history
            WHERE employee_id = v_emp_id(i)
              AND end_date = v_end_date(i);

        COMMIT; -- Commit after each batch
    END LOOP;
    CLOSE c_job;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;


--Scenario 3  Generate Department-Wise Employee Report
Problem:
--Fetch all employees first_name, last_name, department_id and print them grouped by department.
--Why BULK COLLECT? Single fetch for better reporting performance.

declare
  type r_emp is record(
    r_fname  hr.employees.first_name%type,
    r_lname  hr.employees.last_name%type,
    r_dpt_id hr.employees.department_id%type);

  type emp_tab is table of r_emp;
  v_emp emp_tab;
begin
  select first_name, last_name, department_id
    bulk collect
    into v_emp
    from hr.employees
   order by department_id;

  for i in 1 .. v_emp.count loop
    dbms_output.put_line('First_name: ' || v_emp(i).r_fname ||
                         ' Last_name: ' || v_emp(i).r_lname || ' Dpt_id: ' || v_emp(i)
                         .r_dpt_id);
  end loop;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('No employees found.');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
end;

select * from hr.job_history ;


--Scenario 4  Copy Employees to a Backup Table
Problem:
--Copy all employees from employees table into employees_backup table in bulk.
--Why BULK COLLECT? Avoid row-by-row inserts; use FORALL for bulk inserts.

CREATE TABLE employees_backup AS
SELECT * FROM hr.employees WHERE 1=0;

DECLARE
    TYPE emp_tab IS TABLE OF hr.employees%ROWTYPE;  -- Collection of table rows
    v_emp emp_tab;

    CURSOR c_emp IS
        SELECT * FROM hr.employees;  -- Selecting full rows

    l_limit CONSTANT PLS_INTEGER := 10; -- Batch size
BEGIN
    OPEN c_emp;
    LOOP
        FETCH c_emp BULK COLLECT INTO v_emp LIMIT l_limit;

        EXIT WHEN v_emp.COUNT = 0;

        FORALL i IN 1 .. v_emp.COUNT
            INSERT INTO employees_backup VALUES v_emp(i); -- Direct row insert

        DBMS_OUTPUT.PUT_LINE(v_emp.COUNT || ' rows inserted in this batch.');
    END LOOP;
    CLOSE c_emp;

    DBMS_OUTPUT.PUT_LINE('All employees copied to employees_backup.');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

select * from employees_backup ;


--Scenario 5  Fetch Employee and Manager Names Together
Problem:
--For each employee, fetch their first_name and their managers first_name in one go 
--using BULK COLLECT into a record collection.
--Why BULK COLLECT? Efficient join processing for report generation.
DECLARE
    TYPE r_emp_mgr IS RECORD(
        emp_name   hr.employees.first_name%TYPE,
        mgr_name   hr.employees.first_name%TYPE
    );

    TYPE t_emp_mgr IS TABLE OF r_emp_mgr;
    v_data t_emp_mgr;
BEGIN
    -- Bulk collect both employee and manager names
    SELECT e.first_name AS emp_name,
           m.first_name AS mgr_name
    BULK COLLECT INTO v_data
    FROM hr.employees e
    LEFT JOIN hr.employees m
           ON e.manager_id = m.employee_id
    ORDER BY emp_name;

    -- Loop through and print
    FOR i IN 1 .. v_data.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Employee: ' || v_data(i).emp_name ||
                             ' | Manager: ' || NVL(v_data(i).mgr_name, 'No Manager'));
    END LOOP;

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;


--Write a function to return the annual salary of an employee (12  salary).

CREATE OR REPLACE FUNCTION annual_sal_f (p_emp_id NUMBER)
RETURN NUMBER
IS
  v_annual_sal NUMBER;
BEGIN
  SELECT salary * 12
  INTO   v_annual_sal
  FROM   hr.employees
  WHERE  employee_id = p_emp_id;

  RETURN v_annual_sal;
END;


BEGIN
  DBMS_OUTPUT.PUT_LINE('Annual Salary = ' || annual_sal_f(101));
END;

--Example: Function with Both RETURN and OUT Parameter

CREATE OR REPLACE FUNCTION get_salary_details 
(
    p_emp_id NUMBER, 
    p_bonus OUT NUMBER  
) RETURN NUMBER  
IS  
    v_salary NUMBER;  
BEGIN  
    -- Fetch salary of employee
    SELECT salary INTO v_salary FROM hr.employees WHERE employee_id = p_emp_id;  

    -- Calculate bonus
    p_bonus := v_salary * 0.10;  

    -- Return the actual salary
    RETURN v_salary;  
END get_salary_details;  


DECLARE  
    v_emp_id NUMBER := 101;  
    v_salary NUMBER;  
    v_bonus NUMBER;  
BEGIN  
    v_salary := get_salary_details(v_emp_id, v_bonus);  
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);  
    DBMS_OUTPUT.PUT_LINE('Bonus: ' || v_bonus);  
END;  

---Same above Q with multiple employee return
CREATE OR REPLACE FUNCTION annual_sal_multi
RETURN SYS_REFCURSOR
IS
  emp_cur SYS_REFCURSOR;  -- Cursor to return multiple rows
BEGIN
  -- Open cursor for all employees with annual salary
  OPEN emp_cur FOR
    SELECT employee_id,
           first_name || ' ' || last_name AS emp_name,
           salary * 12 AS annual_salary
    FROM hr.employees;

  RETURN emp_cur;  -- Return cursor to caller
END;

DECLARE
  v_emp_id hr.employees.employee_id%TYPE;
  v_emp_name VARCHAR2(100);
  v_annual_sal NUMBER;
  rc SYS_REFCURSOR;
BEGIN
  -- Call the function
  rc := annual_sal_multi;

  -- Fetch rows from the cursor
  LOOP
    FETCH rc INTO v_emp_id, v_emp_name, v_annual_sal;
    EXIT WHEN rc%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Emp ID: ' || v_emp_id || 
                         ' Name: ' || v_emp_name || 
                         ' Annual Salary: ' || v_annual_sal);
  END LOOP;

  CLOSE rc;  -- Close cursor
END;


--Write a function to check if a number is prime (return 'YES' or 'NO').

CREATE OR REPLACE FUNCTION f_check_prime_num(f_num NUMBER)
RETURN VARCHAR2
IS
  i NUMBER := 2;
BEGIN
  -- Handle numbers <= 1
  IF f_num <= 1 THEN
    RETURN 'NO';
  END IF;

  -- Loop from 2 to sqrt(f_num) to check divisibility
  WHILE i <= TRUNC(SQRT(f_num)) LOOP
    IF MOD(f_num, i) = 0 THEN
      RETURN 'NO'; -- Not prime
    END IF;
    i := i + 1;
  END LOOP;

  RETURN 'YES'; -- Prime
END;


DECLARE
  v_num    NUMBER := &num;
  v_result VARCHAR2(10);
BEGIN
  v_result := f_check_prime_num(v_num);
  DBMS_OUTPUT.PUT_LINE('Is ' || v_num || ' prime?  ' || v_result);
END;


--Create a function get_age(dob DATE) that returns employees age.

create or replace function get_age(dob date) return number is
  age number;
begin
    age := TRUNC(MONTHS_BETWEEN(SYSDATE, dob) / 12);
  --age := trunc(age/30)/12 ;
  return age;
end;

declare
  v_age  date := to_date('03-07-2003', 'DD-MM-YYYY');
  result number;
begin
  result := get_age(v_age);
  dbms_output.put_line('Employee Age is : ' || result || ' Years');
end;


--Create a function to return the grade of student based on marks.

create or replace function s_grade(v_marks number) return varchar2 is
begin
  if v_marks > 100 or v_marks < 0 then
    raise_application_error(-20001, 'Marks shoulb be between 1 to 100 ');
  end if;

  if v_marks >= 90 then
    return 'A';
  elsif v_marks >= 80 then
    return 'B';
  elsif v_marks >= 60 then
    return 'C';
  elsif v_marks >= 40 then
    return 'D';
  else
    return 'F';
  end if;
end;

declare
  get_marks number := &num;
  output    varchar2(20);
begin
  output := s_grade(get_marks);
  dbms_output.put_line('Student marks is ' || get_marks ||
                       ' and grade is ' || output);
end;


--Create a deterministic function that returns square of a number.                                      

create or replace function square_number(f_num number) return number
  DETERMINISTIC is
begin
  return f_num * f_num;
end;
                                 
declare
 v_num  number := &num;
 result number;
begin
 result := square_number(v_num);
 dbms_output.put_line('Square root of '||v_num || ' is ' || result);
end;
                                       
-- Define a table function that returns a table of employee records
CREATE OR REPLACE FUNCTION get_employee_records  
RETURN SYS_REFCURSOR  
IS  
    v_cursor SYS_REFCURSOR;  
BEGIN  
    OPEN v_cursor FOR  
    SELECT employee_id, salary FROM hr.employees WHERE salary > 50000;  
    RETURN v_cursor;  
END get_employee_records;  
/



DECLARE
    v_cursor SYS_REFCURSOR;
    v_emp_id NUMBER;
    v_salary NUMBER;
BEGIN
    v_cursor := get_employee_records;
    LOOP
        FETCH v_cursor INTO v_emp_id, v_salary;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_id || ', Salary: ' || v_salary);
    END LOOP;
    CLOSE v_cursor;
END;
/


--Functions that return a record consisting of multiple fields.

-- Define a record type
CREATE OR REPLACE TYPE emp_record AS OBJECT (
    empno NUMBER,
    ename VARCHAR2(50),
    salary NUMBER
);
/

-- Define the function that returns a record
CREATE OR REPLACE FUNCTION get_employee_details (p_emp_id NUMBER)  
RETURN emp_record  
IS  
    v_emp emp_record;  
BEGIN  
    SELECT employee_id, first_name, salary  
    INTO v_emp.empno, v_emp.ename, v_emp.salary  
    FROM hr.employees  
    WHERE employee_id = p_emp_id;  
    RETURN v_emp;  
END get_employee_details;  
/


DECLARE
    v_emp emp_record;
BEGIN
    v_emp := get_employee_details(101);
    DBMS_OUTPUT.PUT_LINE('Emp No: ' || v_emp.empno || ', Name: ' || v_emp.ename || ', Salary: ' || v_emp.salary);
END;                                       


--Example: Function with Both RETURN and OUT Parameter

CREATE OR REPLACE FUNCTION get_salary_details 
(
    p_emp_id NUMBER, 
    p_bonus OUT NUMBER  
) RETURN NUMBER  
IS  
    v_salary NUMBER;  
BEGIN  
    -- Fetch salary of employee
    SELECT salary INTO v_salary FROM hr.employees WHERE employee_id = p_emp_id;  

    -- Calculate bonus
    p_bonus := v_salary * 0.10;  

    -- Return the actual salary
    RETURN v_salary;  
END get_salary_details;  
/

DECLARE  
    v_emp_id NUMBER := 101;  
    v_salary NUMBER;  
    v_bonus NUMBER;  
BEGIN  
    v_salary := get_salary_details(v_emp_id, v_bonus);  
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);  
    DBMS_OUTPUT.PUT_LINE('Bonus: ' || v_bonus);  
END;  

--Q.6 write a procedure to first check table is present or not if not then create that table if present 
--then drop it and then create


  create or replace procedure to_check_table(t_name in varchar2) is
    v_count number;
  begin
    select count(*) into v_count from user_tables where table_name = upper(t_name);

    if v_count > 0 then
      execute immediate 'drop table ' || t_name;
      dbms_output.put_line('Existing table deleted');
      end if;
    if v_count >= 0 then
      execute immediate 'create table ' || t_name ||
                        '(x number,y varchar2(50))';
      dbms_output.put_line('New table created');
    end if;

  exception
    when others then
      dbms_output.put_line(dbms_utility.format_error_backtrace ||
                           dbms_utility.format_error_stack);
    
  end;

begin
  to_check_table('test000');
end;



--     7. Exception behavior inside trigger vs procedure
Practice Task:

--Create a trigger that raises a custom exception.
--Observe how it behaves in DML and whether rollback occurs.


create table t_trigger_test (
id number primary key,
x number );

create or replace trigger trg_raise
  before insert on t_trigger_test
  for each row 
begin
  if :NEW.x > 100 then
    raise_application_error(-20001, 'value of x must < 100 ');
  end if;
end;
  
  insert into t_trigger_test values (101 ,60 ) ; --valid
    insert into t_trigger_test values (102 ,160 ) ; --invalid

select * from t_trigger_test ;


-- Q: What happens when the trigger raises an exception during DML?
A: If the trigger raises an exception (via RAISE_APPLICATION_ERROR), the entire DML statement fails and is
   rolled back. In this example, the insert with x=160 is rejected, and no row is inserted.
   
-- Q: Does the whole transaction roll back?
A: No. Only the failing statement is rolled back. Any prior successful inserts in the same transaction remain
   pending until explicitly committed or rolled back. Example: the row (101, 60) stays valid.
   
-- Q: How is this different from a procedure?
A:
   In a trigger, if an exception is unhandled, the DML fails and is rolled back.
   In a procedure, you can catch the exception inside EXCEPTION block. That allows you to log it or
   continue other logic  but the DML statement that caused the error is still rolled back.
   
-- Q: What is shown by your test?
A: After both inserts, a SELECT shows only one row (101, 60). The second insert failed because
   of the triggers exception.


--     8. Use of AUTONOMOUS_TRANSACTION
Practice Task:

--Create an audit log trigger using PRAGMA AUTONOMOUS_TRANSACTION.
CREATE OR REPLACE TRIGGER trg_pragma
  AFTER DELETE ON emp_2
  FOR EACH ROW
DECLARE
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO delete_audit (empno, deleted_at)
  VALUES (:OLD.empno, SYSTIMESTAMP);

  COMMIT;
END;

--Here we use PRAGMA AUTONOMOUS_TRANSACTION in the delete trigger so that audit log entries are 
--committed independently, even if the main delete operation is later rolled back.


--     9. Mutating Table Problem
Practice Task:

--Create a trigger that reads from the same table its modifying (BEFORE UPDATE).
--Observe error: table is mutating, trigger/function may not see it

CREATE TABLE emp_2 (
  empno  NUMBER PRIMARY KEY,
  ename  VARCHAR2(50),
  deptno NUMBER,
  sal    NUMBER
);

INSERT INTO emp_2 VALUES (1,'A',10,1000);
INSERT INTO emp_2 VALUES (2,'B',10,1200);
INSERT INTO emp_2 VALUES (3,'C',20,1500);
COMMIT;

CREATE OR REPLACE TRIGGER trg_emp_mutate
AFTER UPDATE OF sal ON emp_2
FOR EACH ROW
DECLARE
  v_avg NUMBER;
BEGIN
  -- This SELECT on emp_2 inside a row-level trigger causes ORA-04091
  SELECT AVG(sal) INTO v_avg FROM emp_2 WHERE deptno = :NEW.deptno;
  NULL;
END;

UPDATE emp_2 SET sal = sal + 100 WHERE deptno = 10;
-- Expect ORA-04091: table EMP_2 is mutating, trigger/function may not see it

--Explanation: the row-level trigger selects from the same table while its being changed row-by-row  
--Oracle disallows it (mutating table)


--     10. FORALL and BULK COLLECT Exception Handling
Practice Task:

--Use FORALL with SAVE EXCEPTIONS.
--Use BULK COLLECT INTO and process in a loop.


CREATE TABLE emp_2 (
  empno  NUMBER PRIMARY KEY,
  ename  VARCHAR2(50),
  deptno NUMBER,
  sal    NUMBER
);

INSERT INTO emp_2 VALUES (1,'A',10,1000);
INSERT INTO emp_2 VALUES (2,'B',10,1200);
INSERT INTO emp_2 VALUES (3,'C',20,1500);
INSERT INTO emp_2 VALUES (4,'D',20,1600);
INSERT INTO emp_2 VALUES (5,'E',30,1400);
COMMIT;

CREATE TABLE emp_target (
  empno  NUMBER PRIMARY KEY,
  ename  VARCHAR2(50),
  deptno NUMBER,
  sal    NUMBER
);

-- insert one row to force a PK conflict later (to demonstrate SAVE EXCEPTIONS)
INSERT INTO emp_target VALUES(2,'B',10,1200);
COMMIT;

SELECT * FROM emp_2;
SELECT * FROM emp_target;

DECLARE
  TYPE t_emp_rec IS TABLE OF emp_2%ROWTYPE;
  l_emps t_emp_rec;
BEGIN
  -- bulk fetch rows into collection
  SELECT * BULK COLLECT INTO l_emps FROM emp_2 WHERE deptno IN (10,20);

  DBMS_OUTPUT.PUT_LINE('Rows collected: ' || l_emps.COUNT);

  -- process collection in a PL/SQL loop (safe, in-memory)
  FOR i IN 1 .. l_emps.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Row ' || i || ' -> empno=' || l_emps(i).empno
                         || ', ename=' || l_emps(i).ename
                         || ', sal=' || l_emps(i).sal);
    -- example processing: you can compute, validate, or transform here
  END LOOP;
END;


--Write a cursor to fetch all employees from emp_2 and display their names and salaries.

select * from emp_2 ;

declare
cursor emp is 
select ename,sal from emp_2 ;
v_name emp_2.ename%type ;
v_sal emp_2.sal%type ;
begin
  open emp ;
  loop
    fetch emp into v_name,v_sal ;
    exit when emp%notfound;
    dbms_output.put_line('Empname : ' || v_name || ' And salary is : '|| v_sal) ;
end loop;
close emp;
end;


--Write a cursor FOR loop to fetch employee details without OPEN/FETCH/CLOSE.

begin
  for i in (select empno, ename, sal from emp_2) loop
    dbms_output.put_line(i.empno || ' ' || i.ename || ' ' || i.sal);
  end loop;
end;


--Write a parameterized cursor that fetches employees by department number.

declare
  cursor emp(v_dpt number) is
    select ename, sal from emp_2 where deptno = v_dpt;

  v_name emp_2.ename%type;
  v_sal  emp_2.sal%type;
begin
  open emp(10);
  loop
    fetch emp
      into v_name, v_sal;
    exit when emp%notfound;
    dbms_output.put_line(v_name || ' ' || v_sal);
  end loop;
  close emp;
end;
    

--Return a result set using REF CURSOR.

declare
  type emp_r is record(
    v_name emp_2.ename%type,
    v_sal  emp_2.sal%type);

  type c_emp is ref cursor return emp_r;
  cur   c_emp;
  v_cur emp_r;
begin
  open cur for
    select ename, sal from emp_2;

  loop
    fetch cur
      into v_cur;
    exit when cur%notfound;
    dbms_output.put_line(v_cur.v_name || ' ' || v_cur.v_sal);
  end loop;
  close cur;
end;


declare
  type c_emp is ref cursor;
  cur    c_emp;
  v_name emp_2.ename%type;
  v_sal  emp_2.sal%type;
begin
  open cur for
    select ename, sal from emp_2;
  loop
    fetch cur
      into v_name, v_sal;
    exit when cur%notfound;
    dbms_output.put_line(v_name || ' ' || v_sal);
  end loop;
  close cur;
end;


--Demonstrate %ROWCOUNT and %FOUND.
DECLARE
  CURSOR c_emp IS SELECT ename FROM emp_2;
  v_name emp_2.ename%TYPE;
BEGIN
  OPEN c_emp;
  LOOP
    FETCH c_emp INTO v_name;
    EXIT WHEN c_emp%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Row ' || c_emp%ROWCOUNT || ': ' || v_name);
  END LOOP;
  CLOSE c_emp;
END;


--Increase salary of employees in HR dept by 500 using cursor.

declare
  cursor emp is
    select ename, sal from emp_2 where deptno = 20 for update;
  v_name emp_2.ename%type;

  v_sal emp_2.sal%type;

  update_sal number := 500;
begin
  open emp;
  loop
    fetch emp
      into v_name, v_sal;
    exit when emp%notfound;
    dbms_output.put_line('Emp : ' || v_name ||
                         ', Salary before updating is : ' || v_sal);
    update_sal := update_sal + v_sal;
    update emp_2 set sal = v_sal + 500 where current of emp;
  
    dbms_output.put_line('Emp : ' || v_name ||
                         ', Salary after updating is : ' || update_sal);
    update_sal := 500;
  end loop;
  close emp;

end;


--Handle NO_DATA_FOUND and TOO_MANY_ROWS with cursors.
DECLARE
  CURSOR c_one IS SELECT ename FROM emp_2 WHERE empno = 999; -- No row
  v_name emp_2.ename%TYPE;
BEGIN
  OPEN c_one;
  FETCH c_one INTO v_name;
  IF c_one%NOTFOUND THEN
    DBMS_OUTPUT.PUT_LINE('No employee found!');
  END IF;
  CLOSE c_one;
END;



--Fetch all employee names into a collection.

declare
  type t_name is table of emp_2.ename%type;
  v_names t_name;
  cursor c_emp is
    select ename from emp_2;
begin
  open c_emp;
  fetch c_emp bulk collect
    into v_names;

  for i in 1 .. v_names.count loop
    DBMS_OUTPUT.PUT_LINE('Employee: ' || v_names(i));
  END LOOP;
END;
  

--For each department, fetch all employees using a nested cursor.

DECLARE
  CURSOR c_dept IS SELECT deptno, dname FROM dept;
  CURSOR c_emp(p_deptno NUMBER) IS
    SELECT ename, sal FROM emp_2 WHERE deptno = p_deptno;
BEGIN
  FOR d IN c_dept LOOP
    DBMS_OUTPUT.PUT_LINE('Department: ' || d.dname);
    FOR e IN c_emp(d.deptno) LOOP
      DBMS_OUTPUT.PUT_LINE('-- ' || e.ename || ' (' || e.sal || ')');
    END LOOP;
  END LOOP;
END;


--Update salaries using cursor inside a trigger  observe mutating error.

CREATE OR REPLACE TRIGGER trg_mutate
BEFORE UPDATE ON emp_2
FOR EACH ROW
DECLARE
  CURSOR c IS SELECT sal FROM emp_2;  -- reads same table
  v_sal NUMBER;
BEGIN
  OPEN c;
  FETCH c INTO v_sal; --  Mutating table error
  CLOSE c;
END;

--Answer: Mutating occurs because cursor reads from the same table being modified in row-level trigger.


--Update multiple rows with bulk processing, handle errors per row.

DECLARE
  TYPE t_emp IS TABLE OF emp_2.empno%TYPE;
  v_empnos t_emp := t_emp(1, 2, 999); -- 999 doesnt exist
BEGIN
  FORALL i IN v_empnos.FIRST..v_empnos.LAST SAVE EXCEPTIONS
    UPDATE emp_2 SET sal = sal + 100 WHERE empno = v_empnos(i);

EXCEPTION
  WHEN OTHERS THEN
    FOR i IN 1..SQL%BULK_EXCEPTIONS.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE('Error at index '|| SQL%BULK_EXCEPTIONS(i).ERROR_INDEX ||
                           ' Code: ' || SQL%BULK_EXCEPTIONS(i).ERROR_CODE);
    END LOOP;
END;

--Answer: With SAVE EXCEPTIONS, bulk DML continues even if some rows fail.


--Write a procedure returning employees of a department using REF CURSOR.

CREATE OR REPLACE PROCEDURE get_emp_dept(
  p_deptno IN NUMBER,
  p_cursor OUT SYS_REFCURSOR) IS
BEGIN
  OPEN p_cursor FOR SELECT ename, sal FROM emp_2 WHERE deptno = p_deptno;
END;


--Log every fetch into an audit table.

CREATE TABLE fetch_audit(empno NUMBER, fetched_at TIMESTAMP);

DECLARE
  CURSOR c IS SELECT empno FROM emp_2;
  v_id emp_2.empno%TYPE;
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_id;
    EXIT WHEN c%NOTFOUND;
    INSERT INTO fetch_audit VALUES(v_id, SYSTIMESTAMP);
    COMMIT;
  END LOOP;
  CLOSE c;
END;


--Fetch rows from table name passed as parameter.

DECLARE
  TYPE ref_cur IS REF CURSOR;
  c ref_cur;
  v_name VARCHAR2(50);
BEGIN
  OPEN c FOR 'SELECT ename FROM emp_2 WHERE deptno = :x' USING 10;
  LOOP
    FETCH c INTO v_name;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_name);
  END LOOP;
  CLOSE c;
END;


--Fetch entire row without declaring each column separately.

DECLARE
  CURSOR c IS SELECT * FROM emp_2;
  v_emp c%ROWTYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_emp;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Emp: ' || v_emp.ename || ' Salary: ' || v_emp.sal);
  END LOOP;
  CLOSE c;
END;



-For optimized paging in Oracle, Id use an analytic function like ROW_NUMBER(). The procedure calculates 
--start and end row numbers based on the page input, then selects only those rows. This way, we avoid 
--loading the entire table into memory and fetch only 10 records per page. This approach is scalable
--to millions of rows, provided the ORDER BY column is indexed.


-- Sample table with millions of rows
CREATE TABLE employees_big (
  emp_id    NUMBER PRIMARY KEY,
  emp_name  VARCHAR2(100),
  salary    NUMBER
);

-- Insert some dummy rows (just for demo we insert 100, but in real scenario this could be millions)
BEGIN
  FOR i IN 1..100 LOOP
    INSERT INTO employees_big VALUES (i, 'Employee_'||i, 1000 + i);
  END LOOP;
  COMMIT;
END;

select count(*) from employees_big ;

create or replace procedure get_employee_pages(p_page_number in number) is
  v_start_row number;
  v_end_row   number;
begin
  -- Calculate row boundaries
  v_start_row := (p_page_number - 1) * 10 + 1;
  v_end_row   := p_page_number * 10;

  for rec in (select emp_id, emp_name, salary
                from (SELECT emp_id,
                             emp_name,
                             salary,
                             ROW_NUMBER() OVER(ORDER BY emp_id) AS rn
                        FROM employees_big)
               where rn between v_start_row and v_end_row) loop
    DBMS_OUTPUT.PUT_LINE(rec.emp_id || ' - ' || rec.emp_name || ' - ' ||
                         rec.salary);
  END LOOP;
END;

begin
get_employee_pages(1);
end;


begin
get_employee_pages(4);
end;
--Way2

create or replace procedure get_employee_page_keyset(
    p_page_size in number,
    p_after_id in number,
    p_cursor out sys_refcursor
    ) as
    begin
    open p_cursor for select * from employees_big
    where (p_after_id is null or  emp_id > p_after_id)
    order by emp_id
    fetch first p_page_size rows only;
    
    end;
    /
    --call:
    declare
    p_size number:=&p_size;
    after_id number:=&after_id;
    emp_cur sys_refcursor;
    v_emp employees_big%rowtype;
    begin
       get_employee_page_keyset(p_size,after_id,emp_cur);
    loop
    fetch emp_cur into v_emp;
    exit when emp_cur%notfound;
    dbms_output.put_line(v_emp.emp_id||' [ '|| v_emp.emp_name||v_emp.salary);
    end loop;
    close emp_cur;
    end;


--4.Build a Comma-Separated List
-- Return all department names for an employee as a single comma-separated string using only PL/SQL.

DECLARE
    v_employee_id NUMBER := 109; -- Replace with actual employee ID
    v_department_list VARCHAR2(4000);
BEGIN
    -- Since employees belong to one department directly, we get department name
    SELECT d.department_name
    INTO v_department_list
    FROM hr.employees e
    JOIN hr.departments d ON e.department_id = d.department_id
    WHERE e.employee_id = v_employee_id;
    
    DBMS_OUTPUT.PUT_LINE('Department: ' || NVL(v_department_list, 'No department assigned'));

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Employee not found or has no department');
END;

select * FROM hr.employees ;

--way2
DECLARE
    CURSOR emp_cur IS
        SELECT e.employee_id, e.first_name, e.last_name, d.department_name
        FROM hr.employees e
        LEFT JOIN hr.departments d ON e.department_id = d.department_id
        WHERE e.employee_id IN (100, 101, 102) -- Specific employees
        ORDER BY e.employee_id;
        
    v_output VARCHAR2(4000);
BEGIN
    FOR emp_rec IN emp_cur LOOP
        v_output := emp_rec.employee_id || ' - ' || 
                   emp_rec.first_name || ' ' || emp_rec.last_name || 
                   ': ' || NVL(emp_rec.department_name, 'No Department');
        DBMS_OUTPUT.PUT_LINE(v_output);
    END LOOP;
END;
/
---
CREATE OR REPLACE PROCEDURE p1(dpt_id IN NUMBER) IS
  CURSOR cur IS
    SELECT e.first_name, d.department_name
      FROM hr.employees e
      JOIN hr.departments d
        ON e.department_id = d.department_id
     WHERE e.department_id = dpt_id;

  v_name     hr.employees.first_name%TYPE;
  v_dpt_name hr.departments.department_name%TYPE;

BEGIN
  OPEN cur;
  LOOP
    FETCH cur INTO v_name, v_dpt_name;
    EXIT WHEN cur%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name || ',' || v_dpt_name);
  END LOOP;
  CLOSE cur;
END;

BEGIN
  p1(10);  -- replace 10 with an actual department_id from hr.employees
END;


--5.Conditional Merge with Audit
--Perform a MERGE only if the row has changed, and log old vs new values in an audit table.


-- Main table
CREATE TABLE employees_main (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(50),
    salary NUMBER
);

-- Audit table
CREATE TABLE employees_audit (
    audit_id   NUMBER PRIMARY KEY,
    emp_id     NUMBER,
    old_name   VARCHAR2(50),
    new_name   VARCHAR2(50),
    old_salary NUMBER,
    new_salary NUMBER,
    change_date DATE DEFAULT SYSDATE
);


INSERT INTO employees_main VALUES (1, 'John', 5000);
INSERT INTO employees_main VALUES (2, 'Alice', 6000);

DECLARE
    v_old_name employees_main.emp_name%TYPE;
    v_old_salary employees_main.salary%TYPE;
    v_emp_exists NUMBER;
BEGIN
    -- Check if employee exists
    SELECT COUNT(*) INTO v_emp_exists
    FROM employees_main
    WHERE emp_id = 1;

    IF v_emp_exists = 1 THEN
        -- Employee exists, get old values
        SELECT emp_name, salary
        INTO v_old_name, v_old_salary
        FROM employees_main
        WHERE emp_id = 1;

        -- Only update if values have changed
        IF v_old_name <> 'John' OR v_old_salary <> 5500 THEN
            UPDATE employees_main
            SET emp_name = 'John',
                salary   = 5500
            WHERE emp_id = 1;

            -- Log old vs new in audit table
            INSERT INTO employees_audit(emp_id, old_name, new_name, old_salary, new_salary)
            VALUES (1, v_old_name, 'John', v_old_salary, 5500);
        END IF;

    ELSE
        -- Employee does not exist, insert
        INSERT INTO employees_main(emp_id, emp_name, salary)
        VALUES (1, 'John', 5500);
    END IF;

    COMMIT;
END;

--6.Retry Logic with Exception Tracking
-- Write a procedure that retries a failed DML up to 3 times and logs the error each time with timestamp.

create table dml_error_log (
    log_id      number primary key,
    dml_type    varchar2(10),
    error_msg   varchar2(4000),
    attempt_no  number,
    log_date    timestamp default systimestamp
);
--procedure:

create or replace procedure retry_update(
p_empid in number,
p_salary in number
)as
v_attempts number:=0;
begin
loop
    v_attempts:=v_attempts+1;
    begin
       update employees
       set salary=p_salary
       where employee_id=p_empid;
       
       exit; --exit loop
       
     exception 
         when others then
          
          if v_attempts>=3 then
            insert into dml_error_log(dml_type, error_msg, attempt_no)
          values('UPDATE', sqlerrm, v_attempts);
          raise;
          end if;
        end;  
       end loop;
       
     end;
     /
     
  --call:
  
  declare
   v_empid number:=&eid;
   v_salary number:=&sal;
   begin
   retry_update(v_empid,v_salary);
   
   end;



--7.Dynamic Column Fetcher
--Write a procedure that takes table name and column name as input, and returns distinct values from that column

CREATE OR REPLACE PROCEDURE dynamic_column_fetcher (
    p_table_name  IN VARCHAR2,
    p_column_name IN VARCHAR2
) IS
    v_sql   VARCHAR2(1000);
    v_value VARCHAR2(4000);
    v_cur   SYS_REFCURSOR;
BEGIN
    -- Build dynamic SQL
    v_sql := 'SELECT DISTINCT ' || p_column_name ||
             ' FROM ' || p_table_name;

    -- Open cursor for dynamic SQL
    OPEN v_cur FOR v_sql;

    LOOP
        FETCH v_cur INTO v_value;
        EXIT WHEN v_cur%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE(v_value);
    END LOOP;

    CLOSE v_cur;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END dynamic_column_fetcher;
/


SET SERVEROUTPUT ON;

BEGIN
    -- Fetch distinct job IDs
    dynamic_column_fetcher('HR.EMPLOYEES', 'JOB_ID');

    -- Fetch distinct department IDs
    dynamic_column_fetcher('HR.EMPLOYEES', 'DEPARTMENT_ID');
END;


--8.Nested JSON Builder in PL/SQL
-- Using only PL/SQL, build a nested JSON object of departments and their employees.


--9.Avoid Mutating Table Error
-- Explain a way to update the same table inside a row-level trigger, without hitting the mutating table error.

create table employees as select * from hr.employees;

select * from employees ;


create or replace trigger trg_emp_salary
      after update on employees
      for each row
      begin
        update employees
        set salary=salary*1
        where employee_id=:new.employee_id;
     end;
     /
     drop trigger trg_emp_salary ;
     ------Compound trigger (row-level info collection and statement-level section )
     create or replace trigger trg_emp_bonus
for update on employees
compound trigger

    -- Collection to store affected employee ids
    type emp_tab_type is table of employees.emp_id%type;
    emp_tab emp_tab_type := emp_tab_type();

-- Row-level section: capture affected rows
before each row is
begin
    emp_tab.extend;
    emp_tab(emp_tab.count) := :new.emp_id;
end before each row;

-- Statement-level section: update safely
after statement is
begin
    for i in 1..emp_tab.count loop
        update employees
        set salary = salary * 1.1
        where emp_id = emp_tab(i);
    end loop;
end after statement;

end;


----------------------------------------------------------------------------------------------------------------
=========================================PL/SQL=================================================================

SET SERVEROUTPUT ON;

DECLARE
  user_age NUMBER := 17; -- Example value
BEGIN
  dbms_output.put_line(
    CASE
      WHEN user_age <= 18 THEN '18 or less'
    END
  );
END;
/

DECLARE
  user_age NUMBER := 20; -- Another example value
BEGIN
  dbms_output.put_line(
    CASE
      WHEN user_age <= 18 THEN '18 or less'
    END
  );
END;
/


BEGIN
    BEGIN
        dbms_output.put_line('Hi this my first program un named plsql block :- ' || 100 / 10);
    EXCEPTION
        WHEN OTHERS THEN
            -- Optional
            dbms_output.put_line('Err:-'
                                 || dbms_utility.format_error_stack
                                 || dbms_utility.format_error_backtrace);
    END;

    BEGIN
        dbms_output.put_line('Hi this my first program un named plsql block :- ' || 100 / 0);
    END;
EXCEPTION
    WHEN OTHERS THEN
        -- Optional
        dbms_output.put_line('Err:-'
                             || dbms_utility.format_error_stack
                             || dbms_utility.format_error_backtrace);
END;

----18-05-2025  Sunday-----------------------------------------------------------------------------------

DECLARE
  var_sal number := 100;
BEGIN
  select salary into var_sal from hr.employees where rownum<2;
  dbms_output.put_line('Salary:- ' || var_sal);
END;
/

DECLARE
  var_sal number := 100;
  var_name varchar2(100);
BEGIN
  select salary,first_name into var_sal,var_name from sys.employees where rownum<2;
  dbms_output.put_line('Salary of :- ' || var_name || ' :- ' || var_sal);
END;
/

DECLARE
  var_sal NUMBER := 100;
  var_name VARCHAR2(50);
  var_last_name sys.employees.last_name%TYPE;
BEGIN
  SELECT
    salary,
    first_name
  INTO
    var_sal,
    var_name
  FROM
    sys.employees
  WHERE
    ROWNUM < 2;
  dbms_output.put_line('Salary of :- ' || var_name || ' :- ' || var_sal);
END;
/

DECLARE
  var_sal NUMBER := 100;
  var_name VARCHAR2(50);
  var_last_name sys.employees.last_name%TYPE;
  c_constant constant varchar2(100) := 'ABCD';
BEGIN
  SELECT
    salary,
    first_name
  INTO
    var_sal,
    var_name
  FROM
    sys.employees
  WHERE
    ROWNUM < 2;
  dbms_output.put_line('Salary of :- ' || var_name || ' :- ' || var_sal);
END;
/

--Start : Conditional Statement
IF var_sal <= 9000 THEN
  dbms_output.put_line('Salary is not upto market standards');
END IF;

IF var_sal <= 9000 THEN
  dbms_output.put_line('Salary is not upto market standards');
ELSE
  IF var_sal > 10000 THEN
    dbms_output.put_line('Salary is upto some market standards');
  ELSE
    IF var_sal > 2000 THEN
      dbms_output.put_line('Salary is upto market standards');
    ELSE
      dbms_output.put_line('Salary is not in any staandard measured');
    END IF;
  END IF;
END IF;
--End : Conditional Statement
END;
/


IF var_sal <= 9000 THEN
  dbms_output.put_line('Salary is not upto market standards');
ELSIF var_sal BETWEEN 10000 AND 20000 THEN
  dbms_output.put_line('Salary is upto some market standards');
ELSIF var_sal BETWEEN 20000 AND 30000 THEN
  dbms_output.put_line('Salary is upto market standards');
ELSE
  dbms_output.put_line('Salary is not in any staandard measured');
END IF;

var_sal :=
CASE
  WHEN var_sal = 9000 THEN
    200000
  WHEN var_sal = 200000 THEN
    500000
END;

--Start : Loops
declare
var_sal := 1;
begin
loop
  dbms_output.put_line('Simple Loop ');
  exit when var_sal=10;
  var_sal := var_sal+1;
end loop;
--End : Loops
END;
/

var_sal := 1;
while var_sal <= 10 loop
  dbms_output.put_line('while Loop:- ' || var_sal);
  var_sal := var_sal+1;
end loop;
--End : Loops
END;
/

for i in 1 .. 10 loop
  dbms_output.put_line('for Loop:- ' || i);
end loop;
--End : Loops
END;
/


DECLARE
  var_id         NUMBER;
  var_first_name VARCHAR2(20);
BEGIN
  SELECT first_name, salary
    INTO var_first_name, var_id
    FROM hr.employees;
   WHERE employee_id = 101;
  dbms_output.put_line(var_id);
  IF var_id <= 15000 THEN
    dbms_output.put_line('salary is less current standard');
  ELSIF var_id > 15000 THEN
    dbms_output.put_line('salary is current standard');
  end if;
  IF var_first_name = 'Neena' THEN
    dbms_output.put_line('employee name is correct');
  ELSE
    dbms_output.put_line('employee name is not correct');
  END IF;
END;

-- Using & for single-use variables
DECLARE
  v_name VARCHAR2(100) := '&input_name';
  v_age NUMBER := &input_age;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello ' || v_name || ', you are ' || v_age || ' years old.');
END;
/

-----
--Check if a number is positive or negative.
--Declare a number and print whether it is positive, negative, or zero.
declare
  value1 number := &inpute_number;
begin
  if value1 > 0 then
    dbms_output.put_line('Number is a positive');
  elsif value1 = 0 then
    dbms_output.put_line('Number is a ZERO');
  else
    dbms_output.put_line('Number is a negtive');
  end if;
end;

--Determine if a number is even or odd.
--Use the MOD function to check.
declare
  value1 number := &inpute_number;
begin
  if mod(value1, 2) = 0 then
    dbms_output.put_line('Number is a even');
  else
    dbms_output.put_line('Number is a odd');
  end if;
end;

--Check if a person is eligible to vote.
--If age  18  eligible, else  not eligible.
declare
  age number := &inpute_age;
begin
  if age >= 18 then
    dbms_output.put_line('Person can vote');
  else
    dbms_output.put_line('person can not vote');
  end if;
end;

--Assign grade based on marks.
--Use IF...ELSIF...ELSE to assign a grade (A/B/C/F).
declare
  marks number := &inpute_marks;
begin
  if marks > 80 then
    dbms_output.put_line('student got A grade');
  elsif marks > 60 and marks <= 80 then
    dbms_output.put_line('student got B grade');
  elsif marks > 40 and marks <= 60 then
    dbms_output.put_line('student got C grade');
  else
    dbms_output.put_line('student got F grade');
  end if;
end;


--Use CASE to display the name of a day.
--Input a number (1 to 7), and print the corresponding day (1 = Monday, etc.).

declare
  days number := &inpute_day;
begin
  case
    when days = 1 then
      dbms_output.put_line('Sunday');
    when days = 2 then
      dbms_output.put_line('Monday');
    when days = 3 then
      dbms_output.put_line('Tuesday');
    when days = 4 then
      dbms_output.put_line('Wednesday');
    when days = 5 then
      dbms_output.put_line('Thursday');
    when days = 6 then
      dbms_output.put_line('Friday');
    when days = 7 then
      dbms_output.put_line('Satuarday');
    else
      dbms_output.put_line('value should be less than 7 and greter than 0');
  end case;
end;

--loop
--simple loop
--Print numbers from 1 to 10 using a LOOP.
--Use a counter and EXIT WHEN condition.

DECLARE
    counter NUMBER := 1;
BEGIN
    LOOP
        dbms_output.put_line(counter);
        counter := counter + 1;
        EXIT WHEN counter > 10;
    END LOOP;
END;

--Calculate the sum of numbers from 1 to 100 using a LOOP.
--Keep adding the counter to a total variable.
declare
  total   number := 0;
  counter number := 0;
begin
  loop
    total   := total + counter;
    counter := counter + 1;
    exit when counter > 100;
  end loop;
  dbms_output.put_line(total);
end;


--Print the multiplication table of 5 using a LOOP.
--Example: 5  1 = 5 ... 5  10 = 50

declare
  m_table number := 5;
  counter number := 1;
  v_num   number;
begin
  loop
    v_num := m_table * counter;
    DBMS_OUTPUT.PUT_LINE(m_table || '  ' || counter || ' = ' || v_num);
    counter := counter + 1;
    exit when counter > 10;
  end loop;
end;


--Count and display how many even numbers are between 1 and 20 using a LOOP.
--Use MOD to check for even numbers.

DECLARE
    counter     NUMBER := 1;
    even_count  NUMBER := 0;
BEGIN
    LOOP
        IF MOD(counter, 2) = 0 THEN
            dbms_output.put_line('Even number: ' || counter);
            even_count := even_count + 1;
        END IF;

        counter := counter + 1;
        EXIT WHEN counter > 20;
    END LOOP;

    dbms_output.put_line('Total even numbers between 1 and 20: ' || even_count);
END;


--Print the factorial of a number (e.g., 5) using a LOOP.
--5! = 5  4  3  2  1
DECLARE
    num       NUMBER := 6;    
    result    NUMBER := 1;  --1 ,2,6,24,120,720
    counter   NUMBER := 1;   --2,3,4,5,6
BEGIN
    LOOP
        result := result * counter; --1*1 ,
        counter := counter + 1;    --1+1,
        EXIT WHEN counter > num;   --5 
    END LOOP;

    dbms_output.put_line('Factorial of ' || num || ' is: ' || result);
END;

----19-05-2025  Monday-----------------------------------------------------------------------------------

--while loop

--the WHILE loop is a control structure used in PL/SQL (not regular SQL) that repeatedly executes a block of code
--as long as a specified condition is TRUE.

DECLARE
  i NUMBER := 1;
BEGIN
  WHILE i <= 5 LOOP
    DBMS_OUTPUT.PUT_LINE('Value: ' || i);
    i := i + 1;
  END LOOP;
END;

declare
  var_sal number := 1; --2,3,4
begin
  while var_sal <= 10 loop
    dbms_output.put_line('while Loop:- ' || var_sal); --1,2,3,
    var_sal := var_sal + 1;
  end loop;
end;
--
DECLARE
  n NUMBER := 5; --4,3,2
  fact NUMBER := 1;
BEGIN
  WHILE n > 0 LOOP
    fact := fact * n; --1*5=5,5*4=20,60,120
    n := n - 1;
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('Factorial: ' || fact);
END;
--Q
--Q1. Print Even Numbers from 2 to 10
--Write a PL/SQL block using a WHILE loop that prints even numbers between 2 and 10.

declare
  a number := 2;
begin
  while a <= 10 loop
    if mod(a, 2) = 0 then
      dbms_output.put_line('Even number between 2 to 10 = ' || a);
    end if;
    a := a + 1;
  end loop;
end;

--Q2. Sum of First N Natural Numbers
--Declare a variable n := 5. Use a WHILE loop to calculate the sum of the first n natural numbers 
--and display the result

declare
  n      number := 5;--5,4,3,2,1
  result number := 0; --5,9,
begin
  while n > 0 loop
    result := n + result; --5+0=5,5+4=9=,9+3=12,12+2=14,14+1=15
    n      := n - 1;
  end loop;
  dbms_output.put_line('Sum of First 5 N Natural Numbers = ' || result);
end;

declare
  n      number := 1;
  result number := 0; 
begin
  while n <= 5 loop
    result := n + result; 
    n      := n + 1;
  end loop;
  dbms_output.put_line('Sum of First 5 N Natural Numbers = ' || result);
end;

--Q3. Reverse a Number
--Given a number 1234, write a PL/SQL block that uses a WHILE loop to reverse the number (output: 4321).

DECLARE
  num       NUMBER := 1234;
  reversed  NUMBER := 0; --4
  digit     NUMBER;  --43
BEGIN
  WHILE num > 0 LOOP
    digit := MOD(num, 10);             -- Get the last digit
    reversed := (reversed * 10) + digit; -- Append the digit to reversed number
    num := TRUNC(num / 10);            -- Remove the last digit   123.4 
  END LOOP;

  DBMS_OUTPUT.PUT_LINE('Reversed Number: ' || reversed);
END;

--Q4. Count the Digits in a Number
--Given a number like 98765, use a WHILE loop to count how many digits are present in the number.


DECLARE
  num        NUMBER := 98765; --9876, 987 98 9 0
  digitCount NUMBER := 0; --1 ,2 ,3,4,5
BEGIN
  WHILE num > 0 LOOP
    num := TRUNC(num / 10);     -- Remove the last digit
    digitCount := digitCount + 1;  -- Increase count
  END LOOP;

  DBMS_OUTPUT.PUT_LINE('Number of digits: ' || digitCount);
END;

--Q5. Generate Multiplication Table of 7
--Use a WHILE loop to print the multiplication table of 7 from 7 x 1 to 7 x 10

declare
  m_table number := 7;
  counter number := 1;
begin
  while counter <= 10 loop
    m_table := 7 * counter;
    dbms_output.put_line('Multiplication of 7 * ' || counter || ' = ' || m_table);
    counter := counter + 1;
  end loop;
end;

--for loop
--a FOR loop is used to execute a block of code a fixed number of times. 
--Its cleaner and more concise than a WHILE loop when you know the exact number of iterations.

--Examples
BEGIN
  FOR i IN 1..5 LOOP
    DBMS_OUTPUT.PUT_LINE('Value: ' || i);
  END LOOP;
END;
--
BEGIN
  FOR i IN REVERSE 1..5 LOOP
    DBMS_OUTPUT.PUT_LINE('Reverse Value: ' || i);
  END LOOP;
END;
--
BEGIN
  FOR i IN 1..10 LOOP
    DBMS_OUTPUT.PUT_LINE('3 x ' || i || ' = ' || (3 * i));
  END LOOP;
END;
--
CREATE OR REPLACE PROCEDURE print_numbers IS
BEGIN
  FOR i IN 1..5 LOOP
    DBMS_OUTPUT.PUT_LINE('i = ' || i);
  END LOOP;
END;

BEGIN
  print_numbers;
END;

--
--Q1. Print Numbers from 10 to 1
--Write a PL/SQL block that uses a FOR loop in reverse to print numbers from 10 to 1.

begin
  for i in reverse 1 .. 10 loop
    DBMS_OUTPUT.PUT_LINE(i);
  end loop;
end;

--Q2. Sum of First 10 Natural Numbers
--Use a FOR loop to calculate and display the sum of the first 10 natural numbers (1 + 2 + ... + 10).

declare
  result number := 0;
begin
  for i in 1 .. 10 loop
    result := result + i;
  end loop;
  dbms_output.put_line('Sum of First 10 Natural Numbers = ' || result);
end;
  
 
--Q3. Display the Square of Numbers from 1 to 5
--Using a FOR loop, display each number from 1 to 5 along with its square.

declare
  result number := 0;
begin
  for i in 1 .. 5 loop
    result := i * i;
    dbms_output.put_line('Square number of ' || i || ' is = ' || result);  
  end loop;
end;


--Q4. Print the Multiplication Table of 9
--Use a FOR loop to print the multiplication table for 9 (from 9 x 1 to 9 x 10).

declare
  result number := 0;
begin
  for i in 1 .. 10 loop
    result := 9 * i;
    dbms_output.put_line('Multiplication of 9 * ' || i || ' is = ' || result);  
  end loop;
end;

declare
  result number := 0;
begin
  for i in 1 .. 10 loop
    result := 9 * i;
    dbms_output.put_line(result);  
  end loop;
end;

--Q5. Count and Display Odd Numbers from 1 to 20
--Using a FOR loop, print only the odd numbers between 1 and 20, and count how many odd numbers there are.

declare
  result number := 0;
begin
  for i in 1 .. 20 loop
    if mod(i, 2) = 1 then
      dbms_output.put_line('This is odd number between 1 to 20 = ' || i);
      result := result + 1;
    end if;
  end loop;
  dbms_output.put_line('                                      ');
  dbms_output.put_line('--------------------------------------');
  dbms_output.put_line('                                      ');
  dbms_output.put_line('Total count of odd number between 1 to 20 is = ' || result);
end;


----20-05-2025  Tuesday-----------------------------------------------------------------------------------

Didnt practice due to function

----21-05-2025  Wednesday-----------------------------------------------------------------------------------

didnt practice due to rainfall and electricity issue.

but revise sql privious interview Q

----22-05-2025  Thursday-----------------------------------------------------------------------------------
--cursor is a pointer to a context area that stores the result set of a SQL query. 
--You use cursors to retrieve and process multiple rows returned by a query, one row at a time.


--synatx

DECLARE
  CURSOR cursor_name IS
    SELECT ... FROM ...;
  
  record_variable cursor_name%ROWTYPE;
BEGIN
  OPEN cursor_name;
  LOOP
    FETCH cursor_name INTO record_variable;
    EXIT WHEN cursor_name%NOTFOUND;
    -- Process each row
  END LOOP;
  CLOSE cursor_name;
END;
------Example 1
DECLARE
  CURSOR c_emp IS
    SELECT ename FROM emp;

  v_ename emp.ename%TYPE;
BEGIN
  OPEN c_emp;
  LOOP
    FETCH c_emp INTO v_ename;
    EXIT WHEN c_emp%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Employee: ' || v_ename);
  END LOOP;
  CLOSE c_emp;
END;
------
--Q1. Print All Employee Names
--Write a PL/SQL block that uses an explicit cursor and a loop to display all employee names from the EMP table.

declare
  cursor e_name is
    select first_name from hr.employees;
    
    v_ename hr.employees.first_name %type;
begin
  open e_name;
  loop
    fetch e_name
      into v_ename;
    exit when e_name%notfound;
    dbms_output.put_line('Employee Name = ' || v_ename);
  end loop;
  close e_name;
end;

--Q2. Print Employee Names and Salaries
--Using a cursor and a loop, print each employees name and salary from the EMP table.

declare
  cursor e_name is
    select first_name, salary from hr.employees;
    
  v_ename hr.employees.first_name%type;
  v_esal  hr.employees.salary%type;

begin
  open e_name;
  loop
    fetch e_name
      into v_ename, v_esal;
    exit when e_name%notfound;
    dbms_output.put_line('Employee Name = ' || v_ename ||' And salary of ' || v_ename || ' is = ' ||v_esal);
    dbms_output.put_line('                                                                ');
  end loop;
  close e_name;
end;

--Q3. Display Employees with Salary > 3000
--Declare a cursor that selects only employees with salary greater than 3000. 
--Loop through the cursor and print their names and salaries.

declare
  cursor e_name is
    select first_name, salary from hr.employees where salary > 3000 ;
    
  v_ename hr.employees.first_name%type;
  v_esal  hr.employees.salary%type;

begin
  open e_name;
  loop
    fetch e_name
      into v_ename, v_esal;
    exit when e_name%notfound;
    dbms_output.put_line('Employee Name = ' || v_ename ||' And salary of ' || v_ename || ' is = ' ||v_esal);
    dbms_output.put_line('                                                                ');
  end loop;
  close e_name;
end;
 
--Q4. Print Employee Details by Department (Parameterized Cursor)
--Write a parameterized cursor that takes a department number and prints all employee names and 
--jobs in that department.
--1 way
declare
  cursor e_name(dpt_id number) is
    select first_name, job_id
      from hr.employees
     where department_id = dpt_id;

  v_ename hr.employees.first_name%type;
  v_job   hr.employees.job_id%type;

begin
  open e_name(90);
  loop
    fetch e_name
      into v_ename, v_job;
    exit when e_name%notfound;
    dbms_output.put_line('Employee Name = ' || v_ename || ' And job of ' ||
                         v_ename || ' is = ' || v_job);
    dbms_output.put_line('                                                                ');
  end loop;
  close e_name;
end;
--2 way
declare
  cursor e_name(dpt_id number) is
    select first_name, job_id from hr.employees where department_id = dpt_id ;
    
   BEGIN
  -- Use the cursor with department 10
  FOR emp_rec IN e_name(90) LOOP
    DBMS_OUTPUT.PUT_LINE('Name: ' || emp_rec.first_name || ', Job: ' || emp_rec.job_id);
  END LOOP;
END;


--Q5. Give Bonus to Low Salary Employees
--Declare a cursor that selects employees with salary < 2500. Inside the loop, 
--print their name and use WHERE CURRENT OF to update their salary by adding 500.
--1 way
declare
  cursor e_name is
    select first_name, salary from hr.employees where salary < 2500;
  v_ename  hr.employees.first_name%type;
  v_salary hr.employees.salary%type;
  v_sal    number := 0;
begin
  open e_name;
  loop
    fetch e_name
      into v_ename, v_salary;
    exit when e_name%notfound;
  
    dbms_output.put_line('Employee Name = ' || v_ename ||
                         ' And old salary of ' || v_ename || ' is = ' ||
                         v_salary);
    v_sal := v_salary + 500;
    dbms_output.put_line('New salary of ' || v_ename || ' is = ' || v_sal);
  
    dbms_output.put_line('                                                                ');
  end loop;
  close e_name;
end;

select * from hr.employees where salary < 3000;
--2 way
declare
  cursor e_name is
    select first_name, salary from a_emp where salary < 2500 for update;
  v_ename  a_emp.first_name%type;
  v_salary a_emp.salary%type;
  -- v_sal    number := 0;
begin
  open e_name;
  loop
    fetch e_name
      into v_ename, v_salary;
    exit when e_name%notfound;
  
    dbms_output.put_line('Employee Name = ' || v_ename ||
                         ' And old salary of ' || v_ename || ' is = ' ||
                         v_salary);
  
    update a_emp set salary = salary + 500 where current of e_name;
    
    DBMS_OUTPUT.PUT_LINE('Bonus added! New Salary: ' || (v_salary + 500));
    
        dbms_output.put_line('                                                                ');  
  end loop;
  close e_name;
end;

rollback ;


select * from a_emp where first_name = 'Ki';

----23-05-2025  friday-----------------------------------------------------------------------------------

/*Write a PL/SQL block that uses a cursor to fetch all employees from the a_emp table.
For each employee, do the following using a LOOP and IF...ELSIF conditions:

If salary < 2000, print "Low salary employee: [name]"

If salary between 2000 and 5000, print "Average salary employee: [name]"

If salary > 5000, print "High salary employee: [name]"

Use an explicit cursor and a simple loop, not a cursor FOR loop.
*/

Declare
  cursor emp is
    select first_name, salary from a_emp;
  v_ename a_emp.first_name%type;
  v_sal   a_emp.salary%type;
begin
  open emp;
  loop
    fetch emp
      into v_ename, v_sal;
    exit when emp%notfound;
    dbms_output.put_line('Employee name is : ' || v_ename ||
                         ' And Salary is : ' || v_sal);
    if v_sal < 2500 then
      dbms_output.put_line('Low salary employee : ' || v_ename);
    elsif v_sal between 2000 and 5000 then
      dbms_output.put_line('Average salary employee : ' || v_ename);
    elsif v_sal > 5000 then
      dbms_output.put_line('High salary employee:' || v_ename);
    end if;
    dbms_output.put_line('                                                                ');  
    dbms_output.put_line('-----------------------------------------------------------------');  
    dbms_output.put_line('                                                                ');  

  end loop;
end;

--Prints numbers from 1 to 20
--For multiples of 3, print "Fizz" instead of the number
--For multiples of 5, print "Buzz"
--For numbers that are multiples of both 3 and 5, print "FizzBuzz"

declare
  num number := 0;
begin
  loop
    num := num + 1;
    exit when num > 20;  
    if mod(num, 3) = 0 and mod(num, 5) = 0 then
      dbms_output.put_line('FizzBuzz');
    elsif mod(num, 3) = 0 then
      dbms_output.put_line('Fizz');
    elsif mod(num, 5) = 0 then
      dbms_output.put_line('Buzz');
    else
      dbms_output.put_line(num);
    
    end if;
  end loop;
end;

--Write a PL/SQL block that uses a cursor to loop through the Customer1 table.
--For each customer, check their city:
--If the city is 'NEW YORK', print: 'Customer [Name] is from NEW YORK.'

--Way 1 for condition specific.
DECLARE
  CURSOR C_NAME IS
    SELECT CNAME, CADD FROM CUSTOMER1;

  V_CNAME CUSTOMER1.CNAME%TYPE;
  V_CADD  CUSTOMER1.CADD%TYPE;
BEGIN
  OPEN C_NAME;
  LOOP
    FETCH C_NAME
      INTO V_CNAME, V_CADD;
    EXIT WHEN C_NAME%NOTFOUND;
    IF V_CADD = 'NEW YORK' THEN
      DBMS_OUTPUT.PUT_LINE('Customer ' || V_CNAME || ' is from NEW YORK.');
    ELSE
      DBMS_OUTPUT.PUT_LINE('Customer ' || V_CNAME ||
                           ' is from Another City.');
    END IF;
  END LOOP;
  CLOSE C_NAME;
END;
--WAY 2 FOR ALL RECORD 
DECLARE
  CURSOR C_NAME IS
    SELECT CNAME, CADD FROM CUSTOMER1;

  V_CNAME CUSTOMER1.CNAME%TYPE;
  V_CADD  CUSTOMER1.CADD%TYPE;

BEGIN
  OPEN C_NAME;
  LOOP
    FETCH C_NAME
      INTO V_CNAME, V_CADD;
    EXIT WHEN C_NAME%NOTFOUND;
  
    IF V_CADD = 'NEW YORK' THEN
      DBMS_OUTPUT.PUT_LINE('Customer ' || V_CNAME || ' is from NEW YORK.');
    ELSE
      DBMS_OUTPUT.PUT_LINE('Customer ' || V_CNAME || ' is from ' || V_CADD);
    END IF;
  
  END LOOP;
  CLOSE C_NAME;
END;


--Write a PL/SQL block that uses a cursor to loop through the Ser_det (Service Details) table.
--For each service record:
--If the total amount (i.e., SER_AMT + SP_AMT) is greater than 600, 
--print: 'High Bill: [SID] - [Total Amount]'

declare
  cursor c_spr is
    select sid, sp_amt, ser_amt from ser_det;

  v_sid     ser_det.sid%type;
  v_sp_amt  ser_det.sp_amt%type;
  v_ser_amt ser_det.ser_amt%type;

  v_total number := 0;
begin
  open c_spr;
  loop
    fetch c_spr
      into v_sid, v_sp_amt, v_ser_amt;
    exit when c_spr%notfound;
    v_total := v_sp_amt + v_ser_amt;
    if v_total > 600 then
      dbms_output.put_line('High Bill : ' || v_sid || ' - ' || v_total);
    end if;
  end loop;
  close c_spr;
end;

/*You are maintaining the Vendors table.
Write a PL/SQL block that does the following:

Loop through each vendor using a cursor.

If a vendor's vcreditdays is less than 20, increase it by 5.

After the loop, print a message for each updated vendor:

'Vendor [VID] - Creditdays Increase By : [New Creditdays]'
*/

DECLARE
  CURSOR C_VNAME IS
    SELECT VID, VCREDITDAYS FROM VENDORS;

  V_VID   VENDORS.VID%TYPE;
  V_CDAYS VENDORS.VCREDITDAYS%TYPE;

  V_INCREMENT NUMBER := 0;
BEGIN
  OPEN C_VNAME;
  LOOP
    FETCH C_VNAME
      INTO V_VID, V_CDAYS;
    EXIT WHEN C_VNAME%NOTFOUND;
    IF V_CDAYS < 20 THEN
      V_INCREMENT := V_CDAYS + 5;
      DBMS_OUTPUT.PUT_LINE('Vendors : ' || V_VID || ' Creditdays Increase By : ' || V_INCREMENT);
    END IF;
  END LOOP;
  CLOSE C_VNAME;
END;
    
select * from Vendors where vcreditdays < 20  ;


----24-05-2025  Satuarday-----------------------------------------------------------------------------------
did not practice due to function.

----25-05-2025  Sunday-----------------------------------------------------------------------------------
--cursor/*
   /* THERE ARE TWO TYPE OF CURSOR
      1-IMPLICIT CURSOR
                 implicit cursor automatically created by oracle whenever a sql statement is executed.
      2-EXPLICIT CURSOR 
                 declare and define by the programmer to gain more control over the procesing of the result set.
      SUBTYPE
            1-SIMPLE CURSOR
            2-CURSOR FOR LOOP
            3-REF CURSOR
                  1-SYSREF CURSOR / WEAKREF CURSOR
                  2-STRONG REF CURSOR
            4-CURSOR FOR UPDATE
       ATTRIBUTE OF CURSOR
       1- %FOUND
       2- %NOTFOUND
       3- %ROWCOUNT
       4- %ISOPEN *\*/
       



begin
for i in (select * from hr.employees) loop
dbms_output.put_line('Emp Details :'||i.employee_id||'-'||i.first_name||'-'||i.last_name||'-'||i.%rowcount);
end loop;
end;
---
DECLARE
  v_count NUMBER := 0;
BEGIN
  FOR i IN (SELECT * FROM hr.employees) LOOP
    v_count := v_count + 1;
    DBMS_OUTPUT.PUT_LINE('Emp Details : ' || i.employee_id || '-' || i.first_name || '-' || i.last_name || ' | Row# ' || v_count);
  END LOOP;
END;
---
DECLARE
  CURSOR emp_cur IS
    SELECT employee_id, first_name, last_name FROM hr.employees;

  v_id hr.employees.employee_id%TYPE;
  v_fname hr.employees.first_name%TYPE;
  v_lname hr.employees.last_name%TYPE;
BEGIN
  OPEN emp_cur;
  LOOP
    FETCH emp_cur INTO v_id, v_fname, v_lname;
    EXIT WHEN emp_cur%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE('Emp Details: ' || v_id || '-' || v_fname || '-' || v_lname || ' | Row# ' || emp_cur%ROWCOUNT);
  END LOOP;
  CLOSE emp_cur;
END;
--
DECLARE
    CURSOR cur_emp IS
        SELECT employee_id, salary
        FROM employees
        WHERE department_id = 10
        FOR UPDATE OF salary;
BEGIN
    FOR rec IN cur_emp LOOP
        UPDATE employees
        SET salary = salary * 1.10
        WHERE CURRENT OF cur_emp;
    END LOOP;
    COMMIT;
END;
--
create or replace procedure p1 is 
  CURSOR C_VNAME IS
    SELECT VID, VCREDITDAYS FROM VENDORS;

  V_VID   VENDORS.VID%TYPE;
  V_CDAYS VENDORS.VCREDITDAYS%TYPE;

  V_INCREMENT NUMBER := 0;
BEGIN
  OPEN C_VNAME;
  LOOP
    FETCH C_VNAME
      INTO V_VID, V_CDAYS;
    EXIT WHEN C_VNAME%NOTFOUND;
    IF V_CDAYS < 20 THEN
      V_INCREMENT := V_CDAYS + 5;
      DBMS_OUTPUT.PUT_LINE('Vendors : ' || V_VID || ' Creditdays Increase By : ' || V_INCREMENT);
    END IF;
  END LOOP;
  CLOSE C_VNAME;
END;

begin
  p1 ;
  end ;
 
  declare int
p_emp_id number:=*100*;
begin
pl (p_emp_id );
end;

exec pl (100);
---------------------------------------------------------------------
-- Cursor For Loop

BEGIN
  FOR emp_rec IN (SELECT employee_id, first_name, last_name FROM hr.employees) LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp_rec.employee_id ||
                         ', Name: ' || emp_rec.first_name || ' ' || emp_rec.last_name);
  END LOOP;
END;

--

DECLARE
  v_counter NUMBER := 0;
BEGIN
  FOR emp_rec IN (SELECT employee_id, first_name FROM hr.employees) LOOP
    v_counter := v_counter + 1;
    DBMS_OUTPUT.PUT_LINE('Row ' || v_counter || ': ' || emp_rec.first_name);
  END LOOP;
END;
--

--1. Employee Full Names
--Write a PL/SQL block that uses a cursor FOR loop to print the full name (first_name + last_name) 
--of every employee from the hr.employees table.

BEGIN
  FOR REC IN (SELECT FIRST_NAME, LAST_NAME FROM HR.EMPLOYEES) LOOP
    DBMS_OUTPUT.PUT_LINE('Employee Full Names : ' || REC.FIRST_NAME || ' ' ||
                         REC.LAST_NAME);
  END LOOP;
END;

--2. Department-wise Employee Count
--Using a cursor FOR loop, print each department ID and the number of employees in that department 
--(use hr.employees table grouped by department_id).

BEGIN
  FOR REC IN (SELECT DEPARTMENT_ID, COUNT(EMPLOYEE_ID) AS COUNT_EMP
                FROM HR.EMPLOYEES
               GROUP BY DEPARTMENT_ID) LOOP
    DBMS_OUTPUT.PUT_LINE('Employee_id : ' || REC.DEPARTMENT_ID ||
                         ' Department-wise Employee Count : ' ||
                         REC.COUNT_EMP);
  END LOOP;
END;

(select department_id, count(employee_id) as count_emp
                from hr.employees
               group by department_id);

--3. Vendor Credit Check
--Loop through the vendors table. For each vendor, if vcreditdays is less than 20, print a message:
--'Vendor [VID] has low credit days.'

BEGIN
  FOR REC IN (SELECT VID, VCREDITDAYS FROM VENDORS) LOOP
    IF REC.VCREDITDAYS < 20 THEN
      DBMS_OUTPUT.PUT_LINE('Vendor id : ' || REC.VID ||
                           ' has low credit days.');
    END IF;
  END LOOP;
END;      

select * from vendors where vcreditdays < 20;

--4. Spare Part Cost Check
--From the sparepart table, print the sp_id and sp_cost of each spare part. If cost > 350, print:
--'High cost spare part: [SP_ID]'

BEGIN
  FOR REC IN (SELECT SID, SP_RATE FROM SER_DET) LOOP
    IF REC.SP_RATE > 350 THEN
      DBMS_OUTPUT.PUT_LINE('High cost spare part : ' || REC.SID ||' Cost of that spare part is : ' || REC.SP_RATE);
    END IF;
  END LOOP;
END;

select * from ser_det where sp_rate > 350 ;
--5. Customer Address Display
--Loop through the customer1 table and print each customer's name and address in the format:
--[Customer Name] lives in [City Name]

BEGIN
  FOR REC IN (SELECT CNAME, CADD FROM CUSTOMER1) LOOP
    DBMS_OUTPUT.PUT_LINE(REC.CNAME || ' Lives in ' || REC.CADD);
  END LOOP;
END;

select * from customer1;

--6. Employees with Bonus
--From the hr.employees table, loop through each employee. For those with a salary greater than 10000, 
--calculate a 10% bonus and print:
--'Employee [Name] - Bonus: [Calculated Bonus]'

BEGIN
  FOR REC IN (SELECT FIRST_NAME, SALARY * 0.10 AS BONUS_SALARY
                FROM HR.EMPLOYEES
               WHERE SALARY > 10000) LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ' || REC.FIRST_NAME || ' - Bonus: ' ||
                         REC.BONUS_SALARY);
  END LOOP;
END;
--2 way with rowcount
DECLARE
  V_COUNT NUMBER := 0;
BEGIN
  FOR REC IN (SELECT FIRST_NAME, SALARY * 0.10 AS BONUS_SALARY
                FROM HR.EMPLOYEES
               WHERE SALARY > 10000) LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ' || REC.FIRST_NAME || ' - Bonus: ' ||
                         REC.BONUS_SALARY);
    V_COUNT := V_COUNT + 1;
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('Total employee is : ' || V_COUNT);
END;

select first_name,salary from hr.employees where salary > 10000 ;

--7. Spare Parts Value Check
--From the sparepart table, print sp_id, sp_qty, and total value (quantity  cost). 
--If total value exceeds 5000, print:
--'High Value Spare Part: [SP_ID] - Total: [value]'
DECLARE
  V_TOTAL NUMBER := 0;
BEGIN
  FOR REC IN (SELECT SID, QTY, SP_RATE FROM SER_DET) LOOP
    V_TOTAL := REC.QTY * REC.SP_RATE;
    DBMS_OUTPUT.PUT_LINE('High Value Spare Part: ' || REC.SID ||
                         ' - Total: ' || V_TOTAL);
  END LOOP;
END;

select * from ser_det;

--8. Active Customers by City
--From the customer1 table, count how many customers are from each city using a GROUP BY on cadd.
--Print cities that have more than 1 customers:
--'City: [CADD] - Active Customers: [Count]'

BEGIN
  FOR REC IN (SELECT CADD, COUNT(CID) AS CUS_TOTAL
                FROM CUSTOMER1
               GROUP BY CADD
              HAVING COUNT(CID) > 1) LOOP
    DBMS_OUTPUT.PUT_LINE('City : ' || REC.CADD || ' - Active Customers : ' ||
                         REC.CUS_TOTAL);
  END LOOP;
END;
    
select * from customer1;

--9. Service Bills with Discount Flag
--From the ser_det table, print sid and total amount (sp_amt + ser_amt).
--If total > 1000, print:
--'Service ID: [SID] - Total: [Total Amount] '
DECLARE
  V_TOTAL NUMBER := 0;
BEGIN
  FOR REC IN (SELECT SID, SP_AMT, SER_AMT
                FROM SER_DET
               WHERE SP_AMT + SER_AMT > 1000) LOOP
    V_TOTAL := REC.SP_AMT + REC.SER_AMT;
    DBMS_OUTPUT.PUT_LINE('Service ID : ' || REC.SID || ' Total : ' ||
                         V_TOTAL);
  END LOOP;
END;

SELECT * FROM SER_DET;

--10. Vendor Credit Adjustment Report
--Loop through the vendors table. If vcreditdays is less than 25, show what their new credit days 
--would be after adding 7 days.
--'Vendor [VID] - Credit Updated From [Old] to [New]'
DECLARE
  V_DAYS NUMBER := 0;
BEGIN
  FOR REC IN (SELECT VID, VCREDITDAYS FROM VENDORS) LOOP
    IF REC.VCREDITDAYS < 25 THEN
      V_DAYS := REC.VCREDITDAYS + 7;
      DBMS_OUTPUT.PUT_LINE('Vendors : ' || REC.VID ||
                           ' Credit Updated From ' || REC.VCREDITDAYS ||
                           ' to ' || V_DAYS);
    END IF;
  END LOOP;
END;

select * from vendors where  vcreditdays < 25;


-------------------------------------------Fundamental Quation--------------------------------------------------
----26-05-2025  Monday-----------------------------------------------------------------------------------


--1. Write a PL/SQL block to calculate the incentive of an employee whose ID is 110. by 10 %

declare
  V_incentive number := 0;
begin
  select salary * 0.10
    into V_incentive
    from hr.employees
   where employee_id = 110;
  dbms_output.put_line('Incentive of employee : ' || V_incentive);
end;

--2. Write a PL/SQL block to show an invalid case-insensitive reference to a quoted and without 
--quoted user-defined identifier.

----1
DECLARE
  "WELCOME" varchar2(10) := 'welcome'; -- identifier with quotation 
BEGIN
  DBMS_Output.Put_Line("Welcome"); --reference to the identifier with quotation and different case
END;
----2
DECLARE
  WELCOME varchar2(10) := 'welcome'; -- identifier without quotation
BEGIN
  DBMS_Output.Put_Line("Welcome"); --reference to the identifier with quotation and different case
END;

--3. Write a PL/SQL block to show a reserved word can be used as a user-define identifier.

DECLARE
  "DECLARE" varchar2(25) := 'This is UPPERCASE';
  "Declare" varchar2(25) := 'This is Proper Case';
  "declare" varchar2(25) := 'This is lowercase';
  declare1  varchar2(25) := 'This is lowercase';

BEGIN
  DBMS_Output.Put_Line("DECLARE");
  DBMS_Output.Put_Line("Declare");
  DBMS_Output.Put_Line("declare");
  DBMS_Output.Put_Line(DECLARE1);

END;


select * from hr.employees where employee_id = 110 ;

-------------------------------------Control Statement----------------------------------------------------

--1. Write a PL/SQL program to arrange the number of two variable in such a way that the 
--small number will store in num_small variable and large number will store in num_large variable.

declare 
num_small number := 5; --7
num_large number := 7; --10
num_temp number := 0 ; --10,
begin
IF num_small > num_large THEN
num_temp := num_small;
num_small := num_large;
num_large := num_temp;
END IF;

DBMS_OUTPUT.PUT_LINE ('num_small = '||num_small);
DBMS_OUTPUT.PUT_LINE ('num_large = '||num_large);
END;

--3. Write a PL/SQL program to check whether a number is even or odd.

declare
  v_number number := &input_from_user;
begin
  if mod(v_number, 2) = 0 then
    dbms_output.put_line('Given number is even : ' || v_number);
  else
    dbms_output.put_line('Given number is odd : ' || v_number);
  end if;
end;

--5. Write a PL/SQL program to check whether a date falls on weekend i.e. SATURDAY or SUNDAY.

DECLARE
  dt1     DATE := TO_DATE('&new_dt', 'DD-MON-YYYY');
  get_day VARCHAR2(15);
BEGIN
  get_day := RTRIM(TO_CHAR(dt1, 'DAY'));
  IF get_day IN ('SATURDAY', 'SUNDAY') THEN
    DBMS_OUTPUT.PUT_LINE('The day of the given date is ' || get_day ||
                         ' and it falls on weekend');
    dbms_output.new_line;
  
  ELSE
    DBMS_OUTPUT.PUT_LINE('The day of the given date is ' || get_day ||
                         ' and it does not fall on the weekend');
    dbms_output.new_line;
  
  END IF;
  DBMS_OUTPUT.PUT_LINE('Execution  done successfully.');
END;

--7. Write a PL/SQL program to count number of employees in department 50 and check whether this 
--department have any vacancies or not. There are 50 vacancies in this department.

declare
  v_count    number := 0;
  v_vacanccy number := 0;
begin
  select count(employee_id)
    into v_count
    from hr.employees
   group by department_id
  having department_id = 50;
  if v_count <= 50 then
    v_vacanccy := 50 - v_count;
    DBMS_OUTPUT.PUT_LINE('There is vaccancy available : ' || v_vacanccy);
  else
    DBMS_OUTPUT.PUT_LINE('There is no vaccancy available : ' || v_count);
  end if;
end;

--9. Write a PL/SQL program to count number of employees in a specific department and check 
--whether this department have any vacancies or not. If any vacancies, how many vacancies are in 
--that department.

declare
  v_count    number := 0;
  v_vacanccy number := 0;
  v_dpt number := &num ;
begin
  select count(employee_id)
    into v_count
    from hr.employees
   group by department_id
  having department_id = v_dpt;
  if v_count <= 45 then
    v_vacanccy := 45 - v_count;
    DBMS_OUTPUT.PUT_LINE('There is vaccancy available in dpt : '|| v_dpt || ' is '|| v_vacanccy);
  else
    DBMS_OUTPUT.PUT_LINE('There is vaccancy no available in dpt : '|| v_dpt );
  end if;
end;


--13. Write a PL/SQL program to check whether a given character is letter or digit.

DECLARE
  get_ctr CHAR(1) := '&input_a_character';
BEGIN
  if get_ctr >= 'A' and get_ctr >= 'Z' or get_ctr >= 'a' and get_ctr >= 'z' then
    DBMS_OUTPUT.PUT_LINE('Given Character is letter : ' || get_ctr);
  else
    DBMS_OUTPUT.PUT_LINE('Given Character is number : ' || get_ctr);
  end if;
end;


----27-05-2025  Tuesday-----------------------------------------------------------------------------------

--A stored procedure in Oracle PL/SQL is a named block of code (like a function) that performs a specific task
--and is stored in the database. You can call it multiple times, pass parameters, and even include conditional
--logic, loops, cursors, etc.

--Syantax
CREATE OR REPLACE PROCEDURE procedure_name (
  param1 IN datatype,
  param2 OUT datatype
)
IS
BEGIN
  -- Procedure logic here
END;
----

CREATE OR REPLACE PROCEDURE show_greeting as
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello from procedure!');
END;

begin
show_greeting;
end;
----

CREATE OR REPLACE PROCEDURE greet_user(p_name IN VARCHAR2) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name || '!');
END;

begin
greet_user('Alex');
end;
----

CREATE OR REPLACE PROCEDURE get_bonus   ----get_bonus(salary,bonus)
(salary IN NUMBER, bonus OUT NUMBER) IS  ---b
BEGIN
  bonus := salary * 0.10;
END;

DECLARE
  b NUMBER;
BEGIN
  get_bonus(5000, b);
  DBMS_OUTPUT.PUT_LINE('Bonus: ' || b);
END;

CREATE OR REPLACE PROCEDURE get_bonus   ----get_bonus(salary,bonus)
(salary IN NUMBER, bonus OUT NUMBER,total out number) IS  ---b
BEGIN
  bonus := salary * 0.10;
  total := salary + bonus;
END;

DECLARE
  b NUMBER;
  t number;
BEGIN
  get_bonus(5000, b, t);
  DBMS_OUTPUT.PUT_LINE('Bonus: ' || b || ' Total : ' || t);
END;
----

CREATE OR REPLACE PROCEDURE show_low_salary_employees IS
BEGIN
  FOR rec IN (SELECT first_name, salary FROM hr.employees WHERE salary < 3000) LOOP
    DBMS_OUTPUT.PUT_LINE(rec.first_name || ' - ' || rec.salary);
  END LOOP;
END;

BEGIN
  show_low_salary_employees;
END;
/

----
CREATE OR REPLACE PROCEDURE increase_salary(emp_id IN NUMBER, pct IN NUMBER) IS
BEGIN
  UPDATE employee1
  SET salary = salary + (salary * pct / 100)
  WHERE employee_id = emp_id;

  DBMS_OUTPUT.PUT_LINE('Salary updated for employee ' || emp_id);
END;

begin
increase_salary(101, 200);
end;
----

--1.Write a stored procedure that accepts a person's name as an IN parameter and prints a welcome message like:
--Hello, [name]! Welcome to our system.
CREATE OR REPLACE PROCEDURE greet_user(p_name IN VARCHAR2) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name || '!');
END;

begin
greet_user('Alex');
end;

--2.Create a procedure that takes a number as IN, calculates its square, and returns it through an OUT parameter.

create or replace procedure p_square(p_number  in number,
                                     p_squarer out number) is
begin
  p_squarer := p_number * p_number;
end;
  
declare
  a number;
  b number := &num;
begin
  p_square(b, a);
  dbms_output.put_line('Square root of ' || b || ' is : ' || a);
end;

--3.Write a procedure that accepts an employee ID as input and prints the employee's name and 
--salary using the employees table.

create or replace procedure p_emp(P_empid in number) is
begin
  for rec in (select first_name, salary
                from employee1
               where employee_id = p_empid) loop
    dbms_output.put_line(rec.first_name || ' - ' || rec.salary);
  end loop;
end;
    
    
  begin
    p_emp(100);
  end;
---way 2     
create or replace procedure p_emp(P_empid in number) is
  cursor c_emp is
    select first_name, salary from employee1 where employee_id = p_empid;
  v_fname employee1.first_name%type;
  v_sal   employee1.salary%type;
begin
  open c_emp;
  loop
    fetch c_emp
      into v_fname, v_sal;
    exit when c_emp%notfound;
    dbms_output.put_line(v_fname || ' - ' || v_sal);
  end loop;
end;

begin
  p_emp(101);
end;
---way 3
create or replace procedure p_emp(P_empid in number,
                                  p_name  out varchar2,
                                  p_sal   out number) is
begin
  select first_name, salary
    into p_name, p_sal
    from employee1
   where employee_id = p_empid;
  dbms_output.put_line(p_name || p_sal);
end;

declare a varchar2(50); b number;
begin
p_emp(100, a, b);
end;
--way4
create or replace procedure p_emp(P_empid in number,
                                  v_fname out varchar2,
                                  v_sal   out number) is
  cursor c_emp is
    select first_name, salary from employee1 where employee_id = p_empid;
  --v_fname employee1.first_name%type;
  --v_sal   employee1.salary%type;
begin
  open c_emp;
  loop
    fetch c_emp
      into v_fname, v_sal;
    exit when c_emp%notfound;
    dbms_output.put_line(v_fname || ' - ' || v_sal);
  end loop;
end;

declare a varchar2(50); b number;
begin
p_emp(101, a, b);
end;
    
--4.Create a procedure that takes a city name as input and prints all customer names from that city 
--(use your customer1 table).

create or replace procedure p_emp(P_cadd in varchar2, p_cname out varchar2) is
begin
  select cname into p_cname from customer1 where cadd = p_cadd;
  dbms_output.put_line(p_cname);
end;

declare a varchar2(30);
begin
p_emp('NEW YORK', a);
end;
---
create or replace procedure p1(p_city in varchar2, p_cname out varchar2) is
  cursor cur is
    select cname into p_cname from customer1 where cadd = P_city;
begin
  open cur;
  loop
    fetch cur
      into p_cname;
    exit when cur%notfound;
    dbms_output.put_line(p_cname || ' - ' || p_city);
  end loop;
end;
 
declare
  add varchar2(100);
begin
  p1('NEW YORK', add);
end;

select * from customer1;

--5.Write a procedure that accepts a vendor ID and additional credit days as IN parameters, 
--and updates the vcreditdays in the vendors table.

create or replace procedure p_v(p_vid in number, p_adddays in number) is
  v_addcredit number := 0;

begin
  for rec in (select vcreditdays from vendors where vid = p_vid) loop
    v_addcredit := rec.vcreditdays + p_adddays;
    dbms_output.put_line(' before add days : ' || rec.vcreditdays ||
                         ' after : ' || v_addcredit);
  
    update vendors1 set vcreditdays = v_addcredit where vid = p_vid;
  
  end loop;
end;

begin
  p_v(2001, 5);
end;

rollback;

create table vendors1 as select * from vendors ;

select * from vendors1;

--6.Create a procedure that accepts a department ID as input. For all employees in that department:
--If salary < 3000, print: Low earner: [name] - [salary]
--If salary >= 3000, print: Eligible for incentive: [name] - [salary]

create or replace procedure p_emp(p_dptid in number) is
begin
  for rec in (select salary, first_name
                from hr.employees
               where department_id = p_dptid) loop
    if rec.salary < 3000 then
      dbms_output.put_line('Low earner : ' || rec.first_name ||
                           ' salary is : ' || rec.salary);
    else
      dbms_output.put_line('Eligible for incentive: ' || rec.first_name ||
                           ' salary is : ' || rec.salary);
    end if;
  end loop;
end;
      
begin
  p_emp(90);
end;

--7.Write a procedure that takes a city name as input and returns the number of customers 
--in that city through an OUT parameter.

create or replace procedure p_city is
begin
  for rec in (select count(e.employee_id) as total_cus, l.city
                from hr.employees e
                join hr.departments d
                  on e.department_id = d.department_id
                join hr.locations l
                  on l.location_id = d.location_id
               where l.city in ('Oxford' , 'London')
               group by l.city) loop
    dbms_output.put_line('Total customer in ' || rec.city || ' is : ' ||
                         rec.total_cus);
  end loop;
  EXCEPTION
  WHEN OTHERS THEN
    dbms_output.put_line('err:-'||dbms_utility.format_error_stack);
    dbms_output.put_line('Backtrace: ' ||dbms_utility.format_error_backtrace);
END;

begin
  p_city;
end;
----Way 2
create or replace procedure p1(p_count out number) is
begin
  
select count(e.employee_id) into p_count  from hr.employees e
    join hr.departments d on e.department_id = d.department_id
    join hr.locations l on l.location_id = d.location_id 
    where l.city = 'Oxford'
    group by l.city ;
    dbms_output.put_line('total customer : '|| p_count);
    end;

declare
v_count  number;
begin
p1(v_count);
end;
 

select * from hr.locations ;
select * from hr.departments ;
select * from hr.employees ;

select count(e.employee_id) as total_cus, l.city  from hr.employees e
    join hr.departments d on e.department_id = d.department_id
    join hr.locations l on l.location_id = d.location_id 
    where l.city in ('Oxford' , 'London')
    group by l.city ;

--8.Create a procedure to loop through all vendors:
--If vcreditdays is below 15, increase it by 5.
--Print updated credit days for such vendors.
--Use a cursor FOR loop.

create or replace procedure p_vendor is
  v_increase number := 0;
begin
  for rec in (select vname, vcreditdays from vendors) loop
    if rec.vcreditdays < 15 then
      v_increase := rec.vcreditdays + 5;
      dbms_output.put_line('Updated credit days is : ' || v_increase ||
                           ' to ' || rec.vcreditdays);
    end if;
  end loop;
end;

begin
p_vendor;
end;

select * from vendors;

--9.Create a procedure that loops through the ser_det table:
--For each row, calculate ser_amt + sp_amt.
--If the total is more than 700, print the SID and total with a message:
--High bill: SID [sid] - Total: [amount]

create or replace procedure p_ser_det is
  v_total number := 0;
begin
  for rec in (select sid, ser_amt, sp_amt from ser_det) loop
    if rec.ser_amt + rec.sp_amt > 700 then
      v_total := rec.ser_amt + rec.sp_amt;
      dbms_output.put_line('High bill : ' || rec.sid || ' Total : ' ||
                           v_total);
    end if;
  end loop;
end;
    
begin
  p_ser_det;
end;

--10--Write a PL/SQL procedure named Check_Bonus_Eligibility that:
--Uses an explicit cursor to retrieve all employees from the HR.EMPLOYEES table.
--For each employee, based on their salary:
--If the salary is less than 5000, print:
--'Employee [first_name last_name] (ID: [employee_id]) is eligible for bonus.'
--If the salary is between 5000 and 10000, print:
--'Employee [first_name last_name] (ID: [employee_id]) may be considered for bonus.'
--Else, print:
--'Employee [first_name last_name] (ID: [employee_id]) is not eligible for bonus.'
--Count how many employees fall into each category, and display the totals at the end.
 
----28-05-2025  Wednesday-----------------------------------------------------------------------------------

--Write a PL/SQL procedure named Check_Bonus_Eligibility that:
--Uses an explicit cursor to retrieve all employees from the HR.EMPLOYEES table.
--For each employee, based on their salary:
--If the salary is less than 5000, print:
--'Employee [first_name last_name] (ID: [employee_id]) is eligible for bonus.'
--If the salary is between 5000 and 10000, print:
--'Employee [first_name last_name] (ID: [employee_id]) may be considered for bonus.'
--Else, print:
--'Employee [first_name last_name] (ID: [employee_id]) is not eligible for bonus.'
--Count how many employees fall into each category, and display the totals at the end.

create or replace procedure p_emp is
  v_count1 number := 0;
  v_count2 number := 0;
  v_count3 number := 0;
begin
  for rec in (select first_name, last_name, employee_id, salary
                from hr.employees) loop
    if rec.salary < 5000 then
      v_count1 := v_count1 + 1;
      dbms_output.put_line('Employee : ' || rec.first_name || ' ' ||
                           rec.last_name || ' ID : ' || rec.employee_id ||
                           ' is eligible for bonus ');
      dbms_output.put_line('                                                  ');
    elsif rec.salary between 5000 and 10000 then
      v_count2 := v_count2 + 1;
      dbms_output.put_line('Employee : ' || rec.first_name || ' ' ||
                           rec.last_name || ' ID : ' || rec.employee_id ||
                           ' may be considered for bonus ');
      dbms_output.put_line('                                                  ');
    else
      v_count3 := v_count3 + 1;
      dbms_output.put_line('Employee : ' || rec.first_name || ' ' ||
                           rec.last_name || ' ID : ' || rec.employee_id ||
                           '  is not eligible for bonus. ');
      dbms_output.put_line('                                                  ');
    end if;
  end loop;
  dbms_output.put_line('                                                   ');
  dbms_output.put_line('--------------------------------------------------');
  dbms_output.put_line('                                                  ');
  dbms_output.put_line('Total emp that have salary < 5000 is : ' ||
                       v_count1);
  dbms_output.put_line('                                                  ');
  dbms_output.put_line('Total emp that have salary between 5000 and 10000 is : ' ||
                       v_count2);
  dbms_output.put_line('                                                  ');
  dbms_output.put_line('Total emp that have other salary  is : ' ||
                       v_count3);
end;

begin
  p_emp;
end;
-----Way 2
CREATE OR REPLACE PROCEDURE Check_Bonus_Eligibility IS
    -- Declare explicit cursor to fetch employees
    CURSOR emp_cursor IS
        SELECT employee_id, first_name, last_name, salary
        FROM HR.EMPLOYEES;
 
    -- Declare variables to store employee data
    v_employee_id HR.EMPLOYEES.employee_id%TYPE;
    v_first_name HR.EMPLOYEES.first_name%TYPE;
    v_last_name HR.EMPLOYEES.last_name%TYPE;
    v_salary HR.EMPLOYEES.salary%TYPE;
 
    -- Counters for each category
    eligible_count NUMBER := 0;
    consider_count NUMBER := 0;
    not_eligible_count NUMBER := 0;
 
BEGIN
    -- Iterate through employees using a cursor loop
    FOR emp_rec IN emp_cursor LOOP
        v_employee_id := emp_rec.employee_id;
        v_first_name := emp_rec.first_name;
        v_last_name := emp_rec.last_name;
        v_salary := emp_rec.salary;
 
        -- Determine bonus eligibility
        IF v_salary < 5000 THEN
            DBMS_OUTPUT.PUT_LINE('Employee ' || v_first_name || ' ' || v_last_name ||
                                ' (ID: ' || v_employee_id || ') is eligible for bonus.');
            eligible_count := eligible_count + 1;
        ELSIF v_salary BETWEEN 5000 AND 10000 THEN
            DBMS_OUTPUT.PUT_LINE('Employee ' || v_first_name || ' ' || v_last_name ||
                                ' (ID: ' || v_employee_id || ') may be considered for bonus.');
            consider_count := consider_count + 1;
        ELSE
            DBMS_OUTPUT.PUT_LINE('Employee ' || v_first_name || ' ' || v_last_name ||
                                ' (ID: ' || v_employee_id || ') is not eligible for bonus.');
            not_eligible_count := not_eligible_count + 1;
        END IF;
    END LOOP;
 
    -- Print summary counts
    DBMS_OUTPUT.PUT_LINE('Total eligible employees: ' || eligible_count);
    DBMS_OUTPUT.PUT_LINE('Total employees for consideration: ' || consider_count);
    DBMS_OUTPUT.PUT_LINE('Total employees not eligible: ' || not_eligible_count);
END Check_Bonus_Eligibility;

begin
Check_Bonus_Eligibility;
end;
----29-05-2025  Thursday-----------------------------------------------------------------------------------
didnt practice.

----30-05-2025  Friday-----------------------------------------------------------------------------------
Revise those thing that i have cover in this whole week.

----31-05-2025  Satuarday-----------------------------------------------------------------------------------

--A user-defined function (UDF) in SQL or PL/SQL is a function created by the user to perform a specific 
--task and return a single value. It's similar to a built-in function but custom-made to suit application logic.

--function
                system define function
                user define function 
--syntax
CREATE [OR REPLACE] FUNCTION function_name 
(
   parameter1 [IN] datatype,
   parameter2 [IN] datatype
   -- More parameters if needed
)
RETURN return_datatype
IS
   -- Variable declarations
   variable_name datatype;
BEGIN
   -- Function logic
   -- Must return a value
   RETURN value;
END;

--
CREATE OR REPLACE FUNCTION get_bonus (p_salary NUMBER)
RETURN NUMBER
IS
  v_bonus NUMBER;
BEGIN
  v_bonus := p_salary * 0.10;
  RETURN v_bonus;
END;

SELECT name, get_bonus(salary) FROM employees;
--
create or replace function fun1
return number
is
v_number number;
begin
v_number:=100;
return v_number;
end;

select fun1() from dual;

begin
dbms_output.put_line(fun1());
end;
--
select * from sys.employees;

--procedure may or may not return value
--function will return a value
--procedure is used to implement business logic
--function is used to compute the formulas
--generally DML operations will be handled in Procedure
--DML will not be a part of functions . we can do that we don do

--
create or replace function fun2 (p_employee_id number)
return number
is
v_number number;
begin
select round((sysdate-hire_date)/365,2) into v_number from hr.employees where employee_id=p_employee_id;
--v_number:=100;
return v_number;
end;

select fun2(111) from dual;
--
select count(*) ,employee_id from hr.employees group by employee_id having count(*) > 1;
--
CREATE OR REPLACE FUNCTION fun3 (
p_emp_id in number,
    p_emp_name OUT VARCHAR2,
    p_emp_salary OUT NUMBER
) RETURN VARCHAR2 IS
BEGIN
    SELECT first_name, salary INTO p_emp_name, p_emp_salary
    FROM hr.employees
    WHERE employee_id = p_emp_name;

    RETURN 'SUCCESS';
END;

declare
  p_emp_id NUMBER;
  p_emp_name VARCHAR2(100);
  p_emp_salary NUMBER;
  v_status varchar2(100);
begin
  p_emp_id:=101;
  v_status:= fun3(p_emp_id,p_emp_name,p_emp_salary);
    dbms_output.put_line(p_emp_name);
  dbms_output.put_line(p_emp_salary);
  dbms_output.put_line(v_status);
end;
---
-- Fixed Function
CREATE OR REPLACE FUNCTION fun3 (
   p_emp_id     IN  NUMBER,
   p_emp_name   OUT VARCHAR2,
   p_emp_salary OUT NUMBER
) RETURN VARCHAR2 IS
BEGIN
   SELECT first_name, salary
   INTO p_emp_name, p_emp_salary
   FROM hr.employees
   WHERE employee_id = p_emp_id;

   RETURN 'Success';
/*EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RETURN 'Employee not found';
   WHEN OTHERS THEN
      RETURN 'Error: ' || SQLERRM;*/
END;
/

-- Anonymous Block to Call the Function
DECLARE
   p_emp_id     NUMBER;
   p_emp_name   VARCHAR2(100);
   p_emp_salary NUMBER;
   v_status     VARCHAR2(100);
BEGIN
   p_emp_id := 109;
   v_status := fun3(p_emp_id, p_emp_name, p_emp_salary);

   DBMS_OUTPUT.PUT_LINE('Name: ' || p_emp_name);
   DBMS_OUTPUT.PUT_LINE('Salary: ' || p_emp_salary);
   DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);
END;
/
------------------------------------------------
CREATE OR REPLACE FUNCTION fun3 (
p_emp_id in number,
    p_emp_name OUT VARCHAR2,
    p_emp_salary OUT NUMBER
) RETURN number IS
BEGIN
    SELECT first_name, salary INTO p_emp_name, p_emp_salary
    FROM hr.employees
    WHERE employee_id = p_emp_id;

    RETURN 100;
END;

DECLARE
   p_emp_id     NUMBER;
   p_emp_name   VARCHAR2(100);
   p_emp_salary NUMBER;
   v_status     VARCHAR2(100);
BEGIN
   p_emp_id := 109;
   v_status := fun3(p_emp_id, p_emp_name, p_emp_salary);

   DBMS_OUTPUT.PUT_LINE('Name: ' || p_emp_name);
   DBMS_OUTPUT.PUT_LINE('Salary: ' || p_emp_salary);
   DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);
END;
--
-- Function Definition
CREATE OR REPLACE FUNCTION fun3 (
    p_emp_id IN NUMBER,
    p_emp_name OUT VARCHAR2,
    p_emp_salary OUT NUMBER
) RETURN VARCHAR2 IS
BEGIN
    SELECT first_name, salary
    INTO p_emp_name, p_emp_salary
    FROM hr.employees
    WHERE department_id = p_emp_id ;
  -- AND ROWNUM = 1;  -- ensures only one row returned

    RETURN 'SUCCESS';
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_emp_name := NULL;
        p_emp_salary := NULL;
        RETURN -1;
    WHEN TOO_MANY_ROWS THEN
       -- RETURN -2;
         DBMS_OUTPUT.PUT_LINE('Value more that 1' ) ;
    WHEN OTHERS THEN
        RETURN -3;
END;
/
DECLARE
   p_emp_id     NUMBER;
   p_emp_name   VARCHAR2(100);
   p_emp_salary NUMBER;
   v_status     VARCHAR2(100);
BEGIN
   p_emp_id := 20;
   v_status := fun3(p_emp_id, p_emp_name, p_emp_salary);

   DBMS_OUTPUT.PUT_LINE('Name   : ' || NVL(p_emp_name, 'N/A'));
   DBMS_OUTPUT.PUT_LINE('Salary : ' || NVL(TO_CHAR(p_emp_salary), 'N/A'));
   DBMS_OUTPUT.PUT_LINE('Status : ' || v_status);
END;
/

select count(*), department_id from hr.employees group by department_id;
---------------------------------------------------------------------------------
--10 functions with different computational logics

--examples of function 
--1
CREATE OR REPLACE FUNCTION greet_user1(name IN VARCHAR2) 
RETURN VARCHAR2 IS
BEGIN
    RETURN 'Hello, ' || name || '!';
END;
/
BEGIN
  DBMS_OUTPUT.PUT_LINE(greet_user1('John'));
END;
--2
CREATE OR REPLACE FUNCTION get_square(n IN NUMBER) 
RETURN NUMBER IS
BEGIN
    RETURN 'Square is: ' || n * n;
END;
/
BEGIN
  DBMS_OUTPUT.PUT_LINE('Square is: ' || get_square(5));
END;
--3
CREATE OR REPLACE FUNCTION get_salary(emp_id IN NUMBER)
RETURN NUMBER IS
  v_salary NUMBER;
BEGIN
  SELECT salary INTO v_salary FROM hr.employees WHERE employee_id = emp_id;
  RETURN v_salary;
END;
/
BEGIN
  DBMS_OUTPUT.PUT_LINE('Salary: ' || get_salary(101));
END;
--4
CREATE OR REPLACE FUNCTION get_all_salaries(dept_id IN NUMBER)
RETURN VARCHAR2 IS
  v_result VARCHAR2(4000);
BEGIN
  FOR emp_rec IN (SELECT employee_id, salary FROM hr.employees 
                  WHERE department_id = dept_id) 
  LOOP
    v_result := v_result || 'Emp ID: ' || emp_rec.employee_id || 
                ', Salary: ' || emp_rec.salary || CHR(10); -- CHR(10) is newline
  END LOOP;
  
  RETURN v_result;
END;
/

-- Usage:
BEGIN
  DBMS_OUTPUT.PUT_LINE(get_all_salaries(20)); -- Department 10
END;
--5
CREATE OR REPLACE FUNCTION emp_details1 (
  emp_id IN NUMBER,
  emp_name OUT VARCHAR2,
  emp_salary OUT NUMBER
) RETURN VARCHAR2 IS
BEGIN
  SELECT first_name, salary INTO emp_name, emp_salary FROM hr.employees WHERE employee_id = emp_id;
  RETURN 'FOUND';
END;
/
declare 
emp_name varchar2(50);
emp_salary number;
c varchar2(100);
begin
   c := emp_details1(101,emp_name,emp_salary);
  DBMS_OUTPUT.PUT_LINE(emp_name);
    DBMS_OUTPUT.PUT_LINE(emp_salary);
      DBMS_OUTPUT.PUT_LINE(c);
      end;
--6
-- Assumes this function exists
CREATE OR REPLACE FUNCTION bonus_percentage(salary IN NUMBER)
RETURN NUMBER IS
BEGIN
  RETURN salary * 0.10;
END;
/

-- Use in SQL
SELECT first_name, salary, bonus_percentage(salary) AS bonus
FROM hr.employees;
--7
CREATE OR REPLACE FUNCTION check_pass(marks IN NUMBER)
RETURN VARCHAR2 IS
BEGIN
  IF marks >= 50 THEN
    RETURN 'PASS';
  ELSE
    RETURN 'FAIL';
  END IF;
END;
/
BEGIN
  DBMS_OUTPUT.PUT_LINE('Result: ' || check_pass(65));  -- Will print "PASS"
  DBMS_OUTPUT.PUT_LINE('Result: ' || check_pass(42));  -- Will print "FAIL"
END;
/
SELECT student_id, marks, check_pass(marks) AS result
FROM student_grades;
--8
-- Step 1: Create object type
CREATE OR REPLACE TYPE emp_obj AS OBJECT (
  emp_name   VARCHAR2(100),
  emp_salary NUMBER
);
/

-- Step 2: Function that returns object
CREATE OR REPLACE FUNCTION get_emp_obj(emp_id IN NUMBER)
RETURN emp_obj IS
  v_name hr.employees.first_name%TYPE;
  v_salary hr.employees.salary%TYPE;
BEGIN
  SELECT first_name, salary INTO v_name, v_salary FROM hr.employees WHERE employee_id = emp_id;
  RETURN emp_obj(v_name, v_salary);
END;
/
-- call this 
DECLARE
  v_emp emp_obj;
BEGIN
  v_emp := get_emp_obj(101);
  DBMS_OUTPUT.PUT_LINE('Name: ' || v_emp.emp_name);
  DBMS_OUTPUT.PUT_LINE('Salary: ' || v_emp.emp_salary);
END;


--------------------Practice Quation
--1.Create a function square_num that takes a number as input and returns its square.

create or replace function f_square(value1 in number) return number is

begin
  return value1 * value1;
end;

declare a number := &num;
BEGIN
DBMS_OUTPUT.PUT_LINE('Square root of : ' || a || ' is : ' || f_square(a));
END;

select f_square(5) from dual;
--Way 2
create or replace function f1 return number is
  square_num number;
begin
  square_num := 2 * 2;
  return square_num;
end;

select f1 from dual;

--2.Write a function is_even that accepts a number and returns 'YES' if its even, otherwise 'NO'.

create or replace function f1(v1 in number) return varchar2 is
begin
  if mod(v1, 2) = 0 then
    return 'yes it is a even number.';
  else
    return 'No it is not even number.';
  end if;
end;

declare
  a varchar2(100);
  b number := 10;
begin
  a := f1(b);
  dbms_output.put_line(a || ' The given number is : ' || b);
end;

select f1(5) from dual ;
--way 2
create or replace function f1(p_value number) return number is
begin
  if mod(p_value, 2) = 0 then
    dbms_output.put_line('yes');
  else
    dbms_output.put_line('no');
  end if;
end;

declare
  p_value number := &p_value;
  result  number;
begin
  result := f1(p_value);
  dbms_output.put_line(result);
end;
 
--3.Write a function get_full_name that accepts first name and last name and returns full name 
--(concatenated with a space).
create or replace function f1(f_name in varchar2, l_name in varchar2)
  return varchar2 is
begin
  return f_name || ' ' || l_name;
end;
  
select f1('Data','Engineear') from dual ;

declare
  a varchar2(50) := '&f_name';
  b varchar2(50) := '&l_name';
  c varchar2(100);
begin
  c := f1(a, b);
  dbms_output.put_line(c);
end;
--way 2
create or replace function f1(p_fname in varchar2, p_lname in varchar2)
  return varchar2 is
  full_name varchar2(100);
begin
  full_name := p_fname || p_lname;
  return full_name;
end;

declare
  a       varchar2(100);
  p_fname varchar2(100) := '&p_fname';
  p_lname varchar2(100) := '&p_lname';
begin
  a := f1(p_fname, p_lname);
  dbms_output.put_line(a);
end;
 
--4.Create a function calculate_area that takes radius as input and returns the area of a circle ( * r).

create or replace function f1(e in number) return number is
begin
  return 3.14 * e * e;
end;
  
select f1(5) from dual; 

--way 2
create or replace function f1(e in number) return number is
v number;
begin
  v := 3.14 * e * e;
  return v;
end;

--5.Write a function get_employee_salary that accepts employee_id and returns that 
--employees salary from the hr.employees table.
 
create or replace function f1(eid number) return number is
  v_sal number;
begin
  select salary into v_sal from hr.employees where employee_id = eid and rownum <= 2;
  return v_sal;
end;
  
select f1(101) from dual;


--6.Create a function get_initial that accepts a string and returns the first character in uppercase.

create or replace function f1(p_string varchar2) return varchar2 is
begin
  return initcap(p_string);
end;

select f1('shubham') from dual;

declare
  a varchar2(50) := '&ch';
  b varchar2(50);
begin
  b := f1(a);
  dbms_output.put_line (b);
end;
--way
CREATE OR REPLACE FUNCTION f1(p_string VARCHAR2) 
RETURN VARCHAR2 IS
BEGIN
  RETURN UPPER(SUBSTR(p_string, 1, 1));
END;

SELECT f1('shubham') FROM dual;

--7.Write a function check_pass_fail that takes a marks number and returns 'PASS' if marks >= 50, else 'FAIL'.

create or replace function f1(marks number) return varchar2 is
begin
  if marks >= 50 then
    return 'Pass';
  else
    return 'Fail';
  end if;
end;
      
select f1(30) from dual;

declare
  a number := &valu;
  b varchar2(50);
begin
  b := f1(a);
  dbms_output.put_line(b);
end;

--way 2
CREATE OR REPLACE FUNCTION f1(marks NUMBER)
RETURN VARCHAR2 IS
BEGIN
  RETURN CASE WHEN marks >= 50 THEN 'Pass' ELSE 'Fail' END;
END;
/


  --8.Create a function get_department_name that accepts department_id and returns the 
  --department name from the hr.departments table.

  create or replace function get_department_name(dptid number)
    return varchar2 is
    dpt_name varchar2(50);
  begin
    select department_name
      into dpt_name
      from hr.departments
     where department_id = dptid
       and rownum <= 2;
    return dpt_name;
  end;
    
  select get_department_name(70) from dual ;
--way 2
create or replace function get_department_name(dptid number)
  return varchar2 is
  dpt_name varchar2(50);
begin
  for rec in (select department_name
    from hr.departments
   where department_id = dptid) loop
   dpt_name := rec.department_name;
   dbms_output.put_line(dpt_name) ;
   end loop;
   return dpt_name;
end;
  
select get_department_name(90) from dual ;

--9.Write a function concat_strings that accepts two strings and returns their concatenation 
--with a dash between them.
create or replace function concat_strings(a in varchar2, b in varchar2)
  return varchar2 is
begin
  return a || ' - ' || b;
end;
  
select concat_strings('Data','Engineear') from dual;

--10.Create a function get_employee_count that returns the total number of employees in the hr.employees table.

create or replace function get_employee_count return number is
  t_count number;
begin
  select count(*) into t_count from hr.employees;
  return t_count;
end;

select get_employee_count() from dual;

----1-06-2025  Sunday-----------------------------------------------------------------------------------

-- a package is a collection of related procedures, functions, variables, cursors, and exceptions grouped together under one name. It helps in modularizing code, reusing logic, and organizing programs efficiently.


--syntax
CREATE OR REPLACE PACKAGE package_name IS
  -- Public procedure/function declarations
  FUNCTION get_square(n NUMBER) RETURN NUMBER;
  PROCEDURE greet_user(name VARCHAR2);
END package_name;
/

CREATE OR REPLACE PACKAGE BODY package_name IS

  FUNCTION get_square(n NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN n * n;
  END;

  PROCEDURE greet_user(name VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello, ' || name || '!');
  END;

END package_name;
/
DECLARE
  res NUMBER;
BEGIN
  res := package_name.get_square(5);
  DBMS_OUTPUT.PUT_LINE('Square is: ' || res);

  package_name.greet_user('Shubham');
END;
/
--ex
CREATE OR REPLACE PACKAGE emp_pkg IS
  FUNCTION get_salary(eid NUMBER) RETURN NUMBER;
  PROCEDURE show_employee(eid NUMBER);
END emp_pkg;
/

CREATE OR REPLACE PACKAGE BODY emp_pkg IS

  FUNCTION get_salary(eid NUMBER) RETURN NUMBER IS
    sal NUMBER;
  BEGIN
    SELECT salary INTO sal FROM hr.employees WHERE employee_id = eid;
    RETURN sal;
  END;

  PROCEDURE show_employee(eid NUMBER) IS
    fname hr.employees.first_name%TYPE;
  BEGIN
    SELECT first_name INTO fname FROM hr.employees WHERE employee_id = eid;
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || fname);
  END;

END emp_pkg;
/
BEGIN
  DBMS_OUTPUT.PUT_LINE('Salary: ' || emp_pkg.get_salary(100));
  emp_pkg.show_employee(100);
END;
/
--------overloading
CREATE OR REPLACE PACKAGE emp_logger_pkg IS
  PROCEDURE log_emp(eid NUMBER);
  PROCEDURE log_emp(ename VARCHAR2, sal NUMBER);
END emp_logger_pkg;
/
CREATE OR REPLACE PACKAGE BODY emp_logger_pkg IS

  PROCEDURE log_emp(eid NUMBER) IS
    v_name hr.employees.first_name%TYPE;
    v_salary hr.employees.salary%TYPE;
  BEGIN
    SELECT first_name, salary INTO v_name, v_salary
    FROM hr.employees
    WHERE employee_id = eid;

    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || eid || ', Name: ' || v_name || ', Salary: ' || v_salary);
  END;

  PROCEDURE log_emp(ename VARCHAR2, sal NUMBER) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || ename || ', Salary: ' || sal);
  END;

END emp_logger_pkg;
/
BEGIN
  emp_logger_pkg.log_emp(100); -- Using ID
  --emp_logger_pkg.log_emp('Shubham', 50000); -- Using Name and Salary
END;
/
---trigger
create or replace trigger ad_eba_cust_customers
after delete on eba_cust_customers
for each row
begin
  insert into eba_cust_history (table_name, component_rowkey, component_id, column_name, old_value, new_value)
  values
  ('CUSTOMERS', :old.row_key, :old.id, 'CUSTOMER_REMOVED', substr(:old.customer_name,0,4000), null );
end ad_eba_cust_customers;
---compound trigger
create or replace trigger au_eba_cust_cust_competitor_re
after insert or update or delete on eba_cust_cust_competitor_ref
for each row
declare
  pragma autonomous_transaction;
  ov varchar2(4000) := null;
  nv varchar2(4000) := null;
begin
  ov := null; nv := null;
  for cl in (select name val from eba_cust_competitors t where t.id = :old.competitor_id) loop
    ov := cl.val;
  end loop;
  for cl in (select name val from eba_cust_competitors t where t.id = :new.competitor_id) loop
    nv := cl.val;
  end loop;
  insert into eba_cust_history (table_name, component_rowkey, component_id, column_name, old_value, new_value) values
  ('CUSTOMERS', nvl(:new.customer_id,:old.customer_id), 'COMPETITOR_ID', ov, nv);
  commit;
end au_eba_cust_cust_competitor_re;

----------------  Examples of trigger

CREATE TABLE employees_audit (
    emp_id      NUMBER,
    action_type VARCHAR2(20),
    action_date DATE
);

CREATE TABLE employee (
    emp_id    NUMBER PRIMARY KEY,
    name      VARCHAR2(50),
    salary    NUMBER
);

INSERT INTO employee VALUES (101, 'Alice', 55000);
INSERT INTO employee VALUES (102, 'Bob', 60000);
INSERT INTO employee VALUES (103, 'Charlie', 50000);
INSERT INTO employee VALUES (104, 'David', 62000);
INSERT INTO employee VALUES (105, 'Eva', 58000);

truncate table employee ;

select * from employee;
select * from employees_audit;

-- 1. BEFORE STATEMENT Trigger (on INSERT)
--Fires once before the whole INSERT statement, not for each row.

CREATE OR REPLACE TRIGGER trg_before_insert_stmt
BEFORE INSERT ON employee
BEGIN
  DBMS_OUTPUT.PUT_LINE('BEFORE STATEMENT LEVEL INSERT TRIGGER FIRED.');
END;
--Explanation: Executes once before any row is inserted.
drop trigger trg_before_insert_stmt;

-- 2. AFTER STATEMENT Trigger (on DELETE)
--Fires once after the entire DELETE statement finishes.

CREATE OR REPLACE TRIGGER trg_after_delete_stmt
AFTER DELETE ON employee
BEGIN
  DBMS_OUTPUT.PUT_LINE('AFTER STATEMENT LEVEL DELETE TRIGGER FIRED.');
END;
--Explanation: Executes once after the delete operation finishes (regardless of how many rows were affected).
drop trigger trg_after_delete_stmt;

--3. BEFORE EACH ROW Trigger (on UPDATE)
--Fires once per row before it's updated.

CREATE OR REPLACE TRIGGER trg_before_update_row
BEFORE UPDATE ON employee
FOR EACH ROW
BEGIN
  DBMS_OUTPUT.PUT_LINE('BEFORE ROW LEVEL UPDATE TRIGGER FIRED for Emp ID: ' || :OLD.emp_id);
END;
--Explanation: Executes once for each row being updated, and can access :OLD and :NEW values.
drop trigger trg_before_update_row;

-- 4. AFTER EACH ROW Trigger (on INSERT)
--Used for auditing or logging inserted rows.

CREATE OR REPLACE TRIGGER trg_after_insert_row
AFTER INSERT ON employee
FOR EACH ROW
BEGIN
  INSERT INTO employees_audit (emp_id, action_type, action_date)
  VALUES (:NEW.emp_id, 'INSERT', SYSDATE);
  
  DBMS_OUTPUT.PUT_LINE('AFTER ROW LEVEL INSERT: Emp ID = ' || :NEW.emp_id);
END;
--Explanation: Executes once for each inserted row and logs it into the employees_audit table.
drop trigger trg_after_insert_row ;
-- INSERT (fires BEFORE STATEMENT and AFTER EACH ROW)
INSERT INTO employee VALUES (106, 'Frank', 61000);

-- UPDATE (fires BEFORE EACH ROW)
UPDATE employee SET salary = salary + 1000 WHERE emp_id IN (101, 102);

-- DELETE (fires AFTER STATEMENT)
DELETE FROM employee WHERE emp_id = 105;

select * from employees_audit;

----05-06-2025  Thursday-----------------------------------------------------------------------------------
select * from employee;
select * from employees_audit;
truncate table employees_audit;
--Before each row level trigger.
--1.
create or replace trigger trg_before_row_ins_emp
  before insert on employee
  for each row
begin
  :NEW.name := UPPER(:NEW.name);
  dbms_output.put_line('Before insert on each row trigger are sucessfully fired');
end;

ALTER TRIGGER trg_before_row_ins_emp ENABLE;

--2.
create or replace trigger trg_before_row_upd_emp
  before update on employee
  for each row
begin
  IF :NEW.salary < :OLD.salary THEN
    RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be decreased!');

  END IF;
         DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);

  dbms_output.put_line('Before update on each row trigger are sucessfully fired');
end;

CREATE OR REPLACE TRIGGER trg_before_row_upd_emp
BEFORE UPDATE ON employee
FOR EACH ROW
BEGIN
  IF :NEW.salary < :OLD.salary THEN
    DBMS_OUTPUT.PUT_LINE('Trigger Error: Salary cannot be decreased!');
    RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be decreased!');
  END IF;

  DBMS_OUTPUT.PUT_LINE('Before update on each row trigger fired');
END;

--3.
create or replace trigger trg_before_row_det_emp
  before delete on employee
  for each row
begin
  IF :OLD.salary > 100000 THEN
      dbms_output.put_line('Before delete on each row trigger are sucessfully fired');

    RAISE_APPLICATION_ERROR(-20002,
                            'High salary employee cannot be deleted!');
  END IF;
         DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
  dbms_output.put_line('Before delete on each row trigger are sucessfully fired');
end;

--After each row level trigger.
--1.
create or replace trigger trg_after_row_ins_emp
  after insert on employee
  for each row
begin
  INSERT INTO employees_audit
    (emp_id, action_type, action_date)
  VALUES
    (:NEW.emp_id, 'ROW_INSERT', SYSDATE);
  dbms_output.put_line('After insert on each row trigger are sucessfully fired');
end;
--2.
create or replace trigger trg_aftere_row_upd_emp
  after update on employee
  for each row
begin
  INSERT INTO employees_audit
    (emp_id, action_type, action_date)
  VALUES
    (:NEW.emp_id, 'ROW_UPDATE', SYSDATE);
  dbms_output.put_line('After update on each row trigger are sucessfully fired');
end;
--3.
create or replace trigger trg_aftere_row_det_emp
  after delete on employee
  for each row
begin
  INSERT INTO employees_audit
    (emp_id, action_type, action_date)
  VALUES
    (:OLD.emp_id, 'ROW_DELETE', SYSDATE);
  dbms_output.put_line('After delete on each row trigger are sucessfully fired');
end;

--Before statement level trigger
--1.
create or replace trigger trg_before_sta_ins_emp
  before insert on employee
begin
  dbms_output.put_line('Before insert on statement level trigger are sucessfully fired');
end;
--2.
create or replace trigger trg_before_sta_upd_emp
  before update on employee
begin
  dbms_output.put_line('Before update on statement level trigger are sucessfully fired');
end;
--3.
create or replace trigger trg_before_sta_det_emp
  before delete on employee
begin
  dbms_output.put_line('Before delete on statement level trigger are sucessfully fired');
end;

--After statement level trigger
--1.
create or replace trigger trg_after_sta_ins_emp
  after insert on employee
begin
  dbms_output.put_line('Data sucessfully inserted for employee table');
end;
--2.
create or replace trigger trg_after_sta_upd_emp
  after update on employee
begin
  dbms_output.put_line('Data sucessfully updated for employee table');
end;
--3.
create or replace trigger trg_after_sta_det_emp
  after delete on employee
begin
  dbms_output.put_line('Data sucessfully deleted for emloyee table');
end;

ALTER SESSION SET CURRENT_SCHEMA = shubh;


select * from employee;
select * from employees_audit;

truncate table employees_audit;
--4 trigger will fired.
INSERT INTO employee VALUES (106, 'Nikhil', 110000);

--it throw en error because we apply condition in before update on each row trigger
--NEW.SALARY < OLD.SALARY not allowed.
update employee set salary=8000 where emp_id = 107; 

update employee set salary=11000 where emp_id = 107; --sucessfully fired. 

--it throw an error because we apply condition on before each row level trigger
--salary > 100000 can't be delete.
delete employee where emp_id = 106;

delete employee where emp_id = 107; -- sucessfully deleted because salary < 100000;


---------  Package 

--A package is a collection of related procedures, functions, variables, cursors, 
--and other PL/SQL constructs grouped together in a single unit.
--**It has two parts:
-- 1. Package Specification (what is available publicly)
-- 2. Package Body (actual code/logic for those procedures/functions)

-- Basic Syntax
-- 1. Package Specification
CREATE OR REPLACE PACKAGE emp_pkg AS
  PROCEDURE add_employee(p_id NUMBER, p_name VARCHAR2, p_salary NUMBER);
  FUNCTION get_total_employees RETURN NUMBER;
END emp_pkg;

-- 2. Package Body
CREATE OR REPLACE PACKAGE BODY emp_pkg AS

  PROCEDURE add_employee(p_id NUMBER, p_name VARCHAR2, p_salary NUMBER) IS
  BEGIN
    INSERT INTO employee (emp_id, name, salary)
    VALUES (p_id, p_name, p_salary);
  END;

  FUNCTION get_total_employees RETURN NUMBER IS
    v_total NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_total FROM employee;
    RETURN v_total;
  END;

END emp_pkg;
-----
-- Example 1: Package for Employee Operations
CREATE OR REPLACE PACKAGE employee_pkg AS
  PROCEDURE raise_salary(p_emp_id NUMBER, p_percent NUMBER);
  FUNCTION get_salary(p_emp_id NUMBER) RETURN NUMBER;
END employee_pkg;
--Package Body:
CREATE OR REPLACE PACKAGE BODY employee_pkg AS

  PROCEDURE raise_salary(p_emp_id NUMBER, p_percent NUMBER) IS
  BEGIN
    UPDATE employee
    SET salary = salary + (salary * p_percent / 100)
    WHERE emp_id = p_emp_id;
  END;

  FUNCTION get_salary(p_emp_id NUMBER) RETURN NUMBER IS
    v_salary NUMBER;
  BEGIN
    SELECT salary INTO v_salary
    FROM employee
    WHERE emp_id = p_emp_id;
    RETURN v_salary;
  END;

END employee_pkg;
--Call from SQL*Plus or PL/SQL:
BEGIN
  employee_pkg.raise_salary(107, 10);
  DBMS_OUTPUT.PUT_LINE('New Salary: ' || employee_pkg.get_salary(107));
END;

-- Example 2: Package with Global Variable
CREATE OR REPLACE PACKAGE session_pkg AS
  g_user_name VARCHAR2(100); -- Global variable
  PROCEDURE set_user(p_name VARCHAR2); 
  PROCEDURE show_user;
END session_pkg;

CREATE OR REPLACE PACKAGE BODY session_pkg AS

  PROCEDURE set_user(p_name VARCHAR2) IS
  BEGIN
    g_user_name := p_name;
  END;

  PROCEDURE show_user IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Current User: ' || g_user_name);
  END;

END session_pkg;

BEGIN
  session_pkg.set_user('Shubham');
  session_pkg.show_user;
END;

--Practice
-- Q1: Math Utility Package
--Create a package math_utils_pkg with:
--A function square(p_number NUMBER) RETURN NUMBER
--A function cube(p_number NUMBER) RETURN NUMBER
--A procedure show_result(p_number NUMBER) that prints both square and cube

create or replace package math_utils_pkg as
  function square(p_number number) return number;
  function cube1(p_number number) return number;
  procedure show_result(p_number number);
  v_num  number;
  v_num1 number;
end;

create or replace package body math_utils_pkg as
function square(p_number number) return number is
begin
-- v_num := p_number * p_number;
return p_number * p_number;
end;

function cube1(p_number number) return number is
begin
--v_num1 := p_number * p_number * p_number;
return p_number * p_number * p_number;
end;

procedure show_result(p_number number) is
square1 number; cube11 number;
begin
square1 := square(p_number); cube11 := cube1(p_number);

dbms_output.put_line('Square : ' || square1); dbms_output.put_line('Cube : ' || cube11);
end;
end math_utils_pkg;

begin
math_utils_pkg.show_result(5);
end;

----06-06-2025  Friday-----------------------------------------------------------------------------------

CREATE TABLE student1 (
  rollno NUMBER PRIMARY KEY,
  name   VARCHAR2(50),
  marks  NUMBER
);

select * from student1;

--Create a package student_pkg with:
--A procedure add_student(p_id NUMBER, p_name VARCHAR2, p_marks NUMBER)
--A function get_grade(p_id NUMBER) RETURN VARCHAR2
--(Return A/B/C based on marks: A  75, B  50, C otherwise)

create or replace package student_pkg as
procedure  add_student (p_id NUMBER, p_name VARCHAR2, p_marks NUMBER) ;
function  get_grade (p_id NUMBER) RETURN VARCHAR2 ;
end ;

create or replace package body student_pkg as
  procedure add_student(p_id NUMBER, p_name VARCHAR2, p_marks NUMBER) is
  begin
    insert into student1
      (rollno, name, marks)
    values
      (p_id, p_name, p_marks);
  end;

  function get_grade(p_id NUMBER) RETURN VARCHAR2 is
    v_grade varchar2(1);
    v_marks number;
  begin
    select marks into v_marks from student1 where rollno = p_id;
    if v_marks >= 75 then
      v_grade := 'A';
    elsif v_marks >= 50 then
      v_grade := 'B';
    else
      v_grade := 'C';
    end if;
    return v_grade;
  end;

end student_pkg;

begin
  student_pkg.add_student(101, 'Ravi', 95);
  dbms_output.put_line(student_pkg.get_grade(101));
end;


--     Q3: Global Counter Package
--Create a package counter_pkg with:
--A global variable g_counter (initial value 0)
--A procedure increment_counter
--A procedure reset_counter
--A function get_counter RETURN NUMBER

create or replace package counter_pkg as
  -- g_counter number := 0;
  procedure increment_counter;
  procedure reset_counter;
  function get_counter RETURN NUMBER;
end;

 create or replace package body counter_pkg as
   g_counter number := 0;

   procedure increment_counter is
     v_count number := 1;
   begin
     g_counter := g_counter + v_count;
     dbms_output.put_line('Counter increment : ' || g_counter);
   end;
 
   procedure reset_counter is
   begin
     g_counter := 0;
     dbms_output.put_line('Counter reset : ' || g_counter);
   end;
 
   function get_counter return number is
   begin
     return g_counter;
   end;
 end counter_pkg;

begin
  counter_pkg.increment_counter;
  counter_pkg.increment_counter;
  dbms_output.put_line('current counter : ' || counter_pkg.get_counter);
  counter_pkg.reset_counter;
  dbms_output.put_line('After reset : ' || counter_pkg.get_counter);
end;

--     Q4: Salary Validation Package
--Given this table:
CREATE TABLE employe1 (
    emp_id   NUMBER PRIMARY KEY,
    name     VARCHAR2(50),
    salary   NUMBER
);
INSERT INTO employe1 (emp_id, name, salary) VALUES (101, 'Shubham', 50000);
INSERT INTO employe1 (emp_id, name, salary) VALUES (102, 'Nikita', 60000);
INSERT INTO employe1 (emp_id, name, salary) VALUES (103, 'Rohan', 45000);
INSERT INTO employe1 (emp_id, name, salary) VALUES (104, 'Priya', 70000);
INSERT INTO employe1 (emp_id, name, salary) VALUES (105, 'Amit', 55000);
--Create a package salary_pkg with:
--A procedure update_salary(p_id NUMBER, p_new_salary NUMBER)
--Raise error if new salary < 10000
--A function get_salary(p_id NUMBER) RETURN NUMBER

create or replace package salary_pkg as
procedure update_salary(p_id NUMBER, p_new_salary NUMBER);
function get_salary(p_id NUMBER) RETURN NUMBER ;
end;

create or replace package body salary_pkg as
  procedure update_salary(p_id NUMBER, p_new_salary NUMBER) is
  begin
    if p_new_salary < 10000 then
      RAISE_APPLICATION_ERROR(-20001, 'Salary must be at least 10000');
    --  DBMS_OUTPUT.PUT_LINE('p_new_salary < 10000 not allowed ' || p_id);
    end if;
    update employe1 set salary = p_new_salary where emp_id = p_id; 
        DBMS_OUTPUT.PUT_LINE('Salary updated for emp_id ' || p_id);

  end;

  function get_salary(p_id NUMBER) RETURN NUMBER is
    v_sal number;
  begin
    select salary into v_sal from employe1 where emp_id = p_id;
    return v_sal;
  end;
end salary_pkg;
      
begin
  salary_pkg.update_salary(101, 9000);
  dbms_output.put_line('current salary is : ' || salary_pkg.get_salary(101) );
end;

select * from employe1 where emp_id = 101 ;



-- Q5: Bank Account Package
Given this table:
CREATE TABLE account (
    acc_no   NUMBER PRIMARY KEY,
    name     VARCHAR2(50),
    balance  NUMBER
);

--Create a package bank_pkg with:
--A procedure deposit(p_acc_no NUMBER, p_amount NUMBER)
--A procedure withdraw(p_acc_no NUMBER, p_amount NUMBER)
--Raise error if withdrawal amount > balance
--A function get_balance(p_acc_no NUMBER) RETURN NUMBER

create or replace package bank_pkg as 
procedure deposit(p_acc_no NUMBER, p_amount NUMBER) ;
 procedure withdraw(p_acc_no NUMBER, p_amount NUMBER);
function get_balance(p_acc_no NUMBER) RETURN NUMBER;
end;

create or replace package body bank_pkg is

  procedure deposit(p_acc_no NUMBER, p_amount NUMBER) is
    v_balance number;
    v_total number := 0 ;
  begin
    select balance into v_balance from account where acc_no = p_acc_no;
    update account
       set balance = balance + p_amount
     where acc_no = p_acc_no;
     v_total := v_balance + p_amount ;
    dbms_output.put_line('Blance succesfully updated : ' || v_total);
  end;

  procedure withdraw(p_acc_no NUMBER, p_amount NUMBER) is
    -- v_with number ;
    v_bal number;
  begin
    select balance into v_bal from account where acc_no = p_acc_no;
    if p_amount > v_bal then
      RAISE_APPLICATION_ERROR(-20001, 'Amount must be less than balance');
      --dbms_output.put_line('Amount should be less that current balance');
    else
      --v_bal < p_amount then --v_with := v_bal - p_amount ;
      update account
         set balance = balance - p_amount
       where acc_no = p_acc_no;
      dbms_output.put_line('Balance sucessfully withdraw : ' || p_amount);
    
    end if;
  end;

  function get_balance(p_acc_no NUMBER) RETURN NUMBER is
    v_balance number;
  begin
    select balance into v_balance from account where acc_no = p_acc_no;
    return v_balance;
  end;
end bank_pkg;

begin
  bank_pkg.deposit(201,10000) ;
  bank_pkg.withdraw(201,15000);
  dbms_output.put_line('Current balance is : ' || bank_pkg.get_balance(201));
end;

select balance from account where acc_no = 201;

--------------------07-06-2025 Satuarday----------------------------
--collections in oracle

--Collections are the advance plsql programming part;
--where you will be able to process data in bulk ; it is going to improve the performance of your program

--index by table (associative array) PLSQL TABLE
--nested table
--v array

--associative array cannot be saved into DB, It will be a part of your program only --unbound size is variable
--nested table can be created and stored in db like your normal table -- unbound size is variable
--v-array --bound size is fixed

CREATE OR REPLACE PROCEDURE PROC_ASSOCIATIVE_ARR_BULK AS
  cursor c is
    select dbms_random.value(1, 1000000) employee_id,
           dbms_random.string('a', 26) first_name,
           dbms_random.string('a', 26) last_name,
           dbms_random.string('a', 26) || '@mail.com' email,
           dbms_random.value(1, 100) phone_number,
           '01-01-25' hiredate,
           'Housekeep' job_id,
           dbms_random.value(1, 100) salary,
           null commission_pct,
           null manager_id,
           null department_id
      from emp;
  type t is table of c%rowtype index by pls_integer;
  l_tbl t;
BEGIN
  open c;
  loop
    fetch c bulk collect
      into l_tbl;
  
    forall i in 1 .. 100000
    
      insert into emp --create table structure then run code
        (employee_id,
         first_name,
         last_name,
         email,
         phone_number,
         hire_date,
         job_id,
         salary,
         commission_pct,
         manager_id,
         department_id)
      values
        (l_tbl(i).employee_id,
         l_tbl(i).first_name,
         l_tbl(i).last_name,
         l_tbl(i).email,
         l_tbl(i).phone_number,
         l_tbl(i).hiredate,
         l_tbl(i).job_id,
         l_tbl(i).salary,
         l_tbl(i).commission_pct,
         l_tbl(i).manager_id,
         l_tbl(i).department_id);
  
    exit when c%notfound;
  
  end loop;
  close c;
END;


/*COLLECTION_IS_NULL
You try to operate on an atomically null collection.

NO_DATA_FOUND
A subscript designates an element that was deleted, or a nonexistent element of an associative array.

SUBSCRIPT_BEYOND_COUNT
A subscript exceeds the number of elements in a collection.

SUBSCRIPT_OUTSIDE_LIMIT
A subscript is outside the allowed range.
*/

CREATE OR REPLACE PROCEDURE proc_associative_arr_bulk AS
    CURSOR c IS 
    SELECT
        employee_id,
        first_name,
        last_name,
        email,
        phone_number,
        hire_date,
        job_id,
        salary,
        --commission_pct,
        manager_id,
        department_id
    FROM
        emp1;
 
    TYPE t IS
        TABLE OF c%rowtype;
    l_tbl t;

BEGIN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE EMP5';
    
    OPEN c;

    LOOP
        FETCH c
        BULK COLLECT INTO l_tbl LIMIT 100000;
        
        EXIT WHEN l_tbl.COUNT = 0;  -- Exit when no more rows
        
        FORALL i IN 1..l_tbl.COUNT
            INSERT INTO emp5 (
                employee_id,
                first_name,
                last_name,
                email,
                phone_number,
                hire_date,
                job_id,
                salary,
                --commission_pct,
                manager_id,
                department_id
            ) VALUES ( l_tbl(i).employee_id,
                       l_tbl(i).first_name,
                       l_tbl(i).last_name,
                       l_tbl(i).email,
                       l_tbl(i).phone_number,
                       l_tbl(i).hire_date,
                       l_tbl(i).job_id,
                       l_tbl(i).salary,
                       --l_tbl(i).commission_pct,
                       l_tbl(i).manager_id,
                       l_tbl(i).department_id );
    END LOOP;
 
    CLOSE c;
    
    -- Gather stats after all data is loaded
    dbms_stats.gather_table_stats(
        ownname => 'SYS',
        tabname => 'EMP1',
        cascade => TRUE
    );

EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line('errrr:-'
                             || dbms_utility.format_error_stack
                             || dbms_utility.format_error_backtrace);
        IF c%ISOPEN THEN
            CLOSE c;
        END IF;
END proc_associative_arr_bulk;
/

BEGIN
  proc_associative_arr_bulk;
END;
/


select count(*) from emp5 ;
select count(*) from emp1 ;

truncate table emp5 ;
drop table emp1;

SELECT owner, table_name
FROM all_tables
WHERE table_name = 'EMP1';

SELECT USER FROM DUAL;

SELECT owner EMP5 FROM all_tables  --  Missing comma!


---------------------08-06-2025 Sunday---------------------------------

select count(*) from emp5;

CREATE OR REPLACE PACKAGE pkg_employee AS
    PROCEDURE add_employee(p_emp_id NUMBER, p_name VARCHAR2, p_salary NUMBER);
    PROCEDURE update_salary(p_emp_id NUMBER, p_new_salary NUMBER);
    PROCEDURE get_employee_details(p_emp_id NUMBER);
END pkg_employee;
/
 
CREATE OR REPLACE PACKAGE BODY pkg_employee AS
 
    -- Procedure to add a new employee
    PROCEDURE add_employee(p_emp_id NUMBER, p_name VARCHAR2, p_salary NUMBER) IS
    BEGIN
        INSERT INTO employees (employee_id, first_name, salary) VALUES (p_emp_id, p_name, p_salary);
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Employee added successfully.');
    END add_employee;
 
    -- Procedure to update employee salary
    PROCEDURE update_salary(p_emp_id NUMBER, p_new_salary NUMBER) IS
    BEGIN
        UPDATE employees SET salary = 120/0 WHERE employee_id = p_emp_id;
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Salary updated successfully.');
        exception when others
        then 
        DBMS_OUTPUT.PUT_LINE('Err:-'||dbms_utility.format_error_stack||
            dbms_utility.format_error_backtrace);
    END update_salary;
 
    -- Procedure to fetch employee details
    PROCEDURE get_employee_details(p_emp_id NUMBER) IS
        v_name employees.first_name%TYPE;
        v_salary employees.salary%TYPE;
    BEGIN
        SELECT first_name, salary INTO v_name, v_salary FROM employees WHERE employee_id = p_emp_id;
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name || ', Salary: ' || v_salary);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No employee found with ID ' || p_emp_id);
    END get_employee_details;
 
END pkg_employee;
/
 
CREATE OR REPLACE PACKAGE pkg_salary_manager AS
    PROCEDURE increase_salary(p_emp_id NUMBER, p_increment NUMBER);
END pkg_salary_manager;
/
 
CREATE OR REPLACE PACKAGE BODY pkg_salary_manager AS
 
    PROCEDURE increase_salary(p_emp_id NUMBER, p_increment NUMBER) IS
        v_current_salary employees.salary%TYPE;
    BEGIN
        -- Fetch current salary
        SELECT salary INTO v_current_salary FROM employees WHERE employee_id = p_emp_id;
 
        -- Increase salary
        pkg_employee.update_salary(p_emp_id, v_current_salary + p_increment);
        DBMS_OUTPUT.PUT_LINE('Salary increased successfully.');
    EXCEPTION
        WHEN others THEN
            DBMS_OUTPUT.PUT_LINE('Err:-'||dbms_utility.format_error_stack||
            dbms_utility.format_error_backtrace);
    END increase_salary;
 
END pkg_salary_manager;
/
 
 
BEGIN
    --pkg_employee.add_employee(101, 'John Doe', 50000);
    pkg_salary_manager.increase_salary(110, 5000);
    --pkg_employee.get_employee_details(101);
END;

---------------------------------------------------------------------------------------------------------------

-------------------------------collection -------------------------------------

DECLARE
  TYPE t_associative IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;
  employees t_associative;
BEGIN
  employees(1) := 'Alice';
  employees(2) := 'Bob';
  employees(100) := 'Charlie'; -- Sparse indexing is allowed
  DBMS_OUTPUT.PUT_LINE(employees(100));
END;


DECLARE
  TYPE t_nested_table IS TABLE OF NUMBER;
  salaries t_nested_table;
BEGIN
  -- Populate the nested table
  salaries := t_nested_table(50000, 60000, 70000);

  -- Display the salaries
  FOR i IN 1..salaries.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Salary ' || i || ': ' || salaries(i));
  END LOOP;
END;


DECLARE
  TYPE t_nested_table IS TABLE OF VARCHAR2(50);
  employees t_nested_table;
BEGIN
  -- Populate the nested table
  employees := t_nested_table('Alice', 'Bob', 'Charlie');

  -- Access and display values
  
  for i in 1..employees.count loop
    DBMS_OUTPUT.PUT_LINE(i || employees(i) );
    end loop ;
    --end ;
  
  DBMS_OUTPUT.PUT_LINE('Employee 1: ' || employees(1));
  DBMS_OUTPUT.PUT_LINE('Employee 2: ' || employees(2));
  DBMS_OUTPUT.PUT_LINE('Employee 3: ' || employees(3));
  exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack||dbms_utility.format_error_backtrace);
END;

DECLARE
  TYPE t_nested_table IS TABLE OF VARCHAR2(50);
  employees t_nested_table;
BEGIN
  -- Populate the nested table
  employees := t_nested_table('******', '*****', '****', '***', '**', '*');

  -- Access and display values
  
  for i in 1..employees.count loop
    DBMS_OUTPUT.PUT_LINE( employees(i) );
    end loop ;
    end ;
  
  
  
  
DECLARE
  TYPE emp_record IS RECORD (
    name   VARCHAR2(50),
    salary NUMBER
  );
  TYPE t_nested_table IS TABLE OF emp_record;
  employees t_nested_table := t_nested_table();
BEGIN
  -- Populate the nested table
  employees.EXTEND(2);
  employees(1).name := 'Alice';
  employees(1).salary := 50000;
  employees(1).name := 'Bob';
  employees(2).salary := 60000;

  -- Display values
  FOR i IN 1..employees.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ' || i || ': ' || employees(i).name || ', Salary: ' || employees(i).salary);
  END LOOP;
END;



DECLARE
  TYPE t_nested_table IS TABLE OF VARCHAR2(50);
  employees t_nested_table := t_nested_table();
BEGIN
  -- Extend and populate
  employees.EXTEND(3); -- Adds 3 empty slots
  employees(1) := 'Alice';
  employees(3) := 'Charlie'; -- Skip index 2

  -- Display non-null values
  FOR i IN 1..employees.LAST LOOP
    IF employees(i) IS NOT NULL THEN
      DBMS_OUTPUT.PUT_LINE('Employee ' || i || ': ' || employees(i));
    END IF;
  END LOOP;
END;


SELECT * FROM v$version;


DECLARE
  TYPE t_nested_table IS TABLE OF VARCHAR2(50) index by pls_integer;
  employees t_nested_table;
BEGIN
  -- Populate the nested table
  employees(1) := ( '******');
  employees(2) := ( '*****');
  employees(3) := ( '****');
  employees(4) := ( '***');
  employees(5) := ( '**');

  -- Access and display values
  
    DBMS_OUTPUT.PUT_LINE('Employee at index 1: ' || employees(1));
    DBMS_OUTPUT.PUT_LINE('Employee at index 1: ' || employees(2));
    DBMS_OUTPUT.PUT_LINE('Employee at index 1: ' || employees(3));
    DBMS_OUTPUT.PUT_LINE('Employee at index 1: ' || employees(4));
    DBMS_OUTPUT.PUT_LINE('Employee at index 1: ' || employees(5));

    end ;


select * from customers ;


DECLARE
  CURSOR c_customers is
    SELECT name FROM customers;
  TYPE c_list IS TABLE of customers.name%type;
  name_list c_list := c_list();
  counter   integer := 0;
BEGIN
  FOR n IN c_customers LOOP
    counter := counter + 1;
    name_list.extend;
    name_list(counter) := n.name;
    dbms_output.put_line('Customer(' || counter || '):' ||
                         name_list(counter));
  END LOOP;
END;


--Method Name & Purpose
1. EXISTS(n)
Returns TRUE if the nth element exists in the collection.


DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30);
BEGIN
    IF nums.EXISTS(2) THEN
        DBMS_OUTPUT.PUT_LINE('Element 2 exists: ' || nums(2));
    ELSE
        DBMS_OUTPUT.PUT_LINE('Element 2 does not exist.');
    END IF;
END;
/


Heres the revised response with expected results for each example:

1. EXISTS(n)
Returns TRUE if the nth element exists in the collection.

plsql
Copy
Edit
DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30);
BEGIN
    IF nums.EXISTS(2) THEN
        DBMS_OUTPUT.PUT_LINE('Element 2 exists: ' || nums(2));
    ELSE
        DBMS_OUTPUT.PUT_LINE('Element 2 does not exist.');
    END IF;
END;
/

2. COUNT
Returns the number of elements in the collection.

DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(5, 10, 15);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Number of elements: ' || nums.COUNT);
END;


3. LIMIT
Checks the maximum size of a collection (only for VARRAY).

DECLARE
    TYPE num_varray IS VARRAY(5) OF NUMBER;
    nums num_varray := num_varray(1, 2, 3);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Maximum size of collection: ' || nums.LIMIT);
END;
/

4. FIRST
Returns the smallest index in the collection.

DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(50, 60, 70);
BEGIN
    DBMS_OUTPUT.PUT_LINE('First index: ' || nums.FIRST);
END;
/

5. LAST
Returns the largest index in the collection.

DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(50, 60, 70);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Last index: ' || nums.LAST);
END;
/


6. PRIOR(n)
Returns the index preceding n.

DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30, 343, 242, 232, 24, 23, 24);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Index before 8: ' || nums.PRIOR(8));
END;


7. NEXT(n)
Returns the index succeeding n.


DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Index after 2: ' || nums.NEXT(2));
END;
/



8. EXTEND
Adds one null element to the collection.


DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30);
BEGIN
    nums.EXTEND(9); -- Adds one null element
    DBMS_OUTPUT.PUT_LINE('Count after EXTEND: ' || nums.COUNT);
END;



10. EXTEND(n, i)
Adds n copies of the ith element to the collection.


DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30);
BEGIN
    nums.EXTEND(3, 2); -- Adds 3 copies of element at index 2 (value 20)
    DBMS_OUTPUT.PUT_LINE('Count after EXTEND(3, 2): ' || nums.COUNT);
    DBMS_OUTPUT.PUT_LINE('New elements: ' || nums(4) || ', ' || nums(5) || ', ' || nums(6));
END;



11. TRIM
Removes the last element from the collection.


DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30);
BEGIN
    nums.TRIM;
    DBMS_OUTPUT.PUT_LINE('Count after TRIM: ' || nums.COUNT);
END;


12. TRIM(n)
Removes n elements from the end of the collection.

DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30, 40, 50);
BEGIN
    nums.TRIM(2); -- Removes the last 2 elements
    DBMS_OUTPUT.PUT_LINE('Count after TRIM(2): ' || nums.COUNT);
END;
/

13. DELETE
Removes all elements from the collection.

DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30);
BEGIN
    nums.DELETE; -- Removes all elements
    DBMS_OUTPUT.PUT_LINE('Count after DELETE: ' || nums.COUNT);
END;


14. DELETE(n)
Removes the nth element from the collection.


DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30);
BEGIN
    nums.DELETE(2); -- Deletes element at index 2
    IF nums.EXISTS(2) THEN
        DBMS_OUTPUT.PUT_LINE('Element 2 exists: ' || nums(2));
    ELSE
        DBMS_OUTPUT.PUT_LINE('Element 2 does not exist.');
    END IF;
END;
/

15. DELETE(m, n)
Removes elements in the range m..n.


DECLARE
    TYPE num_table IS TABLE OF NUMBER;
    nums num_table := num_table(10, 20, 30, 40, 50);
BEGIN
    nums.DELETE(2, 4); -- Deletes elements from index 2 to 4
    DBMS_OUTPUT.PUT_LINE('Count after DELETE(2, 4): ' || nums.COUNT);
END;
/


-----------------------------------------------------------------------------------------------

-- how to use bulk collect 

DECLARE
  TYPE emp_table IS TABLE OF hr.employees%ROWTYPE;
  emp_data emp_table;
BEGIN
  SELECT *
    BULK COLLECT
    INTO emp_data
    FROM hr.employees
   WHERE department_id = 100;

  FOR i IN emp_data.FIRST .. emp_data.LAST LOOP
    DBMS_OUTPUT.PUT_LINE('Employee: ' || emp_data(i).first_name || ' ' || emp_data(i)
                         .last_name);
  END LOOP;
END;

select count(*) from hr.employees where department_id=100 ;

---------------------  09-06-2025 Monday  ------------------------------------------------------------------

------------------------------- Exceptions

-- exception is a way to handle errors or unexpected situations that occur during program execution  
-- like dividing by zero, selecting a missing row, or inserting duplicate data.
  
-- There are two type of exception 
   1.predifine 
   2.user define
  
--Common Predefined Exceptions in PL/SQL
| Exception Name            | Error Code | Description                                                                      |
| ------------------------- | ---------- | -------------------------------------------------------------------------------- |
| `NO_DATA_FOUND`           | ORA-01403  | Raised when a SELECT INTO returns no rows                                        |
| `TOO_MANY_ROWS`           | ORA-01422  | SELECT INTO returns **more than one row**                                        |
| `ZERO_DIVIDE`             | ORA-01476  | Division by zero                                                                 |
| `INVALID_CURSOR`          | ORA-01001  | Cursor operation is invalid (e.g., fetch from closed cursor)                     |
| `DUP_VAL_ON_INDEX`        | ORA-00001  | Inserting duplicate value violating a unique constraint                          |
| `VALUE_ERROR`             | ORA-06502  | Type conversion or numeric overflow/underflow (e.g., assigning string to number) |
| `INVALID_NUMBER`          | ORA-01722  | Conversion of character to number failed                                         |
| `LOGIN_DENIED`            | ORA-01017  | Invalid username/password during login                                           |
| `CURSOR_ALREADY_OPEN`     | ORA-06511  | Tried to open a cursor thats already open                                       |
| `ACCESS_INTO_NULL`        | ORA-06530  | Tried to access a null object attribute                                          |
| `CASE_NOT_FOUND`          | ORA-06592  | No `WHEN` clause matched in a CASE expression                                    |
| `COLLECTION_IS_NULL`      | ORA-06531  | Attempted to access an uninitialized nested table or VARRAY                      |
| `SUBSCRIPT_BEYOND_COUNT`  | ORA-06533  | Index out of bounds in collections (e.g., `collection(10)` when only 3 elements) |
| `SUBSCRIPT_OUTSIDE_LIMIT` | ORA-06532  | Index value is outside allowed range                                             |

--   1. DBMS_UTILITY.FORMAT_ERROR_STACK
     Returns the error message (same as SQLERRM)
     Does NOT show where the error occurred

--   2. DBMS_UTILITY.FORMAT_ERROR_BACKTRACE
     Shows exact line number in the PL/SQL block where the error occurred
     Very helpful in deeply nested code or procedure chains


  ==========================================1.predifin================================================

-- Bacis ctructure of excetion handling
BEGIN
  -- Normal code block
EXCEPTION
  WHEN exception_name THEN
    -- Error handling code
  WHEN OTHERS THEN
    -- Fallback for any unhandled exception
END;

--Predefined Exception Example: NO_DATA_FOUND
DECLARE
  v_name VARCHAR2(50);
BEGIN
  SELECT first_name INTO v_name FROM hr.employees WHERE employee_id = 99999;
  DBMS_OUTPUT.PUT_LINE('Name: ' || v_name);

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('No such employee found.');
END;

-- Predefined Exception: ZERO_DIVIDE
DECLARE
  x NUMBER := 100;
  y NUMBER := 0;
  z NUMBER;
BEGIN
  z := x / y;

EXCEPTION
  WHEN ZERO_DIVIDE THEN
    DBMS_OUTPUT.PUT_LINE('Cannot divide by zero.');
END;

-- User-Defined Exception
DECLARE
  e_salary_low EXCEPTION;
  v_salary NUMBER := 2000;
BEGIN
  IF v_salary < 3000 THEN
    RAISE e_salary_low;
  END IF;

EXCEPTION
  WHEN e_salary_low THEN
    DBMS_OUTPUT.PUT_LINE('Salary is below the minimum threshold!');
END;

-- WHEN OTHERS with SQLERRM and SQLCODE
BEGIN
  -- Force error
  DECLARE
    v NUMBER := 1 / 0;
  BEGIN
    NULL;
  END;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error code: ' || SQLCODE);
    DBMS_OUTPUT.PUT_LINE('Error message: ' || SQLERRM);
END;

-- Exception in Cursor Loop
DECLARE
  CURSOR c IS SELECT salary FROM hr.employees WHERE department_id = 999;
  v_sal hr.employees.salary%TYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_sal;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_sal);
  END LOOP;
  CLOSE c;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLCODE);
END;

-- Handling Multiple Exceptions
DECLARE
  x NUMBER := 10;
  y NUMBER := 0;
  z NUMBER;
BEGIN
  z := x / y;

EXCEPTION
  WHEN ZERO_DIVIDE THEN
    DBMS_OUTPUT.PUT_LINE('Caught divide by zero.');
  WHEN VALUE_ERROR THEN
    DBMS_OUTPUT.PUT_LINE('Caught value error.');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Some unknown error: ' || SQLERRM);
END;


------  Ecercise
--  Exercise 1: Handle SELECT returning no rows
DECLARE
  v_name employees.first_name%TYPE;
BEGIN
  SELECT first_name INTO v_name FROM employees WHERE employee_id = 99999;
  DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);

  -- Add proper exception handling here
exception
  when no_data_found then
    dbms_output.put_line('No such as employee found');
  when others then
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;

-- Exercise 2: Handle SELECT returning more than one row
DECLARE
  v_name employees.first_name%TYPE;
BEGIN
  SELECT first_name INTO v_name FROM hr.employees WHERE department_id = 60;
  DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);

  -- Add proper exception handling here
exception
  when too_many_rows then
    dbms_output.put_line('More that one result found');
  when others then
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;

select count(*) from hr. employees where department_id = 60 ;

--  Exercise 3: Handle divide by zero
DECLARE
  x NUMBER := 10;
  y NUMBER := 0;
  z NUMBER;
BEGIN
  z := x / y;
  DBMS_OUTPUT.PUT_LINE('Result: ' || z);

  -- Add proper exception handling here
exception
  when ZERO_DIVIDE then
    dbms_output.put_line('Diviser should not be zero');
  when others then
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;

-- Exercise 4: Handle inserting duplicate data
BEGIN
  INSERT INTO hr.departments (department_id, department_name)
  VALUES (10, 'HR');  -- Assume dept_id 10 already exists

  -- Add exception handling here
exception
  when DUP_VAL_ON_INDEX then
    dbms_output.put_line('Value you are inserting that is allready present.');
  when others then
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;

select * from hr.departments;

-- Exercise 5: Handle value conversion issue
DECLARE
  v_num NUMBER;
BEGIN
  v_num := TO_NUMBER('abc123');

  -- Add exception handling here
exception
  when VALUE_ERROR then
    dbms_output.put_line('Data type not matches to value that you are inserting.');
  when others then
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;

--==========================================1.Userdefine================================================
--A user-defined exception in PL/SQL is an exception that you declare manually in your block. 
--You can also raise it using the RAISE statement or RAISE_APPLICATION_ERROR.

--Range of RAISE_APPLICATION_ERROR code is (between -20000 and -20999).

-- Example 1: Simple User-Defined Exception
DECLARE
  e_low_salary EXCEPTION;  -- Declare
  v_salary NUMBER := 800;
BEGIN
  IF v_salary < 1000 THEN
    RAISE e_low_salary;    -- Raise
  END IF;
EXCEPTION
  WHEN e_low_salary THEN   -- Handle
    DBMS_OUTPUT.PUT_LINE('Salary too low!');
END;

--  Example 2: User-Defined Exception with RAISE_APPLICATION_ERROR
DECLARE
  v_salary NUMBER := 800;
BEGIN
  IF v_salary < 1000 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Minimum salary should be 1000.');
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLERRM); -- Will print custom error message
END;

/*                                       Real-World Examples of User-Defined Exceptions                                      */

-- Example 1: Bank withdrawal  insufficient balance
DECLARE
  e_insufficient_balance EXCEPTION;
  v_balance NUMBER := 2000;
  v_withdraw_amount NUMBER := 3000;
BEGIN
  IF v_withdraw_amount > v_balance THEN
    RAISE e_insufficient_balance;
  END IF;
EXCEPTION
  WHEN e_insufficient_balance THEN
    DBMS_OUTPUT.PUT_LINE('Withdrawal failed: Insufficient balance!');
END;

-- Example 2: E-commerce order  out of stock
DECLARE
  e_out_of_stock EXCEPTION;
  v_stock_qty NUMBER := 0;
BEGIN
  IF v_stock_qty = 0 THEN
    RAISE e_out_of_stock;
  END IF;
EXCEPTION
  WHEN e_out_of_stock THEN
    DBMS_OUTPUT.PUT_LINE('Order failed: Item out of stock!');
  when others then
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;

--  Example 3: HR system  duplicate email check
DECLARE
  e_duplicate_email EXCEPTION;
  v_email VARCHAR2(50) := 'ABULL';
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM hr.employees WHERE email = v_email;
  
  IF v_count > 0 THEN
    RAISE e_duplicate_email;
    else 
      dbms_output.put_line(v_email);
  END IF;

EXCEPTION
  WHEN e_duplicate_email THEN
    DBMS_OUTPUT.PUT_LINE('Error: This email already exists.');
END;

select email from hr.employees ;

--  Example 4: Inventory  Reorder alert
DECLARE
  e_reorder_needed EXCEPTION;
  v_item_stock NUMBER := 3;
BEGIN
  IF v_item_stock < 5 THEN
    RAISE e_reorder_needed;
  END IF;

EXCEPTION
  WHEN e_reorder_needed THEN
    DBMS_OUTPUT.PUT_LINE('Reorder required: Stock below minimum level.');
END;


-- Raise application error examples 
--  Example: Procedure using RAISE_APPLICATION_ERROR
CREATE OR REPLACE PROCEDURE add_employee (
  p_id         NUMBER,
  p_name       VARCHAR2,
  p_salary     NUMBER
)
IS
BEGIN
  -- Check for salary rule
  IF p_salary < 1000 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Salary must be at least 1000.');
  END IF;

  -- Otherwise, insert
  INSERT INTO employee(emp_id, emp_name, salary)
  VALUES (p_id, p_name, p_salary);

  DBMS_OUTPUT.PUT_LINE('Employee added successfully.');
EXCEPTION
  WHEN OTHERS THEN
    -- Print the custom or system error
    DBMS_OUTPUT.PUT_LINE(SQLERRM);
END;

BEGIN
  add_employee(101, 'Alice', 500); -- Will trigger custom error
END;

-- Another Example: Prevent deleting admin user
CREATE OR REPLACE PROCEDURE delete_user(p_user_id NUMBER)
IS
  v_role VARCHAR2(20);
BEGIN
  SELECT user_role INTO v_role FROM users WHERE user_id = p_user_id;

  IF v_role = 'ADMIN' THEN
    RAISE_APPLICATION_ERROR(-20002, 'Cannot delete ADMIN user.');
  END IF;

  DELETE FROM users WHERE user_id = p_user_id;

  DBMS_OUTPUT.PUT_LINE('User deleted successfully.');

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLERRM);
END;


--       Exercise
-- You're building a procedure to register students into a students table. The rules are:
-- Student's age must be at least 18.
-- Student's email must be unique (no duplicate emails allowed).
-- If any rule is violated, raise a custom error using RAISE_APPLICATION_ERROR.

CREATE TABLE student1 (
  student_id   NUMBER PRIMARY KEY,
  name         VARCHAR2(50),
  age          NUMBER,
  email        VARCHAR2(100) UNIQUE
);

-- Procedure: register_student
CREATE OR REPLACE PROCEDURE register_student (
  p_id    NUMBER,
  p_name  VARCHAR2,
  p_age   NUMBER,
  p_email VARCHAR2
)
IS
  v_count NUMBER;
BEGIN
  -- Rule 1: Age must be 18 or older
  IF p_age < 18 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Student must be at least 18 years old.');
  END IF;

  -- Rule 2: Email must be unique
  SELECT COUNT(*) INTO v_count
  FROM student1
  WHERE LOWER(email) = LOWER(p_email);

  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20002, 'Email already exists. Please use another.');
  END IF;

  -- Insert if all validations pass
  INSERT INTO student1 (student_id, name, age, email)
  VALUES (p_id, p_name, p_age, p_email);

  DBMS_OUTPUT.PUT_LINE('Student registered successfully.');
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
    
END;

--Valid Student
BEGIN
  register_student(1, 'John Doe', 20, 'john@mail.com');
END;
--Underage Student
BEGIN
  register_student(2, 'Mini Me', 16, 'mini@mail.com');
END;
--Duplicate Email
BEGIN
  register_student(3, 'Jane Doe', 22, 'john@mail.com');
END;

select * from student1 ;

 --         Difference Between RAISE and RAISE_APPLICATION_ERROR
| Feature                      | `RAISE`                                                                           | `RAISE_APPLICATION_ERROR`                                           |
| ---------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
|      **Purpose**               | Raises a predefined or user-defined exception.                                    | Raises a custom error with a user-defined error code and message.   |

|      **Usage**                 | Used with declared exceptions (`WHEN e_name THEN RAISE`) or standalone (`RAISE;`) | Directly raises an exception with your own error code and message.  |

|      **Error Code Range**      | Uses Oracles internal error codes or user-defined exceptions (no code required)  | Requires error code from `-20000` to `-20999`                        |

|      **Custom Error Message?** | Not directlyneeds separate handling logic                                        | Yesfully customizable message and error number                     |

|      **Common Use Case**       | Propagate existing errors or raise declared exception                             | Enforce business rules or data validations with meaningful messages |

--       What is PRAGMA EXCEPTION_INIT?
--PRAGMA EXCEPTION_INIT is a compiler directive used in PL/SQL to associate a specific Oracle error number 
--(like -1, -2291, -01403, etc.) with a user-defined exception.

-- syntax
PRAGMA EXCEPTION_INIT(exception_name, error_number);

Why use it?
To make error handling more readable and specific

To handle Oracle errors like duplicate keys, foreign key violation, etc. using custom exception names

-- Example 1: Handle DUP_VAL_ON_INDEX (ORA-00001)
DECLARE
  e_duplicate EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_duplicate, -1);  -- ORA-00001: Unique constraint violated

BEGIN
  -- Assume this ID already exists
  INSERT INTO employees(emp_id, name) VALUES (1, 'John');

EXCEPTION
  WHEN e_duplicate THEN
    DBMS_OUTPUT.PUT_LINE('Error: Duplicate employee ID.');
END;

-- Example 2: Handle Foreign Key Violation (ORA-02291)
DECLARE
  e_foreign_key_violation EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_foreign_key_violation, -2291);  -- ORA-02291

BEGIN
  -- Trying to insert a child record with no parent
  INSERT INTO orders(order_id, customer_id) VALUES (1, 9999);  -- 9999 doesn't exist

EXCEPTION
  WHEN e_foreign_key_violation THEN
    DBMS_OUTPUT.PUT_LINE('Error: Customer does not exist.');
END;

-- Key difference.
| Feature        | `PRAGMA EXCEPTION_INIT`                          | Manual Raise with `SQLCODE`                     |
| -------------- | ------------------------------------------------ | ----------------------------------------------- |
|      Binding     | Automatic mapping Oracle error to your exception | Manual checking and raising                     |
|      Readability | Clearer, cleaner, easier to maintain             | Messy and more complex                          |
|      Performance | Slightly better (compiler knows the mapping)     | Slight overhead due to nested blocks            |
|  Best for     | Most real-world PL/SQL apps                      | Special handling when complex conditions needed |

--hen to Use Which?
 Use PRAGMA EXCEPTION_INIT: When handling known Oracle errors like:
Unique constraint: ORA-00001
Foreign key: ORA-02291
No data found: ORA-01403 (if not already predefined)

     Use manual raise (via SQLCODE) only if:
You want custom logic before raising
Youre checking multiple possible errors dynamically

-- Common Oracle Error Codes:
| Oracle Error | PL/SQL Code | Description                                | Notes                                            |
| ------------ | ----------- | ------------------------------------------ | ------------------------------------------------ |
| ORA-00001    | `-1`        | Unique constraint violation                | Use with `PRAGMA EXCEPTION_INIT` for custom name |
| ORA-02291    | `-2291`     | Foreign key violation (parent key missing) |                                                  |
| ORA-01403    | **None**    | No data found                              | **Handled by `NO_DATA_FOUND`, not numeric code** |
| ORA-06502    | `-6502`     | Numeric or value error (e.g., overflow)    | Predefined: `VALUE_ERROR`                        |
| ORA-01476    | `-1476`     | Divide by zero                             | Predefined: `ZERO_DIVIDE`                        |


--------------------- 10-06-2025 Tuesday  ----------------------------------------------------------------------

---------------------- Ref Cursor

-- A REF CURSOR (or cursor variable) is a pointer to a result set. Unlike a static cursor (which is bound to a 
-- specific query at compile time), a REF CURSOR is dynamic  it can be opened for different queries at runtime.

| Type                  | Description|
| --------------------- | --------------------------------------------------------------------------------------
| **Strong REF CURSOR** | Bound to a specific return type (like `RETURN employees%ROWTYPE` or a specific RECORD).
                           The compiler checks that the result set matches this structure.
| **Weak REF CURSOR**   | Not bound to any return type. It can return any query shape at runtime.
                          This makes it flexible for dynamic SQL, but theres no compile-time type safety. |

--Syantax
-- Strong REF CURSOR
TYPE cursor_type_name IS REF CURSOR RETURN table_name%ROWTYPE;
-- Weak REF CURSOR
TYPE cursor_type_name IS REF CURSOR;

-- Example 1: Basic Strong REF CURSOR
DECLARE
  TYPE emp_cur_type IS REF CURSOR RETURN hr.employees%ROWTYPE;
  emp_cursor emp_cur_type;
  emp_record hr.employees%ROWTYPE;
BEGIN
  OPEN emp_cursor FOR SELECT * FROM hr.employees WHERE department_id = 90;

  LOOP
    FETCH emp_cursor INTO emp_record;
    EXIT WHEN emp_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(emp_record.first_name || ' - ' || emp_record.salary);
  END LOOP;

  CLOSE emp_cursor;
END;

--  Example 2: Weak REF CURSOR
DECLARE
  TYPE generic_cursor IS REF CURSOR;
  my_cursor generic_cursor;
  v_name employees.first_name%TYPE;
  v_salary employees.salary%TYPE;
BEGIN
  OPEN my_cursor FOR SELECT first_name, salary FROM employees WHERE department_id = 20;

  LOOP
    FETCH my_cursor INTO v_name, v_salary;
    EXIT WHEN my_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name || ' earns ' || v_salary);
  END LOOP;

  CLOSE my_cursor;
END;

--  Example 3: REF CURSOR as OUT Parameter (from a Procedure)
-- Package spec
CREATE OR REPLACE PACKAGE emp_pkg AS
  TYPE emp_cursor IS REF CURSOR;
  PROCEDURE get_employees_by_dept(p_dept_id NUMBER, p_cursor OUT emp_cursor);
END emp_pkg;
/

-- Package body
CREATE OR REPLACE PACKAGE BODY emp_pkg AS
  PROCEDURE get_employees_by_dept(p_dept_id NUMBER, p_cursor OUT emp_cursor) IS
  BEGIN
    OPEN p_cursor FOR SELECT employee_id, first_name FROM employees WHERE department_id = p_dept_id;
  END;
END;
/

-- Calling from anonymous block
DECLARE
  emp_cur emp_pkg.emp_cursor;
  v_id employees.employee_id%TYPE;
  v_name employees.first_name%TYPE;
BEGIN
  emp_pkg.get_employees_by_dept(30, emp_cur);

  LOOP
    FETCH emp_cur INTO v_id, v_name;
    EXIT WHEN emp_cur%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('ID: ' || v_id || ' Name: ' || v_name);
  END LOOP;

  CLOSE emp_cur;
END;

-- Example 4: Returning REF CURSOR from Function
CREATE OR REPLACE FUNCTION get_high_salary_emps(p_min_salary NUMBER)
RETURN SYS_REFCURSOR IS
  emp_ref SYS_REFCURSOR;
BEGIN
  OPEN emp_ref FOR SELECT employee_id, salary FROM employees WHERE salary > p_min_salary;
  RETURN emp_ref;
END;
/

-- Anonymous block to use it
DECLARE
  emp_cursor SYS_REFCURSOR;
  v_id NUMBER;
  v_sal NUMBER;
BEGIN
  emp_cursor := get_high_salary_emps(10000);
  
  LOOP
    FETCH emp_cursor INTO v_id, v_sal;
    EXIT WHEN emp_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('EmpID: ' || v_id || ', Salary: ' || v_sal);
  END LOOP;

  CLOSE emp_cursor;
END;

------- Strong ref cursor
-- Example 1: Basic Strong REF CURSOR
DECLARE
  TYPE emp_cur_type IS REF CURSOR RETURN hr.employees%ROWTYPE;
  emp_cursor emp_cur_type;
  emp_record hr.employees%ROWTYPE;
BEGIN
  OPEN emp_cursor FOR SELECT * FROM hr.employees WHERE department_id = 90;

  LOOP
    FETCH emp_cursor INTO emp_record;
    EXIT WHEN emp_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(emp_record.first_name || ' - ' || emp_record.salary);
  END LOOP;

  CLOSE emp_cursor;
END;

-- Example 2: Strong REF CURSOR with Custom Record Type
DECLARE
  TYPE emp_rec IS RECORD (
    emp_id   hr.employees.employee_id%TYPE,
    name     hr.employees.first_name%TYPE,
    dept_id  hr.employees.department_id%TYPE
  );

  TYPE emp_cur_type IS REF CURSOR RETURN emp_rec;
  emp_cur emp_cur_type;
  emp_data emp_rec;
BEGIN
  OPEN emp_cur FOR
    SELECT employee_id, first_name, department_id FROM hr.employees WHERE job_id = 'IT_PROG';

  LOOP
    FETCH emp_cur INTO emp_data;
    EXIT WHEN emp_cur%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(emp_data.name || ' from dept ' || emp_data.dept_id);
  END LOOP;

  CLOSE emp_cur;
END;

-- Example 3: Strong REF CURSOR in a Package (Modular & Reusable)
-- Package Specification
CREATE OR REPLACE PACKAGE emp_package AS
  TYPE emp_rec IS RECORD (
    emp_id   hr.employees.employee_id%TYPE,
    full_name hr.employees.first_name%TYPE
  );

  TYPE emp_cur_type IS REF CURSOR RETURN emp_rec;

  PROCEDURE fetch_emp_names(p_dept_id NUMBER, p_cur OUT emp_cur_type);
END emp_package;
/

-- Package Body
CREATE OR REPLACE PACKAGE BODY emp_package AS
  PROCEDURE fetch_emp_names(p_dept_id NUMBER, p_cur OUT emp_cur_type) IS
  BEGIN
    OPEN p_cur FOR
      SELECT employee_id, first_name
      FROM hr.employees
      WHERE department_id = p_dept_id;
  END;
END emp_package;
/

-- Anonymous block to call it
DECLARE
  cur emp_package.emp_cur_type;
  emp emp_package.emp_rec;
BEGIN
  emp_package.fetch_emp_names(60, cur);

  LOOP
    FETCH cur INTO emp;
    EXIT WHEN cur%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp.emp_id || ', Name: ' || emp.full_name);
  END LOOP;

  CLOSE cur;
END;

--  Example 4: Strong REF CURSOR with Dynamic Choice (Multiple Queries)
DECLARE
  TYPE job_rec IS RECORD (
    emp_id hr.employees.employee_id%TYPE,
    job    hr.employees.job_id%TYPE
  );

  TYPE job_cur_type IS REF CURSOR RETURN job_rec;
  job_cur job_cur_type;
  job_row job_rec;

  v_choice VARCHAR2(20) := 'MANAGER';
BEGIN
  IF v_choice = 'MANAGER' THEN
    OPEN job_cur FOR
      SELECT employee_id, job_id FROM hr.employees WHERE job_id = 'SA_MAN';
  ELSE
    OPEN job_cur FOR
      SELECT employee_id, job_id FROM hr.employees WHERE job_id = 'IT_PROG';
  END IF;

  LOOP
    FETCH job_cur INTO job_row;
    EXIT WHEN job_cur%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Emp ID: ' || job_row.emp_id || ', Job: ' || job_row.job);
  END LOOP;

  CLOSE job_cur;
END;

-- Example 5: Using Strong REF CURSOR with JOINs
DECLARE
  TYPE emp_dept_rec IS RECORD (
    emp_name   hr.employees.first_name%TYPE,
    dept_name  hr.departments.department_name%TYPE
  );

  TYPE emp_dept_cur IS REF CURSOR RETURN emp_dept_rec;
  emp_cur emp_dept_cur;
  rec emp_dept_rec;
BEGIN
  OPEN emp_cur FOR
    SELECT e.first_name, d.department_name
    FROM hr.employees e
    JOIN hr.departments d ON e.department_id = d.department_id
    WHERE e.salary > 10000;

  LOOP
    FETCH emp_cur INTO rec;
    EXIT WHEN emp_cur%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(rec.emp_name || ' - ' || rec.dept_name);
  END LOOP;

  CLOSE emp_cur;
END;

---- Practice = 
--1.
--Write a PL/SQL block using a strong REF CURSOR that does the following:
--Declares a REF CURSOR that returns the full row of the employees table using %ROWTYPE.
--Opens the cursor for a query that selects employees with department_id = 90.
--Loops through the result and displays:
--Employee: <first_name> <last_name> - Salary: <salary>
--Closes the cursor at the end.
declare
  type emp_ref_cur is ref cursor return hr.employees%rowtype;

  emp_rec  emp_ref_cur;
  v_result hr.employees%rowtype;
begin
  open emp_rec for
    select * from hr.employees where department_id = 90;
  loop
    fetch emp_rec
      into v_result;
    exit when emp_rec%notfound;
    dbms_output.put_line('Name : ' || v_result.first_name ||
                         v_result.last_name || ' Salary : ' ||
                         v_result.salary);
  end loop;
  close emp_rec;
end;

--2.
--Write a PL/SQL block using a strong REF CURSOR that:
--Declares a custom record type with employee_id, first_name, and salary.
--Declares a REF CURSOR that returns this custom record.
--Opens the cursor for employees where salary > 10000.
--Loops through the cursor and prints:
--Employee ID: <employee_id> - Name: <first_name> - Salary: <salary>
declare
  type emp_typ is record(
    emp_id         hr.employees.employee_id%type,
    emp_first_name hr.employees.first_name%type,
    emp_sal        hr.employees.salary%type);
  type emp_ref_cur is ref cursor return emp_typ;
  emp_cur emp_ref_cur;
  rec     emp_typ;
begin
  open emp_cur for
    select employee_id, first_name, salary
      from hr.employees
     where salary > 10000;
  loop
    fetch emp_cur
      into rec;
    exit when emp_cur%notfound;
    dbms_output.put_line('Employee id : ' || rec.emp_id || ' Name : ' ||
                         rec.emp_first_name || ' Salary : ' || rec.emp_sal);
  end loop;
  close emp_cur;
end;

--3.
--Create a PL/SQL block using a strong REF CURSOR that:
--Declares a record type for employee name and department name.
--Declares a REF CURSOR that returns this record.
--Uses a JOIN between hr.employees and hr.departments to get:
--first_name from employees
--department_name from departments
--Filters employees where salary is between 8000 and 12000
--Loops and prints:Name: <first_name> | Department: <department_name>
declare
  type emp_typ is record(
    emp_first_name hr.employees.first_name%type,
    emp_dpt_name   hr.departments.department_name%type);
  type emp_ref_cur is ref cursor return emp_typ;
  emp_cur emp_ref_cur;
  rec     emp_typ;
begin
  open emp_cur for
    select e.first_name, d.department_name
      from hr.employees e
      join hr.departments d
        on e.department_id = d.department_id
     where e.salary between 8000 and 12000;

  loop
    fetch emp_cur
      into rec;
    exit when emp_cur%notfound;
    dbms_output.put_line(' Employee Name : ' || rec.emp_first_name ||
                         ' Department name : ' || rec.emp_dpt_name);
  end loop;
  close emp_cur;
end;

--4
--Write a PL/SQL block that uses a strong REF CURSOR with the following steps:
--Declare a custom record type that includes:
--employee_id
--first_name
--job_id
--location_id (from the locations table, via join)
--Use a join between employees, departments, and locations.
--Filter for employees who work in 'London'.
--Print the output as:ID: <employee_id> | Name: <first_name> | Job: <job_id> | Location: <location_id>
declare
  type emp_typ is record(
    emp_id    hr.employees.employee_id%type,
    emp_fname hr.employees.first_name%type,
    emp_job_id      hr.employees.job_id%type,
    emp_location_id hr.locations.location_id%type);

  type emp_ref_cur is ref cursor return emp_typ;
  emp_cur emp_ref_cur;
  rec     emp_typ;
begin
  open emp_cur for
    select e.employee_id, e.first_name, e.job_id, l.location_id
      from hr.employees e
      join hr.departments d
        on e.department_id = d.department_id
      join hr.locations l
        on d.location_id = l.location_id
     where city = 'London';

  loop
    fetch emp_cur
      into rec;
    exit when emp_cur%notfound;
    dbms_output.put_line(' Employee id: ' || rec.emp_id || ' Name: ' ||
                         rec.emp_fname || ' Job: ' || rec.emp_job_id ||
                         ' Location id: ' || rec.emp_location_id);
  end loop;
  close emp_cur;
end;

--5.
--Write a PL/SQL block using strong REF CURSOR that:
--Declares a custom record type with:
--employee_id
--first_name
--hire_date
--Cursor should return employees hired in the last 22 years.
--Use the condition:hire_date >= ADD_MONTHS(SYSDATE, -265)
--Display output like:ID: <employee_id> | Name: <first_name> | Hire Date: <hire_date>
declare
  type emp_typ is record(
    emp_id    hr.employees.employee_id%type,
    emp_fname hr.employees.first_name%type,
    emp_hire_date     hr.employees.hire_date%type);

  type emp_ref_cur is ref cursor return emp_typ;
  emp_cur emp_ref_cur;
  rec     emp_typ;
begin
  open emp_cur for
    select employee_id, first_name, hire_date from hr.employees where hire_date >= ADD_MONTHS(SYSDATE, -265);
     

  loop
    fetch emp_cur
      into rec;
    exit when emp_cur%notfound;
    dbms_output.put_line(' Employee id: ' || rec.emp_id || ' Name: ' ||
                         rec.emp_fname || ' Hire date: ' || rec.emp_hire_date);
  end loop;
  close emp_cur;
  exception
    when others then
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);      
end;


select * from hr.employees;

--- Weak ref cursor
-- Example 2: Weak REF CURSOR
DECLARE
  TYPE generic_cursor IS REF CURSOR;
  my_cursor generic_cursor;
  v_name employees.first_name%TYPE;
  v_salary employees.salary%TYPE;
BEGIN
  OPEN my_cursor FOR SELECT first_name, salary FROM employees WHERE department_id = 20;

  LOOP
    FETCH my_cursor INTO v_name, v_salary;
    EXIT WHEN my_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name || ' earns ' || v_salary);
  END LOOP;

  CLOSE my_cursor;
END;

-- Example 2: Weak REF CURSOR with Dynamic Query
DECLARE
  TYPE generic_cur IS REF CURSOR;
  cur generic_cur;
  v_name hr.employees.first_name%TYPE;
  v_sal  hr.employees.salary%TYPE;
  dept_id NUMBER := 50;
BEGIN
  -- Dynamic logic
  IF dept_id = 90 THEN
    OPEN cur FOR SELECT first_name, salary FROM hr.employees WHERE department_id = 90;
  ELSE
    OPEN cur FOR SELECT first_name, salary FROM hr.employees WHERE department_id = 60;
  END IF;

  LOOP
    FETCH cur INTO v_name, v_sal;
    EXIT WHEN cur%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name || ' earns ' || v_sal);
  END LOOP;

  CLOSE cur;
END;

DECLARE
cur SYS_REFCURSOR;
  v_name hr.employees.first_name%TYPE;
  v_sal  hr.employees.salary%TYPE;
  dept_id NUMBER := 50;
BEGIN
  -- Dynamic logic
  IF dept_id = 90 THEN
    OPEN cur FOR SELECT first_name, salary FROM hr.employees WHERE department_id = 90;
  ELSE
    OPEN cur FOR SELECT first_name, salary FROM hr.employees WHERE department_id = 60;
  END IF;

  LOOP
    FETCH cur INTO v_name, v_sal;
    EXIT WHEN cur%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name || ' earns ' || v_sal);
  END LOOP;

  CLOSE cur;
END;
   
--  Example 3: Weak REF CURSOR from Procedure OUT Parameter
-- Procedure with weak REF CURSOR as OUT parameter
CREATE OR REPLACE PROCEDURE get_emps(p_dept_id IN NUMBER, p_cursor OUT SYS_REFCURSOR) AS
BEGIN
  OPEN p_cursor FOR
    SELECT employee_id, first_name FROM hr.employees WHERE department_id = p_dept_id;
END;
/

-- Calling it from anonymous block
DECLARE
  emp_cursor SYS_REFCURSOR;
  v_id       NUMBER;
  v_name     VARCHAR2(50);
BEGIN
  get_emps(90, emp_cursor);

  LOOP
    FETCH emp_cursor INTO v_id, v_name;
    EXIT WHEN emp_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('ID: ' || v_id || ' Name: ' || v_name);
  END LOOP;

  CLOSE emp_cursor;
END;

----- Practice
--- converting strong ref cursor code into week ref cursor code

--1.
--Write a PL/SQL block using a strong REF CURSOR that does the following:
--Declares a REF CURSOR that returns the full row of the employees table using %ROWTYPE.
--Opens the cursor for a query that selects employees with department_id = 90.
--Loops through the result and displays:
--Employee: <first_name> <last_name> - Salary: <salary>
--Closes the cursor at the end.
declare
  type emp_ref_cur is ref cursor;

  emp_rec  emp_ref_cur;
  v_result hr.employees%rowtype;
begin
  open emp_rec for
    select * from hr.employees where department_id = 90;
  loop
    fetch emp_rec
      into v_result;
    exit when emp_rec%notfound;
    dbms_output.put_line('Name : ' || v_result.first_name ||
                         v_result.last_name || ' Salary : ' ||
                         v_result.salary);
  end loop;
  close emp_rec;
end;

--2.
--Write a PL/SQL block using a strong REF CURSOR that:
--Declares a custom record type with employee_id, first_name, and salary.
--Declares a REF CURSOR that returns this custom record.
--Opens the cursor for employees where salary > 10000.
--Loops through the cursor and prints:
--Employee ID: <employee_id> - Name: <first_name> - Salary: <salary>
declare
   type emp_ref_cur is ref cursor ;
  emp_cur emp_ref_cur;

    emp_id         hr.employees.employee_id%type;
    emp_first_name hr.employees.first_name%type;
    emp_sal        hr.employees.salary%type;
begin
  open emp_cur for
    select employee_id, first_name, salary
      from hr.employees
     where salary > 10000;
  loop
    fetch emp_cur
      into emp_id,emp_first_name,emp_sal;
    exit when emp_cur%notfound;
    dbms_output.put_line('Employee id : ' || emp_id || ' Name : ' ||
                         emp_first_name || ' Salary : ' || emp_sal);
  end loop;
  close emp_cur;
end;

--3.
--Create a PL/SQL block using a strong REF CURSOR that:
--Declares a record type for employee name and department name.
--Declares a REF CURSOR that returns this record.
--Uses a JOIN between hr.employees and hr.departments to get:
--first_name from employees
--department_name from departments
--Filters employees where salary is between 8000 and 12000
--Loops and prints:Name: <first_name> | Department: <department_name>
declare
  emp_first_name hr.employees.first_name%type;
  emp_dpt_name   hr.departments.department_name%type;
  emp_ref_cur    sys_refcursor;
begin
  open emp_ref_cur for
    select e.first_name, d.department_name
      from hr.employees e
      join hr.departments d
        on e.department_id = d.department_id
     where e.salary between 8000 and 12000;

  loop
    fetch emp_ref_cur
      into emp_first_name, emp_dpt_name;
    exit when emp_ref_cur%notfound;
    dbms_output.put_line(' Employee Name : ' || emp_first_name ||
                         ' Department name : ' || emp_dpt_name);
  end loop;
  close emp_ref_cur;
end;

--4
--Write a PL/SQL block that uses a strong REF CURSOR with the following steps:
--Declare a custom record type that includes:
--employee_id
--first_name
--job_id
--location_id (from the locations table, via join)
--Use a join between employees, departments, and locations.
--Filter for employees who work in 'London'.
--Print the output as:ID: <employee_id> | Name: <first_name> | Job: <job_id> | Location: <location_id>
declare

  emp_id          hr.employees.employee_id%type;
  emp_fname       hr.employees.first_name%type;
  emp_job_id      hr.employees.job_id%type;
  emp_location_id hr.locations.location_id%type;

  emp_ref_cur sys_refcursor;
begin
  open emp_ref_cur for
    select e.employee_id, e.first_name, e.job_id, l.location_id
      from hr.employees e
      join hr.departments d
        on e.department_id = d.department_id
      join hr.locations l
        on d.location_id = l.location_id
     where city = 'London';

  loop
    fetch emp_ref_cur
      into emp_id, emp_fname, emp_job_id, emp_location_id;
    exit when emp_ref_cur%notfound;
    dbms_output.put_line(' Employee id: ' || emp_id || ' Name: ' ||
                         emp_fname || ' Job: ' || emp_job_id ||
                         ' Location id: ' || emp_location_id);
  end loop;
  close emp_ref_cur;
end;

--5.
--Write a PL/SQL block using strong REF CURSOR that:
--Declares a custom record type with:
--employee_id
--first_name
--hire_date
--Cursor should return employees hired in the last 22 years.
--Use the condition:hire_date >= ADD_MONTHS(SYSDATE, -265)
--Display output like:ID: <employee_id> | Name: <first_name> | Hire Date: <hire_date>
declare

  emp_id        hr.employees.employee_id%type;
  emp_fname     hr.employees.first_name%type;
  emp_hire_date hr.employees.hire_date%type;

  type emp_ref_cur is ref cursor;
  emp_cur emp_ref_cur;
begin
  open emp_cur for
    select employee_id, first_name, hire_date
      from hr.employees
     where hire_date >= ADD_MONTHS(SYSDATE, -265);

  loop
    fetch emp_cur
      into emp_id, emp_fname, emp_hire_date;
    exit when emp_cur%notfound;
    dbms_output.put_line(' Employee id: ' || emp_id || ' Name: ' ||
                         emp_fname || ' Hire date: ' || emp_hire_date);
  end loop;
  close emp_cur;
exception
  when others then
    dbms_output.put_line(DBMS_UTILITY.FORMAT_ERROR_STACK ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;


select * from hr.employees;


commit ;

--------------------- 11-06-2025 Wednesday  ------------------------------------------------------------------

-- A collection is a single variable that can store multiple values 
--  like an array in other programming languages.

--  There are 3 main types of collections:
| Collection Type                  | Ordered? | Index Type              | Can Be Sparse? | Stored in DB? |
| -------------------------------- | -------- | ----------------------- | -------------- | ------------- |
| **Associative Array**            | Yes      | Any (String or Integer) | Yes            |  No          |
| **Nested Table**                 | Yes      | Integer (sequential)    | Yes            |  Yes         |
| **VARRAY (Variable-Size Array)** | Yes      | Integer (sequential)    |  No           |  Yes         |


-- Why Use Collections?
-- To store multiple rows in memory for processing (looping, filtering, etc.).
-- To return multiple values from functions/procedures.
-- To perform bulk operations (e.g., BULK COLLECT, FORALL)  makes PL/SQL much faster.
-- To avoid context switching between SQL and PL/SQL in loops.

-- Syntax
TYPE type_name IS TABLE OF element_type INDEX BY [PLS_INTEGER | VARCHAR2];

variable_name type_name;

--  1. Associative Array (a.k.a. Index-by Table)
DECLARE
  TYPE emp_tab IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;
  employees emp_tab;
BEGIN
  employees(1) := 'Amit';
  employees(2) := 'Bhavna';
  employees(10) := 'Chirag';  -- Gaps allowed

  FOR i IN employees.FIRST .. employees.LAST LOOP
    IF employees.EXISTS(i) THEN
      DBMS_OUTPUT.PUT_LINE(i || ' -> ' || employees(i));
    END IF;
  END LOOP;
END;

-- You dont know the number of elements in advance.
-- Need fast lookup (like a hash table or dictionary).

--syntax
TYPE type_name IS TABLE OF element_type;

variable_name type_name := type_name();
-- Example Nested Table
DECLARE
  TYPE num_table IS TABLE OF NUMBER;
  numbers num_table := num_table(10, 20, 30, 50, 70, 90, 100, 120);  -- Constructor
BEGIN
  cc


--Syantax
TYPE type_name IS VARRAY(size_limit) OF element_type [NOT NULL];
-- Example of varray
DECLARE
  TYPE grade_array IS VARRAY(5) OF NUMBER;
  grades grade_array := grade_array(85, 90, 95);  -- Fixed size
BEGIN
  
  FOR i IN 1 .. grades.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Grade ' || i || ': ' || grades(i));
  END LOOP;
END;

--  Example: Bulk Collect Using Collection
DECLARE
  TYPE sal_tab IS TABLE OF hr.employees.salary%TYPE;
  salaries sal_tab;
BEGIN
  SELECT salary BULK COLLECT INTO salaries
  FROM hr.employees
  WHERE department_id = 90;

  FOR i IN 1 .. salaries.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Salary: ' || salaries(i));
  END LOOP;
END;


begin
  for i in (select salary from hr.employees where department_id = 90) loop
    dbms_output.put_line(i.salary);
  end loop;
end;

-- Example: FORALL with Collection
DECLARE
  TYPE id_tab IS TABLE OF hr.employees.employee_id%TYPE;
  emp_ids id_tab := id_tab(101, 102, 103);
BEGIN
  FORALL i IN 1 .. emp_ids.COUNT
    UPDATE hr.employees
    SET salary = salary * 1.10
    WHERE employee_id = emp_ids(i);
END;
-- FORALL is used to perform bulk DML operations  faster than looping with UPDATE.

-- Collection Methods Summary
| Method      | Description                   | Associative Array | Nested Table | VARRAY |
| ----------- | ----------------------------- | ----------------- | ------------ | ------ |
| `COUNT`     | Number of elements            |                  |             |       |
| `EXISTS(i)` | Does index `i` exist?         |                  |             |       |
| `FIRST`     | First index in the collection |                  |             |       |
| `LAST`      | Last index in the collection  |                  |             |       |
| `PRIOR(i)`  | Index before `i`              |                  |             |       |
| `NEXT(i)`   | Index after `i`               |                  |             |       |
| `DELETE`    | Remove elements               |                  |             |       |
| `TRIM`      | Remove elements from the end  |                  |             |       |
| `EXTEND`    | Add elements to the end       |                  |             |       |

--  Methods specific to Nested Table and VARRAY only:
| Method                  | Reason Associative Array doesnt support it                         |
| ----------------------- | ------------------------------------------------------------------- |
| `EXTEND`                | Associative Arrays are indexed by key, not size                     |
| `TRIM`                  | Associative Arrays do not maintain size ordering                    |
| `DELETE(i)` or `DELETE` | Works for Associative Arrays and Nested Tables, **not** for VARRAYs |



--- Associative arrays example 
-- Example 1: Integer-indexed associative array
DECLARE
  TYPE emp_salary_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  emp_salaries emp_salary_tab;
BEGIN
  emp_salaries(101) := 50000;
  emp_salaries(102) := 60000;
  emp_salaries(105) := 75000;

  DBMS_OUTPUT.PUT_LINE('Salary of Emp 102: ' || emp_salaries(102));
END;

DECLARE
  TYPE emp_salary_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  emp_salaries emp_salary_tab;
  idx PLS_INTEGER;
BEGIN
  emp_salaries(101) := 50000;
  emp_salaries(102) := 60000;
  emp_salaries(105) := 75000;

  idx := emp_salaries.FIRST;
  WHILE idx IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE('Salary of Emp ' || idx || ': ' || emp_salaries(idx));
    idx := emp_salaries.NEXT(idx);
  END LOOP;
END;


-- Example 2: Loop through associative array with integer keys
DECLARE
  TYPE emp_tab IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;
  emp_names emp_tab;
  idx PLS_INTEGER;
BEGIN
  emp_names(1) := 'Shubham';
  emp_names(3) := 'Amit';
  emp_names(7) := 'Ravi';

  idx := emp_names.FIRST;
  WHILE idx IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE('Key: ' || idx || ' => Name: ' || emp_names(idx));
    idx := emp_names.NEXT(idx);
  END LOOP;
END;

--  Example 3: String-indexed associative array
DECLARE
  TYPE country_code_tab IS TABLE OF VARCHAR2(20) INDEX BY VARCHAR2(5);
  countries country_code_tab;
BEGIN
  countries('IN') := 'India';
  countries('US') := 'United States';
  countries('UK') := 'United Kingdom';

  DBMS_OUTPUT.PUT_LINE('Code US stands for: ' || countries('US'));
END;

-- Example 4: Use in cursor loop (dynamic in-memory table)
DECLARE
  TYPE emp_name_tab IS TABLE OF hr.employees.first_name%TYPE INDEX BY PLS_INTEGER;
  emp_names emp_name_tab;
  i PLS_INTEGER := 0;
BEGIN
  FOR rec IN (SELECT first_name FROM hr.employees WHERE ROWNUM <= 5) LOOP
    i := i + 1;
    emp_names(i) := rec.first_name;
  END LOOP;

  -- Print all names
  FOR j IN 1 .. i LOOP
    DBMS_OUTPUT.PUT_LINE('Employee ' || j || ' : ' || emp_names(j));
  END LOOP;
END;

-- Example 5: Using EXISTS with associative array
DECLARE
  TYPE id_table IS TABLE OF VARCHAR2(20) INDEX BY PLS_INTEGER;
  ids id_table;
BEGIN
  ids(1) := 'ABC123';
  ids(2) := 'XYZ456';

  IF ids.EXISTS(2) THEN
    DBMS_OUTPUT.PUT_LINE('Key 2 exists: ' || ids(2));
  ELSE
    DBMS_OUTPUT.PUT_LINE('Key 2 does not exist.');
  END IF;
END;

-- Practice
--1.Example 1: Integer-Key Associative Array
--  Practice Task: Print all the emp_ids using FIRST and NEXT.

DECLARE
  TYPE id_list IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  emp_ids id_list;
    idx PLS_INTEGER;

BEGIN
  emp_ids(1) := 101;
  emp_ids(2) := 105;
  emp_ids(4) := 110;
idx := emp_ids.FIRST;
  WHILE idx IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE('Salary of Emp ' || idx || ': ' || emp_ids(idx));
    idx := emp_ids.NEXT(idx);
  END LOOP;
END;
 
-- Example 2: String-Key Associative Array
-- Practice Task: Access and print the value for 'GJ' and use EXISTS to check if 'KA' exists.
DECLARE
  TYPE state_code_tab IS TABLE OF VARCHAR2(50) INDEX BY VARCHAR2(5);
  state_names state_code_tab;
BEGIN
  state_names('MH') := 'Maharashtra';
  state_names('GJ') := 'Gujarat';
  state_names('KA') := 'Karnataka';

  if state_names.exists('GJ') then
    dbms_output.put_line(state_names('GJ'));
  else
    dbms_output.put_line(state_names('KA'));
  
  end if;
  -- Print full form of state code 'GJ'
END;

DECLARE
  TYPE state_code_tab IS TABLE OF VARCHAR2(50) INDEX BY VARCHAR2(5);
  state_names state_code_tab;
BEGIN
  state_names('MH') := 'Maharashtra';
  state_names('GJ') := 'Gujarat';
  state_names('KA') := 'Karnataka';

  -- 1. Print full form of 'GJ'
  DBMS_OUTPUT.PUT_LINE('GJ = ' || state_names('GJ'));

  -- 2. Check if 'KA' exists
  IF state_names.EXISTS('KA') THEN
    DBMS_OUTPUT.PUT_LINE('KA = ' || state_names('KA'));
  ELSE
    DBMS_OUTPUT.PUT_LINE('KA not found');
  END IF;
END;
 
-- Example 3: Associative Array from Cursor
--  Practice Task: Use a loop to print all employee names collected into the array.
DECLARE
  TYPE name_tab IS TABLE OF hr.employees.first_name%TYPE INDEX BY PLS_INTEGER;
  emp_names name_tab;
  i PLS_INTEGER := 0;
BEGIN
  FOR rec IN (SELECT first_name FROM hr.employees WHERE department_id = 60) LOOP
    i := i + 1;
    emp_names(i) := rec.first_name;
    dbms_output.put_line(emp_names(i));

  END LOOP;

  -- Print all names from the array
END;

DECLARE
  TYPE name_tab IS TABLE OF hr.employees.first_name%TYPE INDEX BY PLS_INTEGER;
  emp_names name_tab;
  i PLS_INTEGER := 0;
  j PLS_INTEGER;
BEGIN
  -- Step 1: Collect names into the associative array
  FOR rec IN (SELECT first_name FROM hr.employees WHERE department_id = 60) LOOP
    i := i + 1;
    emp_names(i) := rec.first_name;
  END LOOP;

  -- Step 2: Print names from the array
  j := emp_names.FIRST;
  WHILE j IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || emp_names(j));
    j := emp_names.NEXT(j);
  END LOOP;
END;
/

-- Example 4: Sparse Array with EXISTS and DELETE
--  Practice Task: Delete key 3, then use EXISTS to verify if it was removed.
DECLARE
  TYPE prod_price_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  prices prod_price_tab;
BEGIN
  prices(1) := 99.99;
  prices(3) := 149.50;
  prices(7) := 199.00;
  
prices.DELETE(3);

  -- Check if key 3 still exists
  IF prices.EXISTS(3) THEN
    DBMS_OUTPUT.PUT_LINE('Key 3 exists.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Key 3 was successfully deleted.');
  END IF;
  -- Delete key 3 and check if it exists before/after
END;

--   Example 5: Using PRIOR and NEXT
--  Practice Task: Use FIRST, NEXT, PRIOR, and LAST to print the department names.
DECLARE
  TYPE dept_list IS TABLE OF VARCHAR2(30) INDEX BY PLS_INTEGER;
  depts dept_list;
  idx PLS_INTEGER;
BEGIN
  -- Insert values
  depts(10) := 'HR';
  depts(20) := 'IT';
  depts(30) := 'Finance';

  -- Print first and last key
  DBMS_OUTPUT.PUT_LINE('First key: ' || depts.FIRST);
  DBMS_OUTPUT.PUT_LINE('Last key: ' || depts.LAST);

  -- Start with the first index
  idx := depts.FIRST;
  WHILE idx IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE('Dept at key ' || idx || ': ' || depts(idx));

    -- Show PRIOR and NEXT for practice
    IF depts.PRIOR(idx) IS NOT NULL THEN
      DBMS_OUTPUT.PUT_LINE('  Prior key: ' || depts.PRIOR(idx));
    END IF;

    IF depts.NEXT(idx) IS NOT NULL THEN
      DBMS_OUTPUT.PUT_LINE('  Next key: ' || depts.NEXT(idx));
    END IF;

    -- Move to next key
    idx := depts.NEXT(idx);
  END LOOP;
END;
/

                       
dbms_output.put_line
----------------------------------------
--     Nested table
-- A nested table is a collection type in PL/SQL that behaves like a single-column table. It can be used 
-- in PL/SQL blocks, procedures, or even stored in database columns.

-- Nested Examples
-- Example 1: Basic Nested Table in PL/SQL Block
DECLARE
  -- Define a nested table type
  TYPE name_list IS TABLE OF VARCHAR2(50);

  -- Declare a nested table variable
  v_names name_list := name_list('Shubham', 'Amit', 'Neha');

BEGIN
  -- Extend and add a new element
  v_names.EXTEND;
  v_names(4) := 'Priya';

  -- Print all names
  FOR i IN 1 .. v_names.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Name ' || i || ': ' || v_names(i));
  END LOOP;
END;

-- Example 2: Nested Table of Records
DECLARE
  -- Define a record type
  TYPE emp_record IS RECORD (
    emp_id   NUMBER,
    emp_name VARCHAR2(50)
  );

  -- Define a nested table of that record
  TYPE emp_table IS TABLE OF emp_record;

  -- Declare the nested table variable
  v_emps emp_table := emp_table();

BEGIN
  -- Add 2 employees
  v_emps.EXTEND(2);
  v_emps(1).emp_id := 101;
  v_emps(1).emp_name := 'Alice';
  v_emps(2).emp_id := 102;
  v_emps(2).emp_name := 'Bob';

  -- Print all employees
  FOR i IN 1 .. v_emps.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Emp ID: ' || v_emps(i).emp_id || ', Name: ' || v_emps(i).emp_name);
  END LOOP;
END;

--  Example 3: Nested Table Type in SQL + PL/SQL
-- Step 1: Create SQL-level nested table type
CREATE OR REPLACE TYPE num_list AS TABLE OF NUMBER;
/

-- Step 2: Use it in PL/SQL
DECLARE
  v_numbers num_list := num_list(10, 20, 30, 40);
BEGIN
  -- Add a new number
  v_numbers.EXTEND;
  v_numbers(5) := 50;

  FOR i IN 1 .. v_numbers.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Value: ' || v_numbers(i));
  END LOOP;
END;

--Example: Procedure with Nested Table of Employee Records
-- Create SQL-level object type (record)
CREATE OR REPLACE TYPE emp_record_type AS OBJECT (
  emp_id     NUMBER,
  emp_name   VARCHAR2(50),
  emp_salary NUMBER
);
/

-- Create SQL-level nested table of that object
CREATE OR REPLACE TYPE emp_table_type AS TABLE OF emp_record_type;
/

CREATE OR REPLACE PROCEDURE print_employees(p_emps IN emp_table_type) IS
BEGIN
  FOR i IN 1 .. p_emps.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Emp ID: ' || p_emps(i).emp_id || 
                         ', Name: ' || p_emps(i).emp_name || 
                         ', Salary: ' || p_emps(i).emp_salary);
  END LOOP;
END;
/
DECLARE
  -- Declare and initialize the nested table
  v_emps emp_table_type := emp_table_type(
    emp_record_type(101, 'Alice', 3000),
    emp_record_type(102, 'Bob', 4000),
    emp_record_type(103, 'Charlie', 5000)
  );
BEGIN
  -- Call the procedure with nested table
  print_employees(v_emps);
END;
  
| Method         | Description                     |
| -------------- | ------------------------------- |
| `.EXTEND`      | Add one or more elements        |
| `.DELETE`      | Delete all or specific elements |
| `.COUNT`       | Get number of elements in table |
| `.EXISTS(i)`   | Check if element `i` exists     |
| `.TRIM`        | Remove last element(s)          |
| `.FIRST/.LAST` | Get first/last index value      |

-- Practice
/*1. Store and Print Student Names
Create a nested table to store 5 student names.
Add one more name dynamically.
Print all names.
Skills: Define nested table of VARCHAR2, use EXTEND, COUNT.*/

DECLARE
  TYPE name_list IS TABLE OF VARCHAR2(50);
  v_names name_list := name_list('Shubham', 'Amit', 'Neha', 'ram', 'Sham');
BEGIN
  v_names.EXTEND;
  v_names(6) := 'Priya';
  FOR i IN 1 .. v_names.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Name ' || i || ': ' || v_names(i));
  END LOOP;
END;

/*2. Calculate Squares
Create a nested table of numbers (1 to 5).
Loop through it and print the square of each number.
Skills: TABLE OF NUMBER, loop, calculations.*/

DECLARE
  TYPE name_list IS TABLE OF number;
  v_names name_list := name_list(1,2,3,4,5);
BEGIN

  FOR i IN 1 .. v_names.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Square of ' || i || ': ' || v_names(i)*v_names(i));
  END LOOP;
END;

/*3. Remove Specific Element
Create a nested table of 10 numbers.
Delete the 5th element.
Print only the elements that still exist.
Skills: DELETE, EXISTS(i).*/

DECLARE
  TYPE name_list IS TABLE OF number;
  v_names name_list := name_list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
  idx     number;
BEGIN
  v_names.delete(5);
  for i in 1 .. v_names.last loop
    if v_names.exists(i) then
      dbms_output.put_line(v_names(i));
    end if;
  end loop;

END;

/*4. Nested Table of Employee Records
Define a record with emp_id, emp_name, salary.
Create a nested table of that record.
Store 3 employees and print details.
Add one more employee using EXTEND.
Skills: RECORD, TABLE OF RECORD, loops.*/

DECLARE
  -- Step 1: Define a record type
  TYPE emp_record IS RECORD (
    emp_id     NUMBER,
    emp_name   VARCHAR2(50),
    emp_salary NUMBER
  );
  TYPE emp_table IS TABLE OF emp_record;
  v_emps emp_table := emp_table();
  v_rec emp_record;
BEGIN
  v_rec.emp_id := 101;
  v_rec.emp_name := 'Sam';
  v_rec.emp_salary := 2000;
  v_emps.EXTEND;
  v_emps(1) := v_rec;

  v_rec.emp_id := 102;
  v_rec.emp_name := 'Jimmy';
  v_rec.emp_salary := 3000;
  v_emps.EXTEND;
  v_emps(2) := v_rec;

  v_rec.emp_id := 103;
  v_rec.emp_name := 'Jon';
  v_rec.emp_salary := 4000;
  v_emps.EXTEND;
  v_emps(3) := v_rec;

  v_rec.emp_id := 104;
  v_rec.emp_name := 'Alice';
  v_rec.emp_salary := 5000;
  v_emps.EXTEND;
  v_emps(4) := v_rec;

  FOR i IN 1 .. v_emps.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Emp ID: ' || v_emps(i).emp_id || 
                         ', Name: ' || v_emps(i).emp_name || 
                         ', Salary: ' || v_emps(i).emp_salary);
  END LOOP;
END;


/*Procedure with Nested Table Input
Create a SQL nested table type: CREATE TYPE num_list AS TABLE OF NUMBER;
Write a procedure print_even_numbers(p IN num_list) to:
Accept a nested table
Print only even numbers
Skills: SQL collection types, procedures with nested table parameters.*/



CREATE OR REPLACE TYPE emp_record_type AS OBJECT (
  emp_id     NUMBER,
  emp_name   VARCHAR2(50),
  emp_salary NUMBER
);
/

-- Create SQL-level nested table of that object
CREATE OR REPLACE TYPE num_list AS TABLE OF number;
/

CREATE OR REPLACE PROCEDURE print_even_numbers(p IN num_list) IS
BEGIN
 FOR i IN 1 .. p.COUNT LOOP
    IF MOD(p(i), 2) = 0 THEN
      DBMS_OUTPUT.PUT_LINE('Even number: ' || p(i));
    END IF;
  END LOOP;
END;
/
DECLARE
  v_numbers num_list := num_list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
BEGIN
  print_even_numbers(v_numbers);
END;

--------------------- 13-06-2025 Friday
-- Syntax of coumpound trigger 
CREATE OR REPLACE TRIGGER trigger_name
FOR [INSERT | UPDATE | DELETE] ON table_name
COMPOUND TRIGGER

  -- Declarations (executed once per triggering statement)
  -- (Optional)
  -- DECLARE SECTION

  BEFORE STATEMENT IS
  BEGIN
    -- Code before the statement executes (once)
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
    -- Code before each row is processed
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
    -- Code after each row is processed
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
    -- Code Tafter the statement finishes (once)
  END AFTER SATEMENT;

END;
/
-- example -1 
CREATE OR REPLACE TRIGGER trg_employee_audit
FOR INSERT OR UPDATE OR DELETE ON employee
COMPOUND TRIGGER

  -- Declare a local procedure to insert audit records
  PROCEDURE log_action(p_emp_id NUMBER, p_action_type VARCHAR2) IS
  BEGIN
    INSERT INTO employees_audit(emp_id, action_type, action_date)
    VALUES (p_emp_id, p_action_type, SYSDATE);
  END;

  -- Row-level BEFORE or AFTER section
  AFTER EACH ROW IS
  BEGIN
    IF INSERTING THEN
      log_action(:NEW.emp_id, 'INSERT');
    ELSIF UPDATING THEN
      log_action(:NEW.emp_id, 'UPDATE');
    ELSIF DELETING THEN
      log_action(:OLD.emp_id, 'DELETE');
    END IF;
  END AFTER EACH ROW;

END;
/

-- Perform some DML operations
UPDATE employee SET salary = salary + 1000 WHERE emp_id = 101;
DELETE FROM employee WHERE emp_id = 105;
INSERT INTO employee VALUES (105, 'Frank', 61000);

-- Check audit table
SELECT * FROM employees_audit;
select * from employee ;

-- Example 2
CREATE OR REPLACE TRIGGER trg_count_inserts
FOR INSERT ON employee
COMPOUND TRIGGER

  -- Declaration section
  g_insert_count NUMBER := 0;

  BEFORE STATEMENT IS
  BEGIN
    g_insert_count := 0;  -- reset before each INSERT statement
  END BEFORE STATEMENT;

  AFTER EACH ROW IS
  BEGIN
    g_insert_count := g_insert_count + 1;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Total rows inserted: ' || g_insert_count);
  END AFTER STATEMENT;

END;
/

INSERT INTO employee (emp_id, name, salary)
VALUES (107, 'George', 57000);

INSERT ALL
  INTO employee VALUES (108, 'Henry', 50000)
  INTO employee VALUES (109, 'Ivy', 51000)
SELECT * FROM dual;

---               Insted of trigger 
Used only on Views (because you cannot normally insert/update/delete directly on complex views).

-- Syntax
CREATE OR REPLACE TRIGGER trigger_name
INSTEAD OF [INSERT | UPDATE | DELETE] ON view_name
FOR EACH ROW
BEGIN
   -- Your logic here, typically DML on underlying tables
END;
/
--Scenario:
/*Two base tables: departments and employees.
One view that joins them.
We want to allow inserting into the view, which normally fails.
Use INSTEAD OF trigger to handle it.*/

CREATE TABLE departments (
  dept_id   NUMBER PRIMARY KEY,
  dept_name VARCHAR2(50)
);

CREATE TABLE employees (
  emp_id    NUMBER PRIMARY KEY,
  name      VARCHAR2(50),
  dept_id   NUMBER REFERENCES departments(dept_id)
);
select * from employees;
select * from departments;
--Insert Sample Data:
INSERT INTO departments VALUES (1, 'HR');
INSERT INTO departments VALUES (2, 'IT');

INSERT INTO employees VALUES (101, 'Alice', 1);
INSERT INTO employees VALUES (102, 'Bob', 2);

--Create a Join View:
CREATE OR REPLACE VIEW emp_dept_view AS
SELECT e.emp_id, e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

INSERT INTO emp_dept_view VALUES (103, 'Charlie', 'IT');
--Youll get an error: "cannot perform DML on this view".



--Create INSTEAD OF Trigger:
CREATE OR REPLACE TRIGGER trg_instead_of_insert
INSTEAD OF INSERT ON emp_dept_view
FOR EACH ROW
BEGIN
  -- Find the dept_id from dept_name
  DECLARE
    v_dept_id departments.dept_id%TYPE;
  BEGIN
    SELECT dept_id INTO v_dept_id FROM departments
    WHERE dept_name = :NEW.dept_name;

    -- Insert into employees using the found dept_id
    INSERT INTO employees (emp_id, name, dept_id)
    VALUES (:NEW.emp_id, :NEW.name, v_dept_id);
  END;
END;
/

select * from emp_dept_view;

INSERT INTO emp_dept_view VALUES (103, 'Charlie', 'IT');
--This time it will work!


SELECT * FROM employees;
SELECT * FROM emp_dept_view;

--Summary of INSTEAD OF Triggers:
| Feature             | Description                                         |
| ------------------- | --------------------------------------------------- |
| Works only on views | Not allowed on base tables                          |
| Allows DML on views | Enables INSERT/UPDATE/DELETE on complex views       |
| One per DML type    | Create separate triggers for INSERT, UPDATE, DELETE |




EXPLAIN PLAN FOR
SELECT o.order_id, c.customer_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

select * from students

-- Drop if already exists (optional)
DROP TABLE exam_attempts;
DROP TABLE students;

-- Create students table
CREATE TABLE students (
    student_id NUMBER PRIMARY KEY,
    name VARCHAR2(50),
    enrollment_date DATE
);

-- Create exam_attempts table
CREATE TABLE exam_attempts (
    attempt_id NUMBER PRIMARY KEY,
    student_id NUMBER,
    exam_date DATE,
    score NUMBER,
    FOREIGN KEY (student_id) REFERENCES students(student_id)
);
-- Insert data into students table
INSERT INTO students VALUES (1, 'Alice', TO_DATE('2023-01-01', 'YYYY-MM-DD'));
INSERT INTO students VALUES (2, 'Bob', TO_DATE('2023-01-05', 'YYYY-MM-DD'));
INSERT INTO students VALUES (3, 'Charlie', TO_DATE('2023-02-01', 'YYYY-MM-DD'));
INSERT INTO students VALUES (4, 'David', TO_DATE('2023-02-15', 'YYYY-MM-DD'));
INSERT INTO students VALUES (5, 'Eva', TO_DATE('2023-03-01', 'YYYY-MM-DD'));

-- Insert data into exam_attempts table
INSERT INTO exam_attempts VALUES (1, 1, TO_DATE('2023-01-10', 'YYYY-MM-DD'), 40);
INSERT INTO exam_attempts VALUES (2, 1, TO_DATE('2023-01-25', 'YYYY-MM-DD'), 30);
INSERT INTO exam_attempts VALUES (3, 2, TO_DATE('2023-01-10', 'YYYY-MM-DD'), 60);
INSERT INTO exam_attempts VALUES (4, 3, TO_DATE('2023-02-20', 'YYYY-MM-DD'), 45);
INSERT INTO exam_attempts VALUES (5, 3, TO_DATE('2023-02-25', 'YYYY-MM-DD'), 20);
INSERT INTO exam_attempts VALUES (6, 4, TO_DATE('2023-02-16', 'YYYY-MM-DD'), 35);
INSERT INTO exam_attempts VALUES (7, 5, TO_DATE('2023-03-15', 'YYYY-MM-DD'), 50);

COMMIT;


| student\_id | name    | total\_score | passed\_flag | first\_attempt\_within\_10\_days |
| ----------- | ------- | ------------ | ------------ | -------------------------------- |
| 1           | Alice   | 70           | 0            | 1                                |
| 2           | Bob     | 60           | 1            | 1                                |
| 3           | Charlie | 65           | 0            | 0                                |
| 4           | David   | 35           | 0            | 1                                |
| 5           | Eva     | 50           | 1            | 1                                |

select * from students;
select * from exam_attempts;
-- way 1
select s.student_id,
       s.name,
       sum(score) as total_score,
       case
         when max(e.score) >= 50 then
          1
         else
          0
       end as passed_flage,
       
       case
         when min(exam_date) - enrollment_date <= 10 then
          1
         else
          0
       end as first_attempt_within_10_days

  from students s
  join exam_attempts e
    on s.student_id = e.student_id
 group by s.student_id, s.name,s.enrollment_date;

--corrected 
WITH first_attempt AS (
    SELECT student_id, exam_date
    FROM (
        SELECT 
            student_id,
            exam_date,
            ROW_NUMBER() OVER (PARTITION BY student_id ORDER BY exam_date) AS rn
        FROM exam_attempts
    )
    WHERE rn = 1
)
SELECT
    s.student_id,
    s.name,
    SUM(e.score) AS total_score,
    CASE 
        WHEN SUM(e.score) >= 50 THEN 1
        ELSE 0
    END AS passed_flag,
    CASE
        WHEN f.exam_date <= s.enrollment_date + 10 THEN 1
        ELSE 0
    END AS first_attempt_within_10_days
FROM
    students s
JOIN
    exam_attempts e ON s.student_id = e.student_id
JOIN
    first_attempt f ON s.student_id = f.student_id
GROUP BY
    s.student_id, s.name, s.enrollment_date, f.exam_date
ORDER BY
    s.student_id;

----14-06-2025  Satuarday-----------------------------------------------------------------------------------


--common table expression cte people call it as a with clause

With cte as (select * from hr.employees ),
ctel as (select * from hr.departments)
select cte.*,ctel.department_name from
cte,ctel where cte.department_id=ctel.department_id ;


-- merge
CREATE TABLE employees1 (
    emp_id      NUMBER PRIMARY KEY,
    emp_name    VARCHAR2(50),
    salary      NUMBER,
    department  VARCHAR2(30)
);

select * from employees1 ;

INSERT INTO employees1 VALUES (101, 'Alice', 50000, 'HR');
INSERT INTO employees1 VALUES (102, 'Bob', 60000, 'Finance');
INSERT INTO employees1 VALUES (103, 'Charlie', 55000, 'IT');
INSERT INTO employees1 VALUES (104, 'David', 52000, 'HR');
COMMIT;

CREATE TABLE emp_updates (
    emp_id      NUMBER,
    emp_name    VARCHAR2(50),
    salary      NUMBER,
    department  VARCHAR2(30)
);

select * from emp_updates;

INSERT INTO emp_updates VALUES (102, 'Bob', 65000, 'Finance');   -- Existing employee (UPDATE)
INSERT INTO emp_updates VALUES (103, 'Charlie', 57000, 'IT');    -- Existing employee (UPDATE)
INSERT INTO emp_updates VALUES (105, 'Eva', 50000, 'Marketing'); -- New employee (INSERT)
INSERT INTO emp_updates VALUES (106, 'Frank', 48000, 'Sales');   -- New employee (INSERT)
COMMIT;

MERGE INTO employees1 tgt
USING emp_updates src
ON (tgt.emp_id = src.emp_id)
WHEN MATCHED THEN
    UPDATE SET
        tgt.emp_name = src.emp_name,
        tgt.salary = src.salary,
        tgt.department = src.department
WHEN NOT MATCHED THEN
    INSERT (emp_id, emp_name, salary, department)
    VALUES (src.emp_id, src.emp_name, src.salary, src.department);



select * from emp_updates;
select * from employees1;

--1. MERGE with Condition  Only Update if Salary Has Changed
MERGE INTO employees1 tgt
USING emp_updates src
ON (tgt.emp_id = src.emp_id)
WHEN MATCHED THEN
    UPDATE SET
        tgt.salary = src.salary
    WHERE tgt.salary != src.salary  -- Only update if salary is different
WHEN NOT MATCHED THEN
    INSERT (emp_id, emp_name, salary, department)
    VALUES (src.emp_id, src.emp_name, src.salary, src.department);

-- 2. MERGE with DELETE (Delete employees no longer in source)
Lets say we want to delete records in employees that are not in emp_updates.
--Step A: Add extra employee to employees to simulate this:

INSERT INTO employees1 VALUES (107, 'George', 47000, 'Support');
COMMIT;

--Step B: MERGE with DELETE logic using a subquery:
MERGE INTO employees1 tgt
USING (
    SELECT emp_id FROM emp_updates
) src
ON (tgt.emp_id = src.emp_id)
WHEN NOT MATCHED BY SOURCE THEN
    DELETE;
--     Result: Employee 107 - George will be deleted because he's not in the source (emp_updates).


--3. MERGE with Specific Field Updates Only (Partial Columns)
--Lets say we only want to update the department if the name and ID match:

MERGE INTO employees tgt
USING emp_updates src
ON (tgt.emp_id = src.emp_id AND tgt.emp_name = src.emp_name)
WHEN MATCHED THEN
  UPDATE SET tgt.department = src.department
WHEN NOT MATCHED THEN
  INSERT
    (emp_id, emp_name, salary, department)
  VALUES
    (src.emp_id, src.emp_name, src.salary, src.department);
--     Use case: This protects against name mismatches and only updates department field.



--
MERGE INTO hr.employees e
USING hr.employees h
ON (e.employee_id = h.employee_id)
WHEN MATCHED THEN
  UPDATE SET e.salary = h.salary
WHEN NOT MATCHED THEN
  INSERT
    (employee_id,
     first_name,
     last_name,
     email,
     phone_number,
     hire_date,
     job_id,
     salary,
     commission_pct,
     manager_id,
     department_id)
  VALUES
    (h.employee_id,
     h.first_name,
     h.last_name,
     h.email,
     h.phone_number,
     h.hire_date,
     h.job_id,
     h.salary,
     h.commission_pct,
     h.manager_id,
     h.department_id);

--          connect by 


SELECT employee_id, manager_id, LEVEL,
       LPAD(' ', LEVEL * 2) || first_name AS hierarchy
FROM hr.employees
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id;

SELECT employee_id, manager_id, LEVEL,
       CONNECT_BY_ISLEAF AS is_leaf
FROM hr.employees  -- people who have not hierarchi
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id;

SELECT employee_id, first_name, manager_id, LEVEL,
       SYS_CONNECT_BY_PATH(first_name, ' -> ') AS hierarchy_path
FROM hr.employees  -- people who have hierarchi
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id;

select * from product ;


product table 

p1 --p2

p2 -- p3

p4--p5'

p1 ->p2->p3->p4->p5
 

CREATE TABLE product (
    product_id      NUMBER PRIMARY KEY,
    product_name    VARCHAR2(100),
    depends_on_id   NUMBER, 
    price           NUMBER,
    CONSTRAINT fk_product_depends
        FOREIGN KEY (depends_on_id)
        REFERENCES product(product_id)
);

-- Base components
INSERT INTO product VALUES (1, 'Motherboard', NULL, 5000);
INSERT INTO product VALUES (2, 'Monitor', NULL, 7000);
INSERT INTO product VALUES (3, 'Processor', 1, 8000);
INSERT INTO product VALUES (4, 'RAM', 1, 3000);
INSERT INTO product VALUES (5, 'Thermal Paste', 3, 500);
INSERT INTO product VALUES (6, 'RAM Heatsink', 4, 1000);
INSERT INTO product VALUES (7, 'HDMI Cable', 2, 400);

select product_id,product_name,depends_on_id,level,
       SYS_CONNECT_BY_PATH(product_name, ' -> ') AS depends_product
from product 
start with depends_on_id is null
CONNECT BY PRIOR product_id = depends_on_id;

select * from product;



-------------- Procedure debug
create table err_log (id number , log_message varchar2(4000),user_nm varchar2(100),system_dattime timestamp);

create sequence seq_err;

create or replace procedure prc_err_log (p_log_msg varchar2,p_user_nm varchar2)
is
begin
insert into err_log values(seq_err.nextval,p_log_msg,p_user_nm,systimestamp) ;
commit;
exception when others then
null;
end;


----15-06-2025  Sunday-----------------------------------------------------------------------------------
----

 What is a Regular Expression (RegEx)?
A Regular Expression (RegEx) is a pattern used to match character combinations in strings. 
Its like a powerful search tool that can check if a string contains a specific pattern, 
extract parts of a string, or replace text.

-- Basic Symbols
| Pattern | Description                         | Example Match                            |       |                          |
| ------- | ----------------------------------- | ---------------------------------------- | ----- | ------------------------ |
| `.`     | Any single character except newline | `a.c` matches `abc`, `a7c`               |       |                          |
| `^`     | Start of line                       | `^abc` matches `abc`, not `xabc`         |       |                          |
| `$`     | End of line                         | `abc$` matches `abc`, not `abcd`         |       |                          |
| `*`     | 0 or more occurrences               | `ab*c` matches `ac`, `abc`, `abbbc`      |       |                          |
| `+`     | 1 or more occurrences               | `ab+c` matches `abc`, `abbbc` (not `ac`) |       |                          |
| `?`     | 0 or 1 occurrence                   | `ab?c` matches `ac`, `abc`               |       |                          |
| \`      | \`                                  | Alternation (OR)                         | \`cat | dog`matches`cat`, `dog\` |

-- Character Sets
| Pattern       | Description          | Example Match                       |
| ------------- | -------------------- | ----------------------------------- |
| `[abc]`       | a or b or c          | Matches `a`, `b`, or `c`            |
| `[^abc]`      | Not a, b, or c       | Matches `x`, `1`, not `a`, `b`, `c` |
| `[a-z]`       | Any lowercase letter | Matches `a` to `z`                  |
| `[A-Z]`       | Any uppercase letter | Matches `A` to `Z`                  |
| `[0-9]`       | Any digit            | Matches `0` to `9`                  |
| `[a-zA-Z0-9]` | Alphanumeric         | Matches `a`, `Z`, `7`               |

-- Meta Characters (Escaped Sequences)
| Pattern | Description                         | Example Match                  |
| ------- | ----------------------------------- | ------------------------------ |
| `\d`    | Any digit (09)                     | Matches `5`                    |
| `\D`    | Any non-digit                       | Matches `a`, `-`, not `5`      |
| `\w`    | Word character (letter, digit, `_`) | Matches `a`, `Z`, `7`, `_`     |
| `\W`    | Non-word character                  | Matches `#`, `@`, not `a`, `1` |
| `\s`    | Whitespace (space, tab, newline)    | Matches space, tab             |
| `\S`    | Non-whitespace                      | Matches `a`, `9`, not space    |

-- Quantifiers
| Pattern | Description           | Example Match                        |
| ------- | --------------------- | ------------------------------------ |
| `{n}`   | Exactly n times       | `a{3}` matches `aaa`                 |
| `{n,}`  | At least n times      | `a{2,}` matches `aa`, `aaaa`         |
| `{n,m}` | Between n and m times | `a{2,4}` matches `aa`, `aaa`, `aaaa` |

-- Assertions (Lookaround)
| Pattern    | Description         | Example                                   |
| ---------- | ------------------- | ----------------------------------------- |
| `(?=...)`  | Positive lookahead  | `\d(?=%)` matches digit before `%`        |
| `(?!...)`  | Negative lookahead  | `\d(?!%)` matches digit not before `%`    |
| `(?<=...)` | Positive lookbehind | `(?<=\$)\d+` matches digits after `$`     |
| `(?<!...)` | Negative lookbehind | `(?<!\$)\d+` matches digits not after `$` |

-- Grouping and Capturing
| Pattern          | Description                      | Example                          |
| ---------------- | -------------------------------- | -------------------------------- |
| `(abc)`          | Capturing group                  | Captures `abc` as a group        |
| `(?:abc)`        | Non-capturing group              | Groups `abc` but doesnt capture |
| `\1`, `\2`, etc. | Backreference to captured groups | Useful in replacement            |

-- Anchors
 | Pattern | Description                            |
| ------- | -------------------------------------- |
| `\b`    | Word boundary (start or end of a word) |
| `\B`    | Not a word boundary                    |

-- Common Real-World Patterns
| Use Case                                        | Pattern                                  |
| ----------------------------------------------- | ---------------------------------------- |
| Email                                           | `^[\w.-]+@[a-zA-Z\d.-]+\.[a-zA-Z]{2,6}$` |
| Phone (10-digit)                                | `^\d{10}$`                               |
| PAN (India)                                     | `^[A-Z]{5}\d{4}[A-Z]$`                   |
| Password (min 8, at least 1 letter and 1 digit) | `^(?=.*[A-Za-z])(?=.*\d).{8,}$`          |
| Decimal number                                  | `^\d+(\.\d+)?$`                          |
| IP Address                                      | `^(\d{1,3}\.){3}\d{1,3}$`                |


--  1. Email Validation
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
--Matches: test.user123@gmail.com
--Invalid: user@.com, @gmail.com

--  2. Mobile Number (India - 10 digits)
^[6-9]\d{9}$
--Matches: 9876543210
--Invalid: 1234567890 (starts with 1)

-- 3. PAN Card (India)
^[A-Z]{5}[0-9]{4}[A-Z]$
--Matches: ABCDE1234F
--Invalid: abcde1234f, A1234E567F

-- 4. Date in Format DD-MM-YYYY
^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-\d{4}$
--Matches: 31-12-2025
--Invalid: 32-01-2025, 15/08/2025

-- 5. Strong Password (Min 8, letter, digit, special char)
^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!%*#?&]{8,}$
--Matches: Pass@1234
--Invalid: password, pass1234 (no special char)

-- 6. Extract All Numbers From a String
\d+
--From: "Order #1234 for 5 items"
--Extracts: 1234, 5

-- 7. HTML Tag Detection
<[^>]+>
-- Matches: <div>, <a href="#">, <img src="...">

-- 8. Extract Domain from Email
@([a-zA-Z0-9.-]+)
--From: user123@gmail.com
--Captures: gmail.com

-- 9. Whitespace Cleanup (Multiple to Single Space)
\s{2,}
--Replace with: ' '
-- "This is a test"  "This is a test"

-- 10. IP Address Format
^(\d{1,3}\.){3}\d{1,3}$
--Matches: 192.168.1.1
--Invalid: 999.999.999.999 (logically invalid, but pattern matches)

-- 11. GST Number (India)
^\d{2}[A-Z]{5}\d{4}[A-Z]{1}[1-9A-Z]{1}Z[0-9A-Z]{1}$
--Matches: 22ABCDE1234F1Z5
 
-- 12. URL Matching
https?:\/\/[^\s]+
--Matches: http://example.com, https://www.site.in

-- 13. Words Starting with Capital Letter
\b[A-Z][a-z]+
-- Matches: India, Shubham, Regex

-- 14. File Extensions (.jpg, .png, .pdf)
.*\.(jpg|jpeg|png|pdf)$
-- Matches: file.jpg, doc.pdf
--Invalid: file.docx

-- 15. Time Format (HH:MM 24-hour)
^([01]\d|2[0-3]):[0-5]\d$
--Matches: 14:30, 09:45
--Invalid: 25:00, 14:99

--
SELECT email
FROM hr.employees
WHERE REGEXP_LIKE(email, '^[a-z0-9._%+-]+@[a-z0-9.-]+\.(com)$');

SELECT first_name,
       REGEXP_INSTR(first_name, '\d') AS digit_position
FROM hr.employees;



-----------------------------------------------------Assigement-1  15-06-2025 Sunday
CREATE TABLE employee (
    employee_id     VARCHAR2(10),
    department      VARCHAR2(50),
    project         VARCHAR2(100),
    work_date       DATE,
    hours_worked    NUMBER(5,2),
    tasks_completed NUMBER
);

select * from employee ;

truncate table employee ;


ALTER SESSION SET CURRENT_SCHEMA = shubh;

rollback ;

select count(*) from employee ;

INSERT ALL
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (503, 'IT', 'Alpha', TO_DATE('19-05-2024', 'DD-MM-YYYY'), 2.8, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (513, 'IT', 'Alpha', TO_DATE('07-05-2024', 'DD-MM-YYYY'), 4.7, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (502, 'HR', 'Alpha', TO_DATE('29-05-2024', 'DD-MM-YYYY'), 4.9, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (511, 'Finance', 'Beta', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 3.9, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (519, 'HR', 'Beta', TO_DATE('13-05-2024', 'DD-MM-YYYY'), 4.4, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (511, 'IT', 'Alpha', TO_DATE('23-05-2024', 'DD-MM-YYYY'), 8.0, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (516, 'HR', 'Alpha', TO_DATE('06-05-2024', 'DD-MM-YYYY'), 2.2, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (510, 'Finance', 'Alpha', TO_DATE('24-05-2024', 'DD-MM-YYYY'), 4.3, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (520, 'Marketing', 'Beta', TO_DATE('24-05-2024', 'DD-MM-YYYY'), 3.6, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'HR', 'Alpha', TO_DATE('01-05-2024', 'DD-MM-YYYY'), 5.0, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'IT', 'Alpha', TO_DATE('28-05-2024', 'DD-MM-YYYY'), 7.6, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (510, 'Marketing', 'Alpha', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 8.0, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'IT', 'Gamma', TO_DATE('20-05-2024', 'DD-MM-YYYY'), 4.2, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (512, 'HR', 'Beta', TO_DATE('14-05-2024', 'DD-MM-YYYY'), 5.8, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (511, 'IT', 'Alpha', TO_DATE('09-05-2024', 'DD-MM-YYYY'), 2.7, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (513, 'HR', 'Alpha', TO_DATE('23-05-2024', 'DD-MM-YYYY'), 3.8, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (514, 'HR', 'Alpha', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 7.3, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'Marketing', 'Beta', TO_DATE('04-05-2024', 'DD-MM-YYYY'), 5.4, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (506, 'HR', 'Gamma', TO_DATE('30-05-2024', 'DD-MM-YYYY'), 7.7, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (505, 'Finance', 'Gamma', TO_DATE('18-05-2024', 'DD-MM-YYYY'), 8.2, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (519, 'IT', 'Alpha', TO_DATE('21-05-2024', 'DD-MM-YYYY'), 2.1, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (508, 'Marketing', 'Alpha', TO_DATE('23-05-2024', 'DD-MM-YYYY'), 8.3, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'IT', 'Gamma', TO_DATE('11-05-2024', 'DD-MM-YYYY'), 6.1, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (513, 'IT', 'Beta', TO_DATE('01-05-2024', 'DD-MM-YYYY'), 7.4, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'Finance', 'Gamma', TO_DATE('03-05-2024', 'DD-MM-YYYY'), 8.9, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (509, 'Marketing', 'Beta', TO_DATE('01-05-2024', 'DD-MM-YYYY'), 8.5, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (513, 'IT', 'Beta', TO_DATE('02-05-2024', 'DD-MM-YYYY'), 3.3, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (505, 'IT', 'Gamma', TO_DATE('07-05-2024', 'DD-MM-YYYY'), 4.7, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (513, 'HR', 'Gamma', TO_DATE('03-05-2024', 'DD-MM-YYYY'), 4.0, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'Finance', 'Alpha', TO_DATE('02-05-2024', 'DD-MM-YYYY'), 6.1, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (515, 'Finance', 'Gamma', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 5.8, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'IT', 'Alpha', TO_DATE('23-05-2024', 'DD-MM-YYYY'), 6.9, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (512, 'Finance', 'Gamma', TO_DATE('07-05-2024', 'DD-MM-YYYY'), 3.4, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (516, 'IT', 'Beta', TO_DATE('27-05-2024', 'DD-MM-YYYY'), 3.8, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (503, 'IT', 'Gamma', TO_DATE('23-05-2024', 'DD-MM-YYYY'), 2.9, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (511, 'IT', 'Alpha', TO_DATE('09-05-2024', 'DD-MM-YYYY'), 2.7, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (503, 'Finance', 'Alpha', TO_DATE('31-05-2024', 'DD-MM-YYYY'), 8.5, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (510, 'Marketing', 'Beta', TO_DATE('16-05-2024', 'DD-MM-YYYY'), 8.9, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (503, 'HR', 'Beta', TO_DATE('02-05-2024', 'DD-MM-YYYY'), 3.4, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (502, 'Marketing', 'Alpha', TO_DATE('03-05-2024', 'DD-MM-YYYY'), 4.0, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (511, 'IT', 'Gamma', TO_DATE('01-05-2024', 'DD-MM-YYYY'), 6.9, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (513, 'HR', 'Gamma', TO_DATE('03-05-2024', 'DD-MM-YYYY'), 4.0, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (508, 'IT', 'Beta', TO_DATE('07-05-2024', 'DD-MM-YYYY'), 8.5, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'Finance', 'Alpha', TO_DATE('02-05-2024', 'DD-MM-YYYY'), 6.1, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (518, 'IT', 'Gamma', TO_DATE('04-05-2024', 'DD-MM-YYYY'), 7.7, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (519, 'IT', 'Gamma', TO_DATE('21-05-2024', 'DD-MM-YYYY'), 2.1, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (502, 'IT', 'Alpha', TO_DATE('05-05-2024', 'DD-MM-YYYY'), 3.9, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (505, 'IT', 'Alpha', TO_DATE('07-05-2024', 'DD-MM-YYYY'), 4.7, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (509, 'IT', 'Gamma', TO_DATE('29-05-2024', 'DD-MM-YYYY'), 4.7, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'HR', 'Beta', TO_DATE('19-05-2024', 'DD-MM-YYYY'), 4.9, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'HR', 'Beta', TO_DATE('19-05-2024', 'DD-MM-YYYY'), 6.7, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (514, 'Finance', 'Beta', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 7.3, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'IT', 'Gamma', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 2.1, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (516, 'HR', 'Alpha', TO_DATE('16-05-2024', 'DD-MM-YYYY'), 2.2, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (506, 'HR', 'Gamma', TO_DATE('16-05-2024', 'DD-MM-YYYY'), 4.2, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (510, 'IT', 'Alpha', TO_DATE('24-05-2024', 'DD-MM-YYYY'), 4.3, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'Marketing', 'Beta', TO_DATE('28-05-2024', 'DD-MM-YYYY'), 8.2, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (520, 'Marketing', 'Beta', TO_DATE('24-05-2024', 'DD-MM-YYYY'), 3.6, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'HR', 'Alpha', TO_DATE('02-05-2024', 'DD-MM-YYYY'), 8.4, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (502, 'Finance', 'Alpha', TO_DATE('10-05-2024', 'DD-MM-YYYY'), 4.4, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (505, 'Finance', 'Beta', TO_DATE('20-05-2024', 'DD-MM-YYYY'), 7.7, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (505, 'Finance', 'Beta', TO_DATE('18-05-2024', 'DD-MM-YYYY'), 8.2, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (512, 'IT', 'Alpha', TO_DATE('07-05-2024', 'DD-MM-YYYY'), 2.7, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (513, 'Marketing', 'Gamma', TO_DATE('01-05-2024', 'DD-MM-YYYY'), 7.6, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (510, 'Marketing', 'Alpha', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 8.0, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (501, 'Marketing', 'Alpha', TO_DATE('04-05-2024', 'DD-MM-YYYY'), 7.7, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'Marketing', 'Beta', TO_DATE('04-05-2024', 'DD-MM-YYYY'), 5.4, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (520, 'Marketing', 'Alpha', TO_DATE('30-05-2024', 'DD-MM-YYYY'), 2.4, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (512, 'HR', 'Beta', TO_DATE('14-05-2024', 'DD-MM-YYYY'), 5.8, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (514, 'HR', 'Gamma', TO_DATE('05-05-2024', 'DD-MM-YYYY'), 5.5, 3)
SELECT 1 FROM DUAL;

INSERT ALL
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (519, 'IT', 'Alpha', TO_DATE('21-05-2024', 'DD-MM-YYYY'), 2.1, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (502, 'IT', 'Alpha', TO_DATE('05-05-2024', 'DD-MM-YYYY'), 3.9, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (505, 'IT', 'Alpha', TO_DATE('07-05-2024', 'DD-MM-YYYY'), 4.7, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (509, 'IT', 'Gamma', TO_DATE('29-05-2024', 'DD-MM-YYYY'), 4.7, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'HR', 'Beta', TO_DATE('19-05-2024', 'DD-MM-YYYY'), 4.9, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'HR', 'Beta', TO_DATE('19-05-2024', 'DD-MM-YYYY'), 6.7, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (514, 'Finance', 'Beta', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 7.3, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'IT', 'Gamma', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 2.1, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (516, 'HR', 'Alpha', TO_DATE('16-05-2024', 'DD-MM-YYYY'), 2.2, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (506, 'HR', 'Gamma', TO_DATE('16-05-2024', 'DD-MM-YYYY'), 4.2, 1)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (510, 'IT', 'Alpha', TO_DATE('24-05-2024', 'DD-MM-YYYY'), 4.3, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'Marketing', 'Beta', TO_DATE('28-05-2024', 'DD-MM-YYYY'), 8.2, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (520, 'Marketing', 'Beta', TO_DATE('24-05-2024', 'DD-MM-YYYY'), 3.6, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'HR', 'Alpha', TO_DATE('02-05-2024', 'DD-MM-YYYY'), 8.4, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (502, 'Finance', 'Alpha', TO_DATE('10-05-2024', 'DD-MM-YYYY'), 4.4, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (505, 'Finance', 'Beta', TO_DATE('20-05-2024', 'DD-MM-YYYY'), 7.7, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (505, 'Finance', 'Beta', TO_DATE('18-05-2024', 'DD-MM-YYYY'), 8.2, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (512, 'IT', 'Alpha', TO_DATE('07-05-2024', 'DD-MM-YYYY'), 2.7, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (513, 'Marketing', 'Gamma', TO_DATE('01-05-2024', 'DD-MM-YYYY'), 7.6, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (510, 'Marketing', 'Alpha', TO_DATE('26-05-2024', 'DD-MM-YYYY'), 8.0, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (501, 'Marketing', 'Alpha', TO_DATE('04-05-2024', 'DD-MM-YYYY'), 7.7, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'Marketing', 'Beta', TO_DATE('04-05-2024', 'DD-MM-YYYY'), 5.4, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (520, 'Marketing', 'Alpha', TO_DATE('30-05-2024', 'DD-MM-YYYY'), 2.4, 2)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (512, 'HR', 'Beta', TO_DATE('14-05-2024', 'DD-MM-YYYY'), 5.8, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (514, 'HR', 'Gamma', TO_DATE('05-05-2024', 'DD-MM-YYYY'), 5.5, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (519, 'IT', 'Alpha', TO_DATE('21-05-2024', 'DD-MM-YYYY'), 2.1, 5)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (517, 'HR', 'Gamma', TO_DATE('31-05-2024', 'DD-MM-YYYY'), 7.4, 4)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (511, 'HR', 'Gamma', TO_DATE('16-05-2024', 'DD-MM-YYYY'), 7.4, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (510, 'Marketing', 'Gamma', TO_DATE('16-05-2024', 'DD-MM-YYYY'), 8.9, 3)
  INTO employee (employee_id, department, project, work_date, hours_worked, tasks_completed) VALUES (504, 'IT', 'Gamma', TO_DATE('21-05-2024', 'DD-MM-YYYY'), 8.9, 3)
SELECT 1 FROM DUAL;


--How do you calculate total hours worked by each employee?

select employee_id, sum(hours_worked) as total_work
  from employee
 group by employee_id;

create or replace procedure emp_total_hour_work is
begin
  for rec in (select employee_id, sum(hours_worked) as total_hour
                from employee
               group by employee_id) loop
    dbms_output.put_line('Employee :' || rec.employee_id ||
                         ' Total hour work is :' || rec.total_hour);
  end loop;
end;

begin
  emp_total_hour_work;
end;

--How can you find the average number of tasks completed per department?

select department, avg(tasks_completed) as average_task_completed
  from employee
 group by department;

create or replace procedure emp_average_task_completed is
begin
  for rec in (select department,
                     round(avg(tasks_completed),3) as average_task_completed
                from employee
               group by department) loop
    dbms_output.put_line('Department :' || rec.department ||
                         ' Average number of tasks completed :' ||
                         rec.average_task_completed);
  end loop;
end;

begin
  emp_average_task_completed;
end;

--Which project had the highest total hours logged?

create or replace procedure emp_project_highest_hours is
begin
  for rec in (SELECT *
                FROM (SELECT project, SUM(hours_worked) AS total_work
                        FROM employee
                       GROUP BY project
                       ORDER BY total_work DESC)
               WHERE ROWNUM <= 1) loop
    dbms_output.put_line('Department :' || rec.project ||
                         ' Average number of tasks completed :' ||
                         rec.total_work);
  end loop;
end;

begin
  emp_project_highest_hours;
end;

--How do you merge employee data with department information?

CREATE TABLE department (
    department_name VARCHAR2(50),
    manager         VARCHAR2(50),
    location        VARCHAR2(50)
);

drop table department ;

ALTER TABLE employee ADD (manager VARCHAR2(50), location VARCHAR2(50));

INSERT INTO department VALUES ('IT', 'Amit Sharma', 'Mumbai');
INSERT INTO department VALUES ('HR', 'Nina Rao', 'Delhi');
INSERT INTO department VALUES ('Finance', 'Sahil Mehta', 'Bangalore');
INSERT INTO department VALUES ('Marketing', 'Priya Kapoor', 'Pune');

MERGE INTO employee e
USING department d
ON (e.department = d.department_name)
WHEN MATCHED THEN
  UPDATE SET e.manager = d.manager,
             e.location = d.location;

select * from employee ;
select * from department ;

--How can you create a summary table of productivity metrics by department and project?
create table emp_summary as
select 
    department,
    project,
    count(*) as total_entries,
    sum(hours_worked) as total_hours,
    sum(tasks_completed) as total_tasks,
    sum(hours_worked) / nullif(sum(tasks_completed), 0) as avg_hours_per_task
from 
    employee
group by 
    department, project;

select * from emp_summary ;

select * from employee ;

-----------------------------------------------------Assigement-2  16-06-2025 Monday

CREATE TABLE orders_1 (
    order_id      NUMBER PRIMARY KEY,
    order_date    DATE,
    customer_id   NUMBER,
    product_id    NUMBER,
    product_name  VARCHAR2(50),
    quantity      NUMBER,
    price         NUMBER(10, 2)
);

INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1001, TO_DATE('21-06-2024', 'DD-MM-YYYY'), 2037, 3010, 'Laptop', 3, 897.45);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1002, TO_DATE('17-02-2024', 'DD-MM-YYYY'), 2035, 3002, 'Tablet', 1, 176.79);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1003, TO_DATE('27-04-2024', 'DD-MM-YYYY'), 2049, 3007, 'Camera', 4, 790.23);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1004, TO_DATE('11-07-2024', 'DD-MM-YYYY'), 2030, 3009, 'Laptop', 1, 928.91);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1005, TO_DATE('19-11-2024', 'DD-MM-YYYY'), 2004, 3009, 'Camera', 1, 729.42);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1006, TO_DATE('08-09-2024', 'DD-MM-YYYY'), 2035, 3004, 'Headphones', 2, 516.28);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1007, TO_DATE('14-07-2024', 'DD-MM-YYYY'), 2043, 3003, 'Headphones', 1, 496.02);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1008, TO_DATE('25-12-2024', 'DD-MM-YYYY'), 2014, 3004, 'Laptop', 2, 888.57);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1009, TO_DATE('10-01-2024', 'DD-MM-YYYY'), 2049, 3007, 'Laptop', 1, 513.99);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1010, TO_DATE('30-07-2024', 'DD-MM-YYYY'), 2040, 3004, 'Headphones', 4, 443.84);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1011, TO_DATE('04-10-2024', 'DD-MM-YYYY'), 2022, 3007, 'Headphones', 3, 215.41);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1012, TO_DATE('30-08-2024', 'DD-MM-YYYY'), 2010, 3006, 'Laptop', 3, 501.52);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1013, TO_DATE('19-10-2024', 'DD-MM-YYYY'), 2001, 3008, 'Headphones', 2, 794.47);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1014, TO_DATE('28-03-2024', 'DD-MM-YYYY'), 2011, 3001, 'Laptop', 1, 578.61);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1015, TO_DATE('11-03-2024', 'DD-MM-YYYY'), 2044, 3009, 'Tablet', 1, 186.64);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1016, TO_DATE('29-03-2024', 'DD-MM-YYYY'), 2024, 3005, 'Phone', 1, 186.64);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1017, TO_DATE('10-11-2024', 'DD-MM-YYYY'), 2003, 3007, 'Laptop', 1, 666.99);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1018, TO_DATE('12-07-2024', 'DD-MM-YYYY'), 2035, 3006, 'Camera', 1, 562.26);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1019, TO_DATE('09-02-2024', 'DD-MM-YYYY'), 2036, 3009, 'Laptop', 4, 359.40);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1020, TO_DATE('28-03-2024', 'DD-MM-YYYY'), 2031, 3003, 'Headphones', 3, 189.66);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1021, TO_DATE('23-06-2024', 'DD-MM-YYYY'), 2004, 3004, 'Camera', 2, 201.88);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1022, TO_DATE('29-03-2024', 'DD-MM-YYYY'), 2019, 3010, 'Camera', 1, 172.94);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1023, TO_DATE('03-12-2024', 'DD-MM-YYYY'), 2047, 3008, 'Phone', 3, 599.98);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1024, TO_DATE('14-06-2024', 'DD-MM-YYYY'), 2036, 3006, 'Laptop', 4, 137.65);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1025, TO_DATE('26-01-2024', 'DD-MM-YYYY'), 2021, 3004, 'Tablet', 4, 915.02);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1026, TO_DATE('29-11-2024', 'DD-MM-YYYY'), 2018, 3005, 'Camera', 4, 128.82);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1027, TO_DATE('13-03-2024', 'DD-MM-YYYY'), 2028, 3006, 'Camera', 4, 810.36);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1028, TO_DATE('22-09-2024', 'DD-MM-YYYY'), 2015, 3004, 'Tablet', 1, 883.27);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1029, TO_DATE('25-04-2024', 'DD-MM-YYYY'), 2042, 3004, 'Camera', 3, 138.79);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1030, TO_DATE('31-08-2024', 'DD-MM-YYYY'), 2002, 3008, 'Headphones', 2, 454.99);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1031, TO_DATE('16-07-2024', 'DD-MM-YYYY'), 2037, 3010, 'Tablet', 1, 499.56);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1032, TO_DATE('01-12-2024', 'DD-MM-YYYY'), 2011, 3010, 'Headphones', 4, 601.19);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1033, TO_DATE('04-12-2024', 'DD-MM-YYYY'), 2023, 3010, 'Laptop', 4, 730.43);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1034, TO_DATE('09-04-2024', 'DD-MM-YYYY'), 2044, 3008, 'Laptop', 4, 75.72);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1035, TO_DATE('26-06-2024', 'DD-MM-YYYY'), 2041, 3004, 'Laptop', 4, 744.83);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1036, TO_DATE('31-08-2024', 'DD-MM-YYYY'), 2012, 3003, 'Headphones', 1, 778.62);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1037, TO_DATE('12-10-2024', 'DD-MM-YYYY'), 2003, 3004, 'Camera', 3, 59.28);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1038, TO_DATE('27-05-2024', 'DD-MM-YYYY'), 2017, 3010, 'Camera', 2, 342.87);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1039, TO_DATE('27-05-2024', 'DD-MM-YYYY'), 2033, 3008, 'Tablet', 3, 271.22);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1040, TO_DATE('15-10-2024', 'DD-MM-YYYY'), 2001, 3008, 'Tablet', 3, 528.26);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1041, TO_DATE('22-09-2024', 'DD-MM-YYYY'), 2039, 3006, 'Camera', 2, 956.04);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1042, TO_DATE('04-07-2024', 'DD-MM-YYYY'), 2020, 3002, 'Phone', 4, 579.92);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1043, TO_DATE('07-05-2024', 'DD-MM-YYYY'), 2047, 3003, 'Headphones', 4, 142.60);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1044, TO_DATE('02-02-2024', 'DD-MM-YYYY'), 2043, 3003, 'Headphones', 1, 640.59);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1045, TO_DATE('01-02-2024', 'DD-MM-YYYY'), 2041, 3009, 'Headphones', 1, 869.87);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1046, TO_DATE('21-07-2024', 'DD-MM-YYYY'), 2014, 3002, 'Phone', 3, 199.75);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1047, TO_DATE('01-09-2024', 'DD-MM-YYYY'), 2031, 3006, 'Tablet', 2, 992.81);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1048, TO_DATE('31-05-2024', 'DD-MM-YYYY'), 2025, 3009, 'Tablet', 2, 130.75);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1049, TO_DATE('12-06-2024', 'DD-MM-YYYY'), 2003, 3005, 'Headphones', 1, 139.74);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1050, TO_DATE('02-07-2024', 'DD-MM-YYYY'), 2004, 3001, 'Tablet', 4, 651.93);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1051, TO_DATE('29-01-2024', 'DD-MM-YYYY'), 2031, 3003, 'Headphones', 1, 951.83);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1052, TO_DATE('17-10-2024', 'DD-MM-YYYY'), 2035, 3006, 'Camera', 3, 939.91);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1053, TO_DATE('08-05-2024', 'DD-MM-YYYY'), 2044, 3006, 'Camera', 1, 475.01);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1054, TO_DATE('08-05-2024', 'DD-MM-YYYY'), 2014, 3001, 'Tablet', 4, 741.31);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1055, TO_DATE('23-02-2024', 'DD-MM-YYYY'), 2049, 3009, 'Phone', 2, 755.13);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1056, TO_DATE('08-02-2024', 'DD-MM-YYYY'), 2041, 3002, 'Tablet', 3, 341.64);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1057, TO_DATE('01-09-2024', 'DD-MM-YYYY'), 2009, 3002, 'Laptop', 4, 163.78);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1058, TO_DATE('30-09-2024', 'DD-MM-YYYY'), 2020, 3001, 'Headphones', 3, 471.68);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1059, TO_DATE('01-12-2024', 'DD-MM-YYYY'), 2032, 3004, 'Laptop', 2, 422.19);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1060, TO_DATE('15-04-2024', 'DD-MM-YYYY'), 2009, 3009, 'Tablet', 1, 555.26);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1061, TO_DATE('12-02-2024', 'DD-MM-YYYY'), 2027, 3009, 'Camera', 1, 853.09);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1062, TO_DATE('01-02-2024', 'DD-MM-YYYY'), 2003, 3005, 'Headphones', 2, 559.46);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1063, TO_DATE('14-09-2024', 'DD-MM-YYYY'), 2004, 3005, 'Tablet', 1, 696.26);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1064, TO_DATE('17-11-2024', 'DD-MM-YYYY'), 2045, 3001, 'Phone', 1, 628.72);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1065, TO_DATE('27-02-2024', 'DD-MM-YYYY'), 2015, 3010, 'Tablet', 3, 143.55);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1066, TO_DATE('18-10-2024', 'DD-MM-YYYY'), 2033, 3004, 'Phone', 1, 137.43);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1067, TO_DATE('24-12-2024', 'DD-MM-YYYY'), 2005, 3008, 'Camera', 1, 103.17);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1068, TO_DATE('29-04-2024', 'DD-MM-YYYY'), 2004, 3004, 'Phone', 2, 132.21);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1069, TO_DATE('24-09-2024', 'DD-MM-YYYY'), 2046, 3003, 'Laptop', 4, 275.31);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1070, TO_DATE('23-03-2024', 'DD-MM-YYYY'), 2012, 3002, 'Laptop', 2, 847.54);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1071, TO_DATE('01-04-2024', 'DD-MM-YYYY'), 2023, 3002, 'Laptop', 2, 546.25);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1072, TO_DATE('09-04-2024', 'DD-MM-YYYY'), 2014, 3003, 'Laptop', 2, 537.42);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1073, TO_DATE('23-02-2024', 'DD-MM-YYYY'), 2046, 3002, 'Laptop', 2, 667.34);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1074, TO_DATE('01-05-2024', 'DD-MM-YYYY'), 2012, 3005, 'Phone', 4, 567.36);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1075, TO_DATE('25-03-2024', 'DD-MM-YYYY'), 2017, 3003, 'Laptop', 2, 80.84);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1076, TO_DATE('22-07-2024', 'DD-MM-YYYY'), 2025, 3006, 'Headphones', 3, 601.14);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1077, TO_DATE('20-11-2024', 'DD-MM-YYYY'), 2030, 3006, 'Phone', 1, 782.53);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1078, TO_DATE('19-09-2024', 'DD-MM-YYYY'), 2022, 3006, 'Camera', 3, 407.42);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1079, TO_DATE('17-02-2024', 'DD-MM-YYYY'), 2047, 3003, 'Phone', 1, 516.47);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1080, TO_DATE('07-05-2024', 'DD-MM-YYYY'), 2026, 3006, 'Tablet', 4, 982.56);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1081, TO_DATE('11-05-2024', 'DD-MM-YYYY'), 2017, 3008, 'Camera', 4, 282.42);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1082, TO_DATE('22-12-2024', 'DD-MM-YYYY'), 2020, 3008, 'Laptop', 2, 405.61);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1083, TO_DATE('29-06-2024', 'DD-MM-YYYY'), 2034, 3007, 'Laptop', 4, 93.38);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1084, TO_DATE('30-11-2024', 'DD-MM-YYYY'), 2041, 3002, 'Tablet', 1, 344.56);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1085, TO_DATE('23-05-2024', 'DD-MM-YYYY'), 2033, 3007, 'Laptop', 4, 839.94);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1086, TO_DATE('28-05-2024', 'DD-MM-YYYY'), 2037, 3008, 'Camera', 3, 816.67);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1087, TO_DATE('15-08-2024', 'DD-MM-YYYY'), 2007, 3003, 'Camera', 1, 658.02);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1088, TO_DATE('06-10-2024', 'DD-MM-YYYY'), 2022, 3004, 'Camera', 4, 399.70);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1089, TO_DATE('26-07-2024', 'DD-MM-YYYY'), 2032, 3002, 'Phone', 4, 347.12);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1090, TO_DATE('07-12-2024', 'DD-MM-YYYY'), 2014, 3010, 'Phone', 4, 811.74);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1091, TO_DATE('18-02-2024', 'DD-MM-YYYY'), 2008, 3006, 'Camera', 1, 116.92);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1092, TO_DATE('01-11-2024', 'DD-MM-YYYY'), 2025, 3010, 'Phone', 2, 699.39);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1093, TO_DATE('10-03-2024', 'DD-MM-YYYY'), 2016, 3010, 'Phone', 4, 411.69);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1094, TO_DATE('18-06-2024', 'DD-MM-YYYY'), 2042, 3003, 'Headphones', 4, 652.23);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1095, TO_DATE('12-06-2024', 'DD-MM-YYYY'), 2019, 3001, 'Phone', 3, 930.54);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1096, TO_DATE('05-04-2024', 'DD-MM-YYYY'), 2041, 3010, 'Headphones', 2, 861.24);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1097, TO_DATE('16-07-2024', 'DD-MM-YYYY'), 2016, 3002, 'Headphones', 4, 522.79);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1098, TO_DATE('04-04-2024', 'DD-MM-YYYY'), 2012, 3010, 'Phone', 4, 456.44);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1099, TO_DATE('13-09-2024', 'DD-MM-YYYY'), 2039, 3001, 'Phone', 2, 831.43);
INSERT INTO orders_1 (order_id, order_date, customer_id, product_id, product_name, quantity, price) VALUES (1100, TO_DATE('27-06-2024', 'DD-MM-YYYY'), 2048, 3007, 'Phone', 2, 751.32);

select count(*) from orders_1 ;

select * from orders_1;

--How can you calculate the total monthly revenue using PLSQL?

SELECT 
  TO_CHAR(order_date, 'YYYY-MM') AS month,
  SUM(price * quantity) AS monthly_revenue
FROM 
  orders_1
GROUP BY 
  TO_CHAR(order_date, 'YYYY-MM')
ORDER BY 
  month;
--
create or replace procedure ord_mon_rev is
begin
  for i in (SELECT TO_CHAR(order_date, 'YYYY-MM') AS month,
                   SUM(price * quantity) AS monthly_revenue
              FROM orders_1
             GROUP BY TO_CHAR(order_date, 'YYYY-MM')
             ORDER BY month) loop
    dbms_output.put_line('Month :' || i.month || ' Monthly Revenue : ' ||
                         i.monthly_revenue);
  end loop;
end;

begin
  ord_mon_rev;
end;

--Which products generated the highest sales revenue?


select *
  from (select max(price * quantity) as high_revenue, product_name
          from orders_1
         group by product_name
         order by high_revenue desc) orders_1
 where rownum = 1;

create or replace procedure pro_high_reve is
begin
  for i in (select *
              from (select max(price * quantity) as high_revenue,
                           product_name
                      from orders_1
                     group by product_name
                     order by high_revenue desc) orders_1
             where rownum = 1) loop
    dbms_output.put_line('Product Name :' || i.product_name ||
                         ' Highest Revenue : ' || i.high_revenue);
  end loop;
end;

begin
  pro_high_reve;
end;

--What is the average order value per month?

SELECT 
  TO_CHAR(order_date, 'YYYY-MM') AS month,
  round(AVG(price * quantity), 2) AS monthly_Average_revenue
FROM 
  orders_1
GROUP BY 
  TO_CHAR(order_date, 'YYYY-MM')
ORDER BY 
  month;

create or replace procedure avg_mon_reve is
begin
  for i in (SELECT TO_CHAR(order_date, 'YYYY-MM') AS month,
                   round(AVG(price * quantity), 2) AS monthly_Average_revenue
              FROM orders_1
             GROUP BY TO_CHAR(order_date, 'YYYY-MM')
             ORDER BY month) loop
    dbms_output.put_line('Month :' || i.month || ' Average Revenue : ' ||
                         i.monthly_Average_revenue);
  end loop;
end;

begin
  avg_mon_reve ;
end;

--How can you find the top 5 customers by total purchase amount?

select *
  from (select customer_id, sum(price * quantity) as total_purchase
          from orders_1
         group by customer_id
         order by total_purchase desc) orders_1
 where rownum <= 5;

create or replace procedure top5_total_purch is
begin
  for i in (select *
              from (select customer_id,
                           sum(price * quantity) as total_purchase
                      from orders_1
                     group by customer_id
                     order by total_purchase desc) orders_1
             where rownum <= 5) loop
    dbms_output.put_line('Customer Id :' || i.customer_id ||
                         ' Total Purchase Amount : ' || i.total_purchase);
  end loop;
end;

begin
  top5_total_purch ;
end;

--How do you create a pivot table showing revenue by product and month?

SELECT *
FROM (
    SELECT 
        TO_CHAR(order_date, 'YYYY-MM') AS month,
        product_name,
        price * quantity AS revenue
    FROM 
        orders_1
)
PIVOT (
    SUM(revenue) FOR product_name IN (
        'Laptop' AS Laptop,
        'Tablet' AS Tablet,
        'Camera' AS Camera,
        'Headphones' AS Headphones,
        'Phone' AS Phone
    )
)
ORDER BY month;
---
create or replace procedure revenue_by_product is 
begin
  for i in (SELECT *
FROM (
    SELECT 
        TO_CHAR(order_date, 'YYYY-MM') AS month,
        product_name,
        price * quantity AS revenue
    FROM 
        orders_1
)
PIVOT (
    SUM(revenue) FOR product_name IN (
        'Laptop' AS Laptop,
        'Tablet' AS Tablet,
        'Camera' AS Camera,
        'Headphones' AS Headphones,
        'Phone' AS Phone
    )
)
ORDER BY month ) loop 
dbms_output.put_line ('Month: ' ||i.month ||'Loptop: '|| i.laptop ||
                             'Tablet: '|| i.tablet ||'Camera: ' ||i.camera||
                             'Headphones: ' || i.Headphones||'Phone: ' || i.Phone) ;
end loop;
end;

begin
  revenue_by_product;
end;

select * from orders_1;


------------------------------------------------------------------------------------------





SELECT * FROM (
  SELECT salary FROM hr.employees ORDER BY salary DESC
) WHERE ROWNUM <= 2;

SELECT * FROM (
  SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) AS rnk
  FROM hr.employees
) WHERE rnk = 2 and rownum <= 1;

 --Find employees who earn more than the maximum salary of any other department
select e.first_name ,e.salary from hr.employees e
where e.salary > all (select max(salary) from hr.employees 
WHERE department_id <> e.department_id group by department_id);



SELECT e.first_name, e.salary, e.department_id
FROM hr.employees e
WHERE e.salary > (
    SELECT MAX(salary)
    FROM hr.employees
    WHERE department_id <> e.department_id
   -- GROUP BY department_id
);


select max(salary), department_id from hr.employees group by department_id order by department_id desc;


--rownum
--rowid
SELECT *
FROM (
  SELECT department_id, MAX(salary) AS max_salary
  FROM hr.employees
  GROUP BY department_id
  ORDER BY MAX(salary) DESC
)
WHERE ROWNUM <= 3;


SELECT department_id, RANK() OVER (ORDER BY department_id)
FROM hr.employees; ----skip next rank if there is tie

SELECT department_id, dense_rank() OVER (ORDER BY department_id)
FROM hr.employees;

select department_id,rowid from hr.employees ;



create or replace procedure hr.show_ind(p_table_name  in varchar2,
                                     p_column_name in varchar2) is
                                     
index_count number ;
begin
  SELECT COUNT(*)
  INTO index_count
  FROM user_indexes I
  JOIN user_ind_columns C
    ON I.INDEX_NAME = C.INDEX_NAME
  WHERE C.COLUMN_NAME = UPPER(p_column_name)
    AND C.TABLE_NAME = UPPER(p_table_name);
    
    if index_count = 0 then
      execute immediate
      'CREATE INDEX '
    
  for rec in (select I.INDEX_NAME, C.COLUMN_NAME,count(*)
                from user_indexes I
                join user_ind_columns C
                  on I.INDEX_NAME = C.INDEX_NAME
               where C.COLUMN_NAME = p_column_name
                 and C.TABLE_NAME = p_table_name) loop
                 index_count := count(*) ;
    dbms_output.put_line('Index_name: ' || rec.INDEX_NAME ||'Column_name: '|| rec.COLUMN_NAME);
  end loop;
  
end;

alter procedure show_ind compile ;

declare
  table_name  varchar2(50) := 'EMPLOYEES';
  column_name varchar2(50) := 'EMPLOYEE_ID';
begin
  hr.show_ind('EMPLOYEES', 'EMPLOYEE_ID');
end;

select * from employees


--What is directory in oracle 
-- In Oracle a DIRECTORY is a database object that points to a physical directory (folder) on the servers file 
--system (the machine where the Oracle database is running).

--It tells Oracle where to read or write files on the server  but it doesnt store files itself.

CREATE TABLE emp2 (
  id NUMBER,
  name VARCHAR2(100)
);

select count(*) from emp2 ;


BEGIN
  INSERT INTO emp2 (id, name)
  SELECT LEVEL, 'Name_' || LEVEL
  FROM dual
  CONNECT BY LEVEL <= 10000000;

  COMMIT;
END;

select * from emp2

CREATE TABLE emp2 (
  id NUMBER,
  name VARCHAR2(100)
);

SELECT table_name, tablespace_name
FROM user_tables
WHERE table_name = 'EMP3';

INSERT /*+ APPEND */ INTO emp2 (id, name)
SELECT ROWNUM, 'Name_' || ROWNUM
FROM all_objects, all_objects
WHERE ROWNUM <= 10000000;

--Insert 10 million rows into the emp2 table.
--FROM all_objects, all_objects
--all_objects is a data dictionary view  it has metadata rows for every object in the 
--database (tables, views, indexes, etc.).
--Typically, all_objects has thousands of rows.
--By cross joining it with itself:
FROM all_objects, all_objects
--you get a Cartesian product  so if all_objects has 10,000 rows, you now get 10,000  10,000 = 100 million possible rows.
--The WHERE ROWNUM <= 10000000 limits it to the first 10 million rows.
--This is a fast trick to generate a big dataset without needing actual source data.
--
  /*+ APPEND */
--APPEND tells Oracle to do a Direct-Path Insert:
--Instead of inserting each row using the normal buffer and redo process,

COMMIT;

--So why this way?
--You used this pattern because:
--You needed lots of test data (10 million rows).
--Using all_objects, all_objects is a simple way to generate many rows from a small data source.
--ROWNUM ensures unique IDs from 1 to 10 million.
--The /*+ APPEND */ hint makes it faster and more efficient than a normal insert.

CREATE OR REPLACE DIRECTORY export_dir AS 'C:\app\Namdev\export';
--Here, export_dir is the logical name, and 'C:\app\Namdev\export' is the actual 
--folder path on your server machine (not your local PC if youre connected remotely).


DECLARE
  v_file UTL_FILE.FILE_TYPE;
BEGIN
  v_file := UTL_FILE.FOPEN('EXPORT_DIR', 'emp2_data.csv', 'w');
  UTL_FILE.PUT_LINE(v_file, 'id|name');
  FOR rec IN (SELECT id, name FROM emp2) LOOP
    UTL_FILE.PUT_LINE(v_file, rec.id || '|' || rec.name);
  END LOOP;
  UTL_FILE.FCLOSE(v_file);
END;
/
--Whats happening here?

--a) DECLARE
--You declare a variable v_file of type UTL_FILE.FILE_TYPE.
--UTL_FILE is Oracles package to handle file input/output.

--
v_file := UTL_FILE.FOPEN('EXPORT_DIR', 'emp2_data.csv', 'w');

--This opens (or creates) the file named emp2_data.csv in the EXPORT_DIR directory.
--'w' means write mode  if the file exists, it will overwrite it.

--
UTL_FILE.PUT_LINE(v_file, 'id|name');

--This writes a header row: id|name  useful if you want column names in your CSV.

--
  FOR rec IN (SELECT id, name FROM emp2) LOOP
  UTL_FILE.PUT_LINE(v_file, rec.id || '|' || rec.name);
  END LOOP;

--This FOR loop fetches each row from your emp2 table.
--For each row, it writes id|name in pipe-separated format.

--
UTL_FILE.FCLOSE(v_file);

--Always close the file to save and flush data.


-- Check directory object
SELECT * FROM ALL_DIRECTORIES WHERE DIRECTORY_NAME = 'EXPORT_DIR';

--To verify that the EXPORT_DIR object exists and points to the correct path.
--ALL_DIRECTORIES is a data dictionary view that lists all defined Oracle directories.

SELECT COUNT(*) FROM emp2;


-- Allow AB to create directories
GRANT CREATE ANY DIRECTORY TO AB;

-- If SYS creates the directory, grant access to AB
-- Example: SYS runs:
CREATE OR REPLACE DIRECTORY EXPORT_DIR AS 'C:\app\Namdev\export';

-- Then SYS grants permissions on it to AB:
GRANT READ, WRITE ON DIRECTORY EXPORT_DIR TO AB;

-- Allow AB to use UTL_FILE
GRANT EXECUTE ON UTL_FILE TO AB;


---------------------------------------- 09-07-025 Wedbesday  W3resorces --------------------------------------

-- 1. Write a program in PL/SQL to show the uses of static PL/SQL statement.

-- 9. Write a program in PL/SQL to display a cursor based detail information of employees from employees table.

declare
  cursor emp is
    select employee_id, first_name, last_name, email, job_title
      from employees;

  emp_info emp%rowtype;
begin
  open emp;
  loop
    fetch emp
      into emp_info;
    exit when emp%notfound;
    dbms_output.put_line('employee info: ' || 'Id: ' ||
                         emp_info.employee_id || ' F_name: ' ||
                         emp_info.first_name || ' L_name: ' ||
                         emp_info.last_name || ' Email: ' ||
                         emp_info.email || ' Job_title: ' ||
                         emp_info.job_title);
  
  end loop;
  close emp;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Backtrace: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;


select * from employees ;

--10. Write a program in PL/SQL to retrieve the records from the employees table and display them using cursors.

declare
  cursor emp is
    select employee_id, first_name, last_name from hr.employees;
  v_emp_id hr.employees.employee_id%type;
  v_fname  hr.employees.first_name%type;
  v_lname  hr.employees.last_name%type;
begin
  open emp;
  loop
    fetch emp
      into v_emp_id, v_fname, v_lname;
    exit when emp%notfound;
    dbms_output.put_line('Id: ' || v_emp_id || ' Fname: ' || v_fname ||
                         ' Lname: ' || v_lname);
  end loop;
  close emp;
exception
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Backtrace: ' ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;

--11. Write a program in PL/SQL to declare a record datatype with same datatype of tables using %TYPE attribute.


DECLARE
  CURSOR cur_emp_detail IS
    SELECT employee_id, first_name, last_name, salary FROM hr.employees;
  TYPE type_record_type IS RECORD(
    emp_id       hr.employees.employee_id%TYPE,
    emp_f_name   hr.employees.first_name%TYPE,
    emp_l_name   hr.employees.last_name%TYPE,
    emp_s_salary hr.employees.salary%TYPE);
  emp_rec_type type_record_type;
BEGIN
  OPEN cur_emp_detail;
  LOOP
    FETCH cur_emp_detail
      INTO emp_rec_type;
    EXIT WHEN cur_emp_detail%NOTFOUND;
    dbms_output.Put_line('Employees Information::  ' || '  ID: ' ||
                         emp_rec_type.emp_id || '|   Name: ' ||
                         emp_rec_type.emp_f_name || ' ' ||
                         emp_rec_type.emp_l_name || '|   Salary: ' ||
                         emp_rec_type.emp_s_salary);
  END LOOP;
  dbms_output.Put_line('Total number of Employees : ' ||
                       cur_emp_detail%rowcount);
  CLOSE cur_emp_detail;
END;
/*"In this version, I use a custom RECORD type to group related columns with custom names.
It gives me flexibility in naming and lets me standardize how I handle data, 
but I have to keep the record structure in sync with the SELECT list manually."*/
/* When to use
When you want custom field names that are different from column names.

When you want to pass structured data between program units.*/


DECLARE
  CURSOR cur_emp_detail IS
    SELECT employee_id, first_name, last_name, salary FROM hr.employees;
    emp_id       hr.employees.employee_id%TYPE;
    emp_f_name   hr.employees.first_name%TYPE;
    emp_l_name   hr.employees.last_name%TYPE;
    emp_s_salary hr.employees.salary%TYPE;
  --emp_rec_type type_record_type;
BEGIN
  OPEN cur_emp_detail;
  LOOP
    FETCH cur_emp_detail
      INTO emp_id,emp_f_name,emp_l_name,emp_s_salary;
    EXIT WHEN cur_emp_detail%NOTFOUND;
    dbms_output.Put_line('Employees Information::  ' || '  ID: ' ||
                         emp_id || '|   Name: ' ||
                         emp_f_name || ' ' ||
                         emp_l_name || '|   Salary: ' ||
                         emp_s_salary);
  END LOOP;
  dbms_output.Put_line('Total number of Employees : ' ||
                       cur_emp_detail%rowcount);
  CLOSE cur_emp_detail;
END;
/*"This is the simplest approach: I declare one variable for each column, so the FETCH maps directly.
Its easy for a few columns, but if the query grows, this style is hard to maintain."*/
/*When to use
Small queries with few columns.

Ad hoc scripts or very simple anonymous blocks.*/

DECLARE
  CURSOR cur_emp_detail IS
    SELECT employee_id, first_name, last_name, salary FROM hr.employees;

  emp_rec_type cur_emp_detail%rowtype;
BEGIN
  OPEN cur_emp_detail;
  LOOP
    FETCH cur_emp_detail
      INTO emp_rec_type;
    EXIT WHEN cur_emp_detail%NOTFOUND;
    dbms_output.Put_line('Employees Information::  ' || '  ID: ' ||
                         emp_rec_type.employee_id || '|   Name: ' ||
                         emp_rec_type.first_name || ' ' ||
                         emp_rec_type.last_name || '|   Salary: ' ||
                         emp_rec_type.salary);
  END LOOP;
  dbms_output.Put_line('Total number of Employees : ' ||
                       cur_emp_detail%rowcount);
  CLOSE cur_emp_detail;
END;
/*-"I use the cursors %ROWTYPE to automatically match the structure of the SELECT list.
This is easy to maintain  if I add or remove columns, I dont need to update my variable declaration manually.
Its more robust and less error-prone for large rows."*/
/*When to use
Best practice for static cursors when you want to fetch entire rows or partial rows.

Default choice for most real projects  safer than custom record or multiple scalars.*/

--12. Write a program in PL/SQL to create an implicit cursor with for loop.

BEGIN
  FOR emprec IN (SELECT department_name,
                        d.department_id,
                        first_name,
                        last_name,
                        job_id,
                        salary
                   FROM hr.departments d
                   join hr.employees e
                     ON e.department_id = d.department_id
                  WHERE job_id = 'ST_CLERK'
                    AND salary > 3000) LOOP
    dbms_output.Put_line('Name: ' || emprec.first_name || ' ' ||
                         emprec.last_name || chr(9) || ' Department: ' ||
                         emprec.department_name || chr(9) ||
                         ' Department ID: ' || emprec.department_id ||
                         chr(9) || ' Job ID: ' || emprec.job_id || chr(9) ||
                         ' Salary: ' || emprec.salary);
  END LOOP;
END;

--13. Write a program in PL/SQL to create an explicit cursor with for loop.

---implicit cursor FOR loop
begin
  for rec in (select * from hr.employees) loop
    dbms_output.put_line(rec.employee_id || ' ' || rec.first_name || ' ' ||
                         rec.last_name);
  end loop;
end;

---explicit cursor FOR loop
DECLARE
  CURSOR emp_cur IS
    SELECT employee_id, first_name, last_name FROM hr.employees;
BEGIN
  FOR rec IN emp_cur LOOP
    DBMS_OUTPUT.PUT_LINE(rec.employee_id || ' ' || rec.first_name || ' ' || rec.last_name);
  END LOOP;
END;

--14. Create a PL/SQL block to increase salary of employees in the department 50 using WHERE CURRENT OF clause.

DROP TABLE emp_temp;

CREATE TABLE emp_temp AS
  SELECT employee_id,
         first_name,
         last_name,
		 department_id,
         salary
  FROM   hr.employees;

DECLARE
  CURSOR employee_cur IS
    SELECT employee_id, salary
      FROM emp_temp
     WHERE department_id = 50
       FOR UPDATE;
  incr_sal NUMBER;
BEGIN
  FOR employee_rec IN employee_cur LOOP
    IF employee_rec.salary < 15000 THEN
      incr_sal := .15;
    ELSE
      incr_sal := .10;
    END IF;
  
    UPDATE emp_temp
       SET salary = salary + salary * incr_sal
     WHERE CURRENT OF employee_cur;
  END LOOP;
  EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);

END;

select * from emp_temp where salary < 15000 ;


---------------------------------------- 10-07-025 Wedbesday  W3resorces --------------------------------------

for update cursor
  DECLARE
  CURSOR emp_cur IS
    SELECT employee_id, salary
    FROM emp_temp
    WHERE department_id = 110
    FOR UPDATE;

  v_increment NUMBER;
BEGIN
  FOR rec IN emp_cur LOOP
    IF rec.salary < 15000 THEN
      v_increment := 0.15;
    ELSE
      v_increment := 0.10;
    END IF;

    UPDATE emp_temp
    SET salary = salary + (salary * v_increment)
    WHERE CURRENT OF emp_cur;
  END LOOP;

  COMMIT;  -- Always commit to release the locks!
END;
/

select * from emp_temp where department_id = 110 ;

/* Task:
Write a PL/SQL block that uses an explicit cursor to display all employees 
in the Sales department (department_id = 80), showing:
Employee ID
Full name
Salary
Use manual OPEN, FETCH, CLOSE  no FOR LOOP*/.

declare
  cursor emp is
    select employee_id, first_name, last_name, salary
      from hr.employees
     where department_id = 80;
  emp_id     hr.employees.employee_id%type;
  emp_fname  hr.employees.first_name%type;
  emp_lname  hr.employees.last_name%type;
  emp_salary hr.employees.salary%type;
begin
  open emp;
  loop
    fetch emp
      into emp_id, emp_fname, emp_lname, emp_salary;
    exit when emp%notfound;
    dbms_output.put_line('EmpId: ' || emp_id || ' Full_name: ' ||
                         emp_fname || ' ' || emp_lname || ' Salary: ' ||
                         emp_salary);
  end loop;
  close emp;
exception
  when no_data_found then
    dbms_output.put_line('No employee in department 80');
  when others then
    dbms_output.put_line('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Backtrace: ' ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;


 /*Task:
Write a PL/SQL block using a cursor FOR loop to display all job titles and 
total number of employees for each job_id in the employees table.

Tip: Use SELECT job_id, COUNT(*) FROM employees GROUP BY job_id.
*/

declare
  cursor emp is
    SELECT job_id, COUNT(*) as total FROM hr.employees GROUP BY job_id;
begin
  for rec in emp loop
    dbms_output.put_line(rec.job_id || ' Total_Emp_is: ' || rec.total);
  end loop;
exception
  when others then
    dbms_output.put_line('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Backtrace: ' ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;

/* Cursor with FOR UPDATE + WHERE CURRENT OF:
     Task:
Update the salaries of all employees in department 110:

If salary < 11000, increase by 15%

Else, increase by 10%

Use a FOR UPDATE cursor with WHERE CURRENT OF.
Display the employee ID and new salary inside the loop.
End with a COMMIT.*/

declare
  cursor emp is
    select employee_id, salary
      from emp_temp
     where department_id = 110
       for update;
  v_salary number;
begin
  for rec in emp loop
    if rec.salary < 11000 then
      v_salary := 0.15;
    else
      v_salary := 0.10;
    end if;
  
    update emp_temp
       set salary = salary + (salary * v_salary)
     where current of emp;
     
     DBMS_OUTPUT.PUT_LINE('Updated Emp ID: ' || rec.employee_id || ' New Salary: ' ||
                     TO_CHAR(rec.salary + (rec.salary * v_salary)));

  end loop;
  commit;
exception
  when others then
    dbms_output.put_line('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Backtrace: ' ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
end;
 
 select employee_id, salary from emp_temp where department_id = 110

/*Strong REF CURSOR procedure:
     Task:
Write a stored procedure that takes a department_id as input and returns a strong REF CURSOR 
with all employees in that department.

Then write an anonymous block to call it and display the result using DBMS_OUTPUT.*/
  
create or replace procedure p_emp (i_dpt_id in number ) is
DECLARE
  TYPE emp_cur_type IS REF CURSOR RETURN hr.employees%ROWTYPE;
  emp_cursor emp_cur_type;
  emp_record hr.employees%ROWTYPE;
BEGIN
  OPEN emp_cursor FOR SELECT * FROM hr.employees WHERE department_id = 90;

  LOOP
    FETCH emp_cursor INTO emp_record;
    EXIT WHEN emp_cursor%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(emp_record.first_name || ' - ' || emp_record.salary);
  END LOOP;

  CLOSE emp_cursor;
  exception
  when others then
    dbms_output.put_line('Error: ' || SQLERRM);
    DBMS_OUTPUT.PUT_LINE('Backtrace: ' ||
                         DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END;

--- corrected 
CREATE OR REPLACE PACKAGE emp_pkg IS
  TYPE emp_ref_cursor IS REF CURSOR RETURN hr.employees%ROWTYPE;

  PROCEDURE p_emp(i_dpt_id IN NUMBER, o_emp OUT emp_ref_cursor);
END emp_pkg;

CREATE OR REPLACE PACKAGE BODY emp_pkg IS
  PROCEDURE p_emp(i_dpt_id IN NUMBER, o_emp OUT emp_ref_cursor) IS
  BEGIN
    OPEN o_emp FOR
      SELECT * FROM hr.employees WHERE department_id = i_dpt_id;
  END;
END emp_pkg;

DECLARE
  emp_cursor emp_pkg.emp_ref_cursor;
  emp_record hr.employees%ROWTYPE;
BEGIN
  emp_pkg.p_emp(90, emp_cursor);  -- Call procedure with department_id 90

  LOOP
    FETCH emp_cursor INTO emp_record;
    EXIT WHEN emp_cursor%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE('Name: ' || emp_record.first_name ||
                         ', Salary: ' || emp_record.salary);
  END LOOP;

  CLOSE emp_cursor;
END;









/*Challenge: Cursor + BULK COLLECT + FORALL
     Task:
Write a PL/SQL block that:

Uses an explicit cursor or SELECT to fetch all employees with salary < 6000 into a collection using BULK COLLECT.

Uses FORALL to update them to increase their salary by 20%.

Display total rows updated.*/




---------------------------------------
declare
  type aa is table of varchar2(50);
  bb aa;
  -- v_first_name varchar2(40);
begin
  select first_name, last_name
    bulk collect
    into bb
    from hr.employees
   where employee_id between 101 and 105;
  for i in 1 .. bb.count loop
    dbms_output.put_line(bb(i));
  end loop;
end;


declare
  type aa is table of hr.employees%rowtype;
  bb aa;
  -- v_first_name varchar2(40);
begin
  select *
    bulk collect
    into bb
    from hr.employees
   where employee_id between 101 and 105;
  for i in 1 .. bb.count loop
    dbms_output.put_line(bb(i).first_name || ' ' || bb(i).last_name || ' ' || bb(i)
                         .salary);
  end loop;
end;


declare
  type aa is record(
    first_name hr.employees.first_name%type,
    last_name  varchar2(80));

  type nested_t is table of aa;

  v_names nested_t;
  counter number := 0;
begin
  select first_name, last_name bulk collect into v_names from hr.employees;

  for i in v_names.first .. v_names.last loop
    dbms_output.put_line(v_names(i)
                         .first_name || ' ' || v_names(i).last_name);
    counter := counter + 1;
  end loop;
  dbms_output.put_line('counter is : ' || counter);
end;

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

------ Cursor 5 Quation

--Q1. Write an explicit cursor to display employee name and department name.
--Using tables: employees and departments.
--Also handle the case where department name is NULL (print No Department).

declare
  cursor emp is
    select e.first_name, d.department_name
      from hr.employees e
      left join hr.departments d
        on e.department_id = d.department_id;

  v_name     varchar2(40);
  v_dpt_name varchar2(40);
begin
  open emp;
  loop
    fetch emp
      into v_name, v_dpt_name;
    exit when emp%notfound;
  
    dbms_output.put_line(v_name || ' ' || nvl(v_dpt_name, 'No department'));
  
  end loop;
  close emp;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace || SQLERRM);
end;

--Q2. Write a cursor that increases salary by 10% for all employees working in Accounting department.
--Using: departments.department_name = 'Accounting'
--Update salaries using WHERE CURRENT OF.
--(Interviewers love this one.)
declare
  cursor emp is
    select employee_id, salary
      from employee1 e
      join hr.departments d
        on e.department_id = d.department_id
     where d.department_name = 'Accounting'
       for update;
  v_emp_id number;
  v_sal    number;
  new_sal  number;
begin
  open emp;
  loop
    fetch emp
      into v_emp_id, v_sal;
    exit when emp%notfound;
    dbms_output.put_line('Before salary update of : ' || v_emp_id ||
                         ' is ' || v_sal);
    new_sal := v_sal +(v_sal * 0.10);
    update employee1 set salary = new_sal where current of emp;
    dbms_output.put_line('After salary update of : ' || v_emp_id || ' is ' ||
                         new_sal);
  
  end loop;
  close emp;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace);
end;

--using bulk collect 
declare
  type c_v_id is table of employee1.employee_id%type;
  type c_v_sal is table of employee1.salary%type;
  type c_v_rowid is table of rowid;

  v_emp_id c_v_id;
  v_sal    c_v_sal;
  v_row    c_v_rowid;

begin
  select e.employee_id, e.salary, e.rowid
    bulk collect
    into v_emp_id, v_sal, v_row
    from employee1 e
    join hr.departments d
      on e.department_id = d.department_id
   where d.department_name = 'Accounting';

  for i in 1 .. v_sal.count loop
    dbms_output.put_line('Before salary update : ' || v_emp_id(i) ||
                         ' is ' || v_sal(i));
    v_sal(i) := v_sal(i) * 1.10;
    dbms_output.put_line('After salary update : ' || v_emp_id(i) || ' is ' ||
                         v_sal(i));
  end loop;

  forall i in 1 .. v_sal.count
    update employee1 set salary = v_sal(i) where rowid = v_row(i);

  dbms_output.put_line(v_emp_id.count || ' employees sallary updated !');

exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace || SQLERRM);
end;

--Q3. Write a cursor to fetch all employees hired in a given year and count them.
--Ask the user for a year (e.g., 2005), then use a cursor to:
--fetch records
--print employee names
--finally print the total employee count.

select employee_id, extract(year from hire_date) as hire_dates
  from employee1
 where extract(year from hire_date) = 2005;

declare
  cursor emp(which_year number) is
    select first_name || ' ' || last_name as emp_name,
           employee_id,
           extract(year from hire_date) as hire_dates
      from employee1
     where extract(year from hire_date) = which_year;

  v_emp_name      varchar2(50);
  v_emp_id        number;
  v_year          varchar2(10);
  total_employees number := 0;

begin
  open emp(&_num);
  loop
    fetch emp
      into v_emp_name, v_emp_id, v_year;
    exit when emp%notfound;
    dbms_output.put_line('Employee_name : ' || v_emp_name ||
                         ' Employee_id : ' || v_emp_id || ' Year is : ' ||
                         v_year);
  
    total_employees := total_employees + 1;
  end loop;
  dbms_output.put_line('Total Employees is : ' || total_employees);
  close emp;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace || SQLERRM);
end;


-- Q4.Write a cursor to fetch employees whose salary is below 20000.
--Delete these employees using WHERE CURRENT OF.
--Print employee_id and message "Deleted" for each.

declare
  cursor emp is
    select employee_id from employee1 where salary < 5000 for update;

  v_emp_id number;
begin
  open emp;
  loop
    fetch emp
      into v_emp_id;
    exit when emp%notfound;
    dbms_output.put_line('Employee_id : ' || v_emp_id || ' is Deleted !');
    delete from employee1 where current of emp;
  end loop;
  close emp;
exception
  when others then
    dbms_output.put_line(dbms_utility.format_error_stack ||
                         dbms_utility.format_error_backtrace || SQLERRM);
end;

rollback;

-- Q5.Create a parameterized cursor that fetches employees from a given department.
--Ask user to input department name (e.g., 'Sales').
--Print employee_id, name, and department name for all employees in that department.

declare
  cursor cur(dpt_name varchar2) is
    select employee_id, first_name, department_name
      from employee1 e
      join hr.departments d
        on e.department_id = d.department_id
     where lower(department_name) = lower(dpt_name);

  v_emp_id   number;
  v_emp_name varchar2(50);
  v_dpt_name varchar2(50);

  dept varchar2(30) := '&_char';
begin
  open cur(dept);
  loop
    fetch cur
      into v_emp_id, v_emp_name, v_dpt_name;
    exit when cur%notfound;
    dbms_output.put_line(v_emp_id || ' ' || v_emp_name || ' ' ||
                         v_dpt_name);
  end loop;
  close cur;
exception
  when others then
    dbms_output.put_line(SQLCODE || SQLERRM);
end;
--Using bulk collect
declare
  type huge is record(
    v_emp_id   number,
    v_emp_name varchar2(50),
    v_dpt_name varchar2(50));

  type cur is table of huge;
  v_record cur;
begin
  select employee_id, first_name, department_name
    bulk collect
    into v_record
    from employee1 e
    join hr.departments d
      on e.department_id = d.department_id
   where lower(department_name) = lower('sales');

  for i in 1 .. v_record.count loop
    dbms_output.put_line(v_record(i)
                         .v_emp_id || ' ' || v_record(i).v_emp_name || ' ' || v_record(i)
                         .v_dpt_name);
  end loop;
exception
  when others then
    dbms_output.put_line(SQLCODE || SQLERRM);
  
end;


--Procedure 5Q

--Q1. Procedure With IN, OUT, IN OUT Parameters (Real Scenario)

--Write a procedure get_emp_stats that takes department_id (IN parameter),
--returns total employees (OUT parameter),
--and average salary (OUT parameter).
--Also print all employee names inside the procedure.

create or replace procedure get_emp_stats(dpt_id      in number,
                                          v_total_emp out number,
                                          v_avg_sal   out number) is
  cursor cur is
    select first_name from employee1 where department_id = dpt_id;
  v_name varchar2(40);
begin
  select count(*), avg(salary)
    into v_total_emp, v_avg_sal
    from employee1
   where department_id = dpt_id;
   -- Using normal loop
 /* open cur;
  loop
    fetch cur
      into v_name;
    exit when cur%notfound;
    dbms_output.put_line(v_name);
  end loop;
  close cur;*/
  
  --Using for loop
  for i in cur loop
    dbms_output.put_line(i.first_name);
    end loop;
exception
  when others then
    dbms_output.put_line(SQLCODE || SQLERRM);
end;

declare
  v_total number;
  v_avg   number;
begin
  get_emp_stats(10, v_total, v_avg);
  dbms_output.put_line(v_total);
  dbms_output.put_line(v_avg);
end;

--using ref-cursor
CREATE OR REPLACE PROCEDURE get_emp_stats_ref(
    dpt_id      IN NUMBER,
    v_total_emp OUT NUMBER,
    v_avg_sal   OUT NUMBER
) IS
    TYPE ref_cursor_type IS REF CURSOR;
    emp_cursor ref_cursor_type;

    v_name employee1.first_name%TYPE;
BEGIN
    -- 1) Calculate OUT parameters
    SELECT COUNT(*), AVG(salary)
      INTO v_total_emp, v_avg_sal
      FROM employee1
     WHERE department_id = dpt_id;

    -- 2) Open REF CURSOR to fetch employee names
    OPEN emp_cursor FOR
      SELECT first_name
      FROM employee1
     WHERE department_id = dpt_id;

    LOOP
        FETCH emp_cursor INTO v_name;
        EXIT WHEN emp_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee: ' || v_name);
    END LOOP;

    CLOSE emp_cursor;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No employees found in department ' || dpt_id);
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE || ' - ' || SQLERRM);
END;

DECLARE
    v_total NUMBER;
    v_avg   NUMBER;
BEGIN
    get_emp_stats_ref(10, v_total, v_avg);
    DBMS_OUTPUT.PUT_LINE('Total Employees = ' || v_total);
    DBMS_OUTPUT.PUT_LINE('Average Salary  = ' || v_avg);
END;

--Using bulk collect
CREATE OR REPLACE PROCEDURE get_emp_stats_ref(dpt_id      IN NUMBER,
                                              v_total_emp OUT NUMBER,
                                              v_avg_sal   OUT NUMBER) IS
  TYPE colection IS table of employee1.first_name%type;
  emp_cursor colection;

  --v_name employee1.first_name%TYPE;
BEGIN
  -- 1) Calculate OUT parameters
  SELECT COUNT(*), AVG(salary)
    INTO v_total_emp, v_avg_sal
    FROM employee1
   WHERE department_id = dpt_id;

  select first_name
    bulk collect
    into emp_cursor
    from employee1
   where department_id = dpt_id;

  for i in 1 .. emp_cursor.count loop
    dbms_output.put_line(emp_cursor(i));
  end loop;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('No employees found in department ' || dpt_id);
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE || ' - ' || SQLERRM);
END;

DECLARE
  v_total NUMBER;
  v_avg   NUMBER;
BEGIN
  get_emp_stats_ref(10, v_total, v_avg);
  DBMS_OUTPUT.PUT_LINE('Total Employees = ' || v_total);
  DBMS_OUTPUT.PUT_LINE('Average Salary  = ' || v_avg);
END;



--Q2. Procedure With Exception Handling & Validation

--Create a procedure update_salary that
--Accepts employee_id and hike percentage
--Validates: if hike > 20%, raise custom exception
--Updates the salary
--Writes success or error message using DBMS_OUTPUT
--Logs errors into an error_log table
--(Create the error_log table yourself in the question.)
select * from error_log ;

create or replace procedure update_salary(emp_id in number,
                                          v_hike in float) is
  salary_hick exception;

  v_log number;
begin
  if v_hike > 0.20 then
    raise salary_hick;
  end if;

  update employee1
     set salary = salary + (salary * v_hike)
   where employee_id = emp_id;

  dbms_output.put_line('salary updated sucessfully');

  select nvl(max(log_id), 0) + 1 into v_log from error_log;

  insert into error_log
    (log_id, error_message, log_time)
  values
    (v_log, 'salary update sucessful', sysdate);

exception
  when salary_hick then
    dbms_output.put_line('salay hicking by > 20 % is not aalowed');
    select nvl(max(log_id), 0) + 1 into v_log from error_log;
  
    insert into error_log
      (log_id, error_message, log_time)
    values
      (v_log, 'salary update failed', sysdate);
  when others then
    dbms_output.put_line(SQLCODE || SQLERRM);
end;

begin
update_salary(101, 0.30);
end;

select * from error_logS
order by log_id desc ;
















